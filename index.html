<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="写一个赚乾的程序">
<meta property="og:type" content="website">
<meta property="og:title" content="程序乾">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="程序乾">
<meta property="og:description" content="写一个赚乾的程序">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="乾">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>程序乾</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序乾</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 23:50:59" itemprop="dateCreated datePublished" datetime="2023-08-13T23:50:59+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 00:48:52" itemprop="dateModified" datetime="2023-08-14T00:48:52+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h2><h3 id="单体架构："><a href="#单体架构：" class="headerlink" title="单体架构："></a>单体架构：</h3><p>将业务的所有功能集中在一个项目中开发，打包成一个包部署</p>
<p>优点：架构简单，部署成本低</p>
<p>缺点：耦合度高</p>
<h3 id="分布式架构："><a href="#分布式架构：" class="headerlink" title="分布式架构："></a>分布式架构：</h3><p>根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务</p>
<p>优点：降低服务耦合</p>
<p>服务治理</p>
<p>需要考虑的问题：</p>
<p>服务拆分粒度如何？</p>
<p>服务集群地址如何维护？</p>
<p>服务之间如何实现远程调用？</p>
<p>服务健康程度如何？</p>
<h3 id="微服务："><a href="#微服务：" class="headerlink" title="微服务："></a>微服务：</h3><p>微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征：</p>
<p>单一职责： 微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发</p>
<p>面向服务：微服务对外暴露业务接口</p>
<p>自治：团队独立，技术独立，数据独立，部署独立</p>
<p>隔离性强：服务调用做好隔离，容错，降级，避免出现级联问题</p>
<h3 id="微服务技术对比："><a href="#微服务技术对比：" class="headerlink" title="微服务技术对比："></a>微服务技术对比：</h3><p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MyBlog\图片\image-20221117214336117.png" alt="image-20221117214336117"></p>
<h3 id="SpringCloud："><a href="#SpringCloud：" class="headerlink" title="SpringCloud："></a>SpringCloud：</h3><p>目前使用最广泛的微服务框架</p>
<p>SpringCloud集成了各种微服务组件，并做了自动装配，十分方便。</p>
<p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MyBlog\图片\image-20221117214744817.png" alt="image-20221117214744817"></p>
<h3 id="服务拆分及远程调用："><a href="#服务拆分及远程调用：" class="headerlink" title="服务拆分及远程调用："></a>服务拆分及远程调用：</h3><p>服务拆分注意事项：</p>
<p>1.不同微服务，不要重复开发相同业务</p>
<p>2.微服务数据独立，不要访问其他微服务的数据库</p>
<p>3.微服务可以将自己的业务暴露为接口，供其他微服务调用</p>
<h2 id="分布式服务架构案例"><a href="#分布式服务架构案例" class="headerlink" title="分布式服务架构案例"></a>分布式服务架构案例</h2><p>1.微服务调用方式</p>
<p>​	基于RestTemplate发起的http请求实现远程调用</p>
<p>​	http请求做远程调用是与语言无关的调用，只要知道对方的ip，端口，接口路径，请求参数即可</p>
<h3 id="提供者与消费者"><a href="#提供者与消费者" class="headerlink" title="提供者与消费者"></a>提供者与消费者</h3><p>服务提供者：一次业务中，被其他微服务调用的服务。（提供接口给其他微服务）</p>
<p>服务消费者：一次业务中，调用其他微服务的服务。（调用其他微服务提供的接口）</p>
<h2 id="eureka注册中心"><a href="#eureka注册中心" class="headerlink" title="eureka注册中心"></a>eureka注册中心</h2><h3 id="远程调用的问题"><a href="#远程调用的问题" class="headerlink" title="远程调用的问题"></a>远程调用的问题</h3><p>调用时的http地址硬编码，需要动态编码</p>
<h3 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a>Eureka的作用</h3><p>消费者如何获取提供者具体信息？</p>
<p>​	服务提供者启动时向eureka注册自己的信息</p>
<p>​	eureka保存这些信息</p>
<p>​	消费者根据服务名称向eureka拉取提供者信息</p>
<p>如果有多个服务提供者，消费者该如何选择？</p>
<p>​	服务消费者利用负载均衡算法，从服务列表中挑选一个</p>
<p>消费者如何感知服务提供者健康状态？</p>
<p>​	服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</p>
<p>​	eureka会更新记录服务列表信息，心跳不正常会被踢出</p>
<p>​	消费者就可以拉取到最新的信息</p>
<h3 id="eureka架构："><a href="#eureka架构：" class="headerlink" title="eureka架构："></a>eureka架构：</h3><p>EurekaServer：服务端，注册中心</p>
<p>​	记录服务信息</p>
<p>​	心跳监控</p>
<p>EurekaClient：客户端</p>
<p>​	Provider：服务提供者</p>
<p>​	consumer：服务消费者</p>
<h3 id="服务注册："><a href="#服务注册：" class="headerlink" title="服务注册："></a>服务注册：</h3><p>引入eureka-client依赖</p>
<p>在application.yml中配置eureka地址</p>
<h3 id="服务拉取："><a href="#服务拉取：" class="headerlink" title="服务拉取："></a>服务拉取：</h3><p>在order-server完成服务拉取</p>
<p>服务拉取是基于服务名称获取服务列表，然后在对服务列表做负载均衡</p>
<p>1.修改OrderService的代码，修改访问的url路径，用服务名代替ip，端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String url =&quot;http://userservice/user/&quot;+order.getUserId();</span><br></pre></td></tr></table></figure>

<p>2.在order-service项目的启动类OrderApplication中的RestTemplate添加负载均衡注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate restTemplate()&#123;</span><br><span class="line">	return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h2><p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Apple\项目\研究生课程资料\Typora\图片\image-20221118110239295.png" alt="image-20221118110239295"></p>
<h3 id="负载均衡策略："><a href="#负载均衡策略：" class="headerlink" title="负载均衡策略："></a>负载均衡策略：</h3><p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Apple\项目\研究生课程资料\Typora\图片\image-20221118110432121.png" alt="image-20221118110432121"></p>
<p>通过IRule实现可以修改负载均衡规则，有两种方式：</p>
<p>1.代码方式：在order-service中OrderApplication类中，定义一个新的IRule：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public IRule randoRule()&#123;</span><br><span class="line">	return new RandomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#针对某个微服务</span><br><span class="line">userservice:</span><br><span class="line">	ribbon:</span><br><span class="line">		NFLoadBalanceRuleClassName: com.netflix.loadbalancer.RandoRule </span><br></pre></td></tr></table></figure>

<h3 id="饥饿加载："><a href="#饥饿加载：" class="headerlink" title="饥饿加载："></a>饥饿加载：</h3><p>Ribbon默认采用懒加载，第一次访问时才会去创建LoadBalanceClient，请求事件会很长。</p>
<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过以下配置开启饥饿加载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">	eager-load:</span><br><span class="line">		enabled: true #开启饥饿加载</span><br><span class="line">		clients: userservice #指定对userservice这个服务饥饿加载</span><br></pre></td></tr></table></figure>

<h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><p>服务的注册和发现，是阿里巴巴的产品，相比Eureka功能丰富点。</p>
<h3 id="Nacos服务搭建"><a href="#Nacos服务搭建" class="headerlink" title="Nacos服务搭建"></a>Nacos服务搭建</h3><p>下载安装包</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p>
<p>解压</p>
<p>在bin目录下运行指令：startup.cmd -m standalone</p>
<h3 id="Nacos服务注册或发现"><a href="#Nacos服务注册或发现" class="headerlink" title="Nacos服务注册或发现"></a>Nacos服务注册或发现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">引入nacos.discovery依赖</span><br><span class="line"></span><br><span class="line">配置nacos地址spring.cloud.nacos.server-addr</span><br></pre></td></tr></table></figure>

<h3 id="Nacos服务分级存储模型"><a href="#Nacos服务分级存储模型" class="headerlink" title="Nacos服务分级存储模型"></a>Nacos服务分级存储模型</h3><p>服务—&gt;集群—-&gt;实例</p>
<p><strong>服务集群属：</strong></p>
<p>1.修改application.yml，添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	cloud:</span><br><span class="line">		nacos:</span><br><span class="line">			server-addr: loaclhost:8848 #nacos服务端地址</span><br><span class="line">			discovery:</span><br><span class="line">				cluster-name: HZ #配置集群名称，即机房位置</span><br><span class="line">				</span><br></pre></td></tr></table></figure>

<p><strong>环境隔离</strong></p>
<h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>服务提供者分为临时实例和非临时实例，临时实例类似eureka心跳检测，非临时实例会主动发请求问是否存在</p>
<h3 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h3><p>在Nacos中添加配置文件</p>
<p>1.引入Nacos的配置管理客户端依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.在userservice中的resource目录添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	application:</span><br><span class="line">		name: userservice #服务名称</span><br><span class="line">	profiles:</span><br><span class="line">		active: dev</span><br><span class="line">	cloud:</span><br><span class="line">		nacos:</span><br><span class="line">			server-addr: localhost:8848</span><br><span class="line">			config:</span><br><span class="line">				file-extension: yaml # 文件后缀名</span><br></pre></td></tr></table></figure>

<p><strong>配置热更新</strong></p>
<p>方式一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过@Value注解注入，结合@RefreshScope来刷新</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过@ConfigurationProperties注入，自动刷新</span><br></pre></td></tr></table></figure>

<p><strong>多环境配置共享</strong></p>
<p>微服务启动时会从nacos读取多个配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[spring.application.name]-[spring.profiles.active].yaml 例如：userservice-dev.yaml</span><br><span class="line"></span><br><span class="line">[spring.application.name].yaml 例如：userservice.yaml</span><br></pre></td></tr></table></figure>

<p>无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件</p>
<p>服务名-profile.yaml&gt;服务名称.yaml&gt;本地配置</p>
<h3 id="集群搭建步骤"><a href="#集群搭建步骤" class="headerlink" title="集群搭建步骤"></a>集群搭建步骤</h3><p>1.搭建Mysql集群并初始化数据库表</p>
<p>2.下载解压nacos</p>
<p>3.修改集群配置（节点信息），数据库配置</p>
<p>4.分别启动多个nacos节点</p>
<p>5.nginx反向代理</p>
<h2 id="http客户端Feign"><a href="#http客户端Feign" class="headerlink" title="http客户端Feign"></a>http客户端Feign</h2><p>Feign是一个声明式http客户端，官方地址：<a target="_blank" rel="noopener" href="http://github.com/OpenFeign/feign">http://github.com/OpenFeign/feign</a></p>
<p>其作用是实现http请求的发送，解决上面提到的问题</p>
<h3 id="使用Feign的步骤"><a href="#使用Feign的步骤" class="headerlink" title="使用Feign的步骤"></a>使用Feign的步骤</h3><p>1.引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.在order-service的启动类添加注解开启Feign的功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableFeignClients</span><br><span class="line">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class OrderApplication&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		SpringApplication.run(OrderApplication.class,args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.编写Feign客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(&quot;userservice&quot;)</span><br><span class="line">public interface UserClient&#123;</span><br><span class="line">	</span><br><span class="line">	@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="line">	User findById(@PathVariable(&quot;id&quot;) Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p>
<p>服务名称： userservice</p>
<p>请求方式：GET</p>
<p>请求路径：&#x2F;usr&#x2F;{id}</p>
<p>请求参数： Long id</p>
<p>返回值类型： User</p>
<h3 id="自定义Feign的配置"><a href="#自定义Feign的配置" class="headerlink" title="自定义Feign的配置"></a>自定义Feign的配置</h3><p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Users\peanut\AppData\Roaming\Typora\typora-user-images\image-20221119103505499.png" alt="image-20221119103505499"></p>
<h3 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h3><p>Feign底层的客户端实现：</p>
<p>URLConnection：默认实现，不支持连接池</p>
<p>Apache HttpClient： 支持连接池</p>
<p>OKHttp：支持连接池</p>
<p>因此优化Feign的性能主要包括：</p>
<p>1.使用连接池代替默认的URLConnection</p>
<p>2.日志级别，最好用basic或none</p>
<p><strong>连接池配置</strong></p>
<p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置连接池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">	client:</span><br><span class="line">		config:</span><br><span class="line">			default:</span><br><span class="line">				loggerLevel: BASIC</span><br><span class="line">	httpclient:</span><br><span class="line">		enabled: true</span><br><span class="line">		max-connections: 200</span><br><span class="line">		max-connections-per-route: 50 </span><br></pre></td></tr></table></figure>

<h3 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h3><p>1.让controller和FeignClient继承同一接口</p>
<p>2.将FeignClient，Pojo，Feign的默认配置都定义到一个项目中，供所有消费者使用</p>
<h2 id="统一网关"><a href="#统一网关" class="headerlink" title="统一网关"></a>统一网关</h2><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>身份认证和权限校验</p>
<p>服务路由，负载均衡</p>
<p>请求限流</p>
<h3 id="网关的技术实现"><a href="#网关的技术实现" class="headerlink" title="网关的技术实现"></a>网关的技术实现</h3><p>关键步骤：</p>
<p>1.创建项目，引入nacos服务发现和gateway依赖</p>
<p>2.配置application.yml，包括服务基本信息、nacos地址、路由</p>
<p>路由配置包括：</p>
<p>1.路由id：路由的唯一标示</p>
<p>2.路由目标(uri)：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p>
<p>3.路由断言（predicates)：判断路由的规则</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>不同环境下，docker可以兼容</p>
<p>docker将用户程序与所需要调用的系统函数库一起打包</p>
<h3 id="初识docker"><a href="#初识docker" class="headerlink" title="初识docker"></a>初识docker</h3><p>虚拟机是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在windows系统里面运行Ubuntu系统，这样就可以运行任意的ubuntu应用</p>
<h4 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h4><p>镜像：docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像</p>
<p>容器：镜像中的应用程序运行后形成的进程就是容器，知识Docker会给容器做隔离，对外不可见</p>
<p>DockerHub：是Docker镜像的托管平台</p>
<p>docker架构：CS架构，有两部分组成</p>
<p>​	服务端：Docker守护进程，负责处理Docker指令，管理镜像，容器等</p>
<p>​	客户端：通过命令或RestAPI向Docker服务端发送指令，可以在本地或远程向服务端发送指令</p>
<h3 id="安装Dcoker"><a href="#安装Dcoker" class="headerlink" title="安装Dcoker"></a>安装Dcoker</h3><p>分为CE和EE两大版本，CE社区版（免费，支持周期7个月）</p>
<h4 id="在CentOS安装Docker"><a href="#在CentOS安装Docker" class="headerlink" title="在CentOS安装Docker"></a>在CentOS安装Docker</h4><p>如果之前安装过，可以使用下面命令卸载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">				docker-client \</span><br><span class="line">				docker-client-latest \</span><br><span class="line">				docker-common \</span><br><span class="line">				docker-latest \</span><br><span class="line">				docker-latest-logrotate \</span><br><span class="line">				docker-logrotate \</span><br><span class="line">				docker-selinux \</span><br><span class="line">				docker-engine-selinux \</span><br><span class="line">				docker-engine \</span><br><span class="line">				docker-ce</span><br></pre></td></tr></table></figure>

<p>安装yum工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 --skip-broken</span><br></pre></td></tr></table></figure>

<p>配置本地镜像源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">	--add-repo \</span><br><span class="line">	https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p>安装命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><p>正常是去逐一修改防火墙，打开需要用到的端口</p>
<p>这里简化，直接关闭防火墙</p>
<p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl run docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>配置国内镜像</p>
<p>参考国内阿里云的镜像加速文档：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<h3 id="Docker基本操作"><a href="#Docker基本操作" class="headerlink" title="Docker基本操作"></a>Docker基本操作</h3><p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MyBlog\图片\image-20221219111044609.png" alt="image-20221219111044609"></p>
<h4 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pause</span><br><span class="line">docker unpause</span><br><span class="line">docker stop</span><br><span class="line">docker start</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<p>创建一个Nignx容器</p>
<p>步骤一：去docker hub查看Nginx的容器运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>

<p>进入容器，修改HTML文件内容</p>
<p>步骤一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [name] bash</span><br></pre></td></tr></table></figure>

<p>步骤二：进入nginx的HTML所在目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/share/nginx/html</span><br></pre></td></tr></table></figure>

<p>步骤三：修改index.html的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s#Welcome to nginx#qian qian huan ying ni#g&#x27; index.html</span><br><span class="line">sed -i &#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27; index.html</span><br></pre></td></tr></table></figure>

<h4 id="操作数据卷"><a href="#操作数据卷" class="headerlink" title="操作数据卷"></a>操作数据卷</h4><p>数据卷(volume)：将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</p>
<p>数据卷操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume --help</span><br><span class="line">查看volume的所有操作</span><br></pre></td></tr></table></figure>

<h4 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h4><p>创建容器时，可以通过-v参数来挂载一个数据卷到某个容器目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">	--name mn \</span><br><span class="line">	-v html:/root/html \</span><br><span class="line">	-p 8080:80 \</span><br><span class="line">	ngnix \</span><br></pre></td></tr></table></figure>

<h4 id="Dockerfile自定义镜像"><a href="#Dockerfile自定义镜像" class="headerlink" title="Dockerfile自定义镜像"></a>Dockerfile自定义镜像</h4><p>镜像结构：</p>
<p>将应用程序及其需要的系统函数库、环境、配置、依赖打包而成</p>
<p>自定义镜像：</p>
<p>Dockerfile是一个文本文件，其中包含一个个的指令，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定基础镜像</td>
<td>FROM centos:6</td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量，可在后面指令使用</td>
<td>ENV key value</td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝本地文件到镜像的指定目录</td>
<td>COPY .&#x2F;mysql-5.7.rpm &#x2F;tmp</td>
</tr>
<tr>
<td>RUN</td>
<td>执行Linux的shell命令，一般是安装过程的命令</td>
<td>RUN yum install gcc</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>指定容器运行时监听的端口，是给镜像使用者看的</td>
<td>EXPOSE 8080</td>
</tr>
<tr>
<td>ENTRYOINT</td>
<td>镜像中应用的启动命令，容器运行时调用</td>
<td>ENTRYPOINT java -jar xx.jar</td>
</tr>
</tbody></table>
<p>案例：</p>
<p>步骤一：</p>
<p>建立一个空文件夹docker-demo</p>
<p>步骤二：</p>
<p>拷贝课前资料中的docker-demo.jar文件到docker-demo这个目录</p>
<p>步骤三：</p>
<p>拷贝课前资料中的jadk8.tar.gz文件到docker-demo这个目录</p>
<p>步骤四：</p>
<p>拷贝课前资料提供的Dockerfile到docker-demo这个目录</p>
<p>步骤五：</p>
<p>进入docker-demo</p>
<p>步骤六：</p>
<p>运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure>

<h3 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h3><p>Compose文件是一个文本文件，通过指定定义集群中的每个容器如何运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line">services:</span><br><span class="line">	mysql:</span><br><span class="line">		image: mysql:5.7.25</span><br><span class="line">		environment:</span><br><span class="line">		MYSQL_ROOT_PASSWORD: 123</span><br><span class="line">		volumes:</span><br><span class="line">		- /tmp/mysql/data:/var/lib/mysql</span><br><span class="line">		- /tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf</span><br><span class="line">	web:</span><br><span class="line">		build: .</span><br><span class="line">		ports:</span><br><span class="line">		- 8090: 8090</span><br></pre></td></tr></table></figure>

<p>DockerCompose的安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.29.1/docker-compose-&#x27;uname -s&#x27;-&#x27;uname -m&#x27; &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br><span class="line"></span><br><span class="line">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>

<h3 id="Docker镜像仓库"><a href="#Docker镜像仓库" class="headerlink" title="Docker镜像仓库"></a>Docker镜像仓库</h3><p>搭建私有镜像仓库</p>
<h2 id="服务异步通讯"><a href="#服务异步通讯" class="headerlink" title="服务异步通讯"></a>服务异步通讯</h2><h3 id="初识MQ"><a href="#初识MQ" class="headerlink" title="初识MQ"></a>初识MQ</h3><p>同步通讯</p>
<p>同步调用会随着业务的增多速度加慢</p>
<p>异步通讯</p>
<p>异步调用常见的实现就是事件驱动模式</p>
<p>MQ（MessageQueue) 是用来存放消息的队列，也就是事件驱动的Broker</p>
<h3 id="RabbitMQ快速入门"><a href="#RabbitMQ快速入门" class="headerlink" title="RabbitMQ快速入门"></a>RabbitMQ快速入门</h3><p>安装RabbitMQ：</p>
<p>单机部署：在线拉取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p>执行下面命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-e RABBITMQ_DEFAULT_USER=qian \</span><br><span class="line">-e RABBITMQ_DEFAULT_PASS=1126 \</span><br><span class="line">--name mq \</span><br><span class="line">--hostname mq1 \</span><br><span class="line">-p 15672:15672 \</span><br><span class="line">-p 5672:5672 \</span><br><span class="line">-d \</span><br><span class="line">rabbitmq:3-management</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MyBlog\图片\image-20230313161341123.png" alt="image-20230313161341123"></p>
<p>常见的消息模型：</p>
<p>MQ的官方文档中给出了5个MQ的Demo示例，对应了以下不用用法：</p>
<p>1.基本消息队列(BasicQueue)</p>
<p>2.工作消息队列(WorkQueue)</p>
<p>3.发布订阅(Publish、Subscribe)</p>
<p>​	广播、路由和主题</p>
<h3 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h3><p>AMQP是用于在应用程序之间传递业务消息的开放标准，该协议与语言和平台无关，更符合微服务中的需求</p>
<p>利用SpringAMQP实现基础消息队列功能</p>
<p>1.在父工程中引入spring-amqp的依赖</p>
<p>2.在publisher服务中利用RabbitTemplate发送消息到simple.queue这个对列</p>
<p>3.在consumer服务中编写消费逻辑，绑定simple.queue这个队列</p>
<h3 id="发布、订阅"><a href="#发布、订阅" class="headerlink" title="发布、订阅"></a>发布、订阅</h3><p>Fanout :将接收的消息路由到每一个跟其绑定的queue</p>
<h2 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h2><h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch:"></a>elasticsearch:</h3><p>是一款强大的开源搜索引擎，可以帮助我们从海量数据中快速找到需要的内容。</p>
<p>elasticsearch结合kibana、Logstash、Beats组合成elastic stack技术栈</p>
<h3 id="正向索引和倒排索引："><a href="#正向索引和倒排索引：" class="headerlink" title="正向索引和倒排索引："></a>正向索引和倒排索引：</h3><p>正向索引按照id进行搜索</p>
<p>倒排索引按照词条进行分词，记录对应词条id，搜索时先对词语进行分词，去词条表查询文档id，根据文档id查找文档</p>
<h3 id="安装es："><a href="#安装es：" class="headerlink" title="安装es："></a>安装es：</h3><p>单点部署es</p>
<p>1.创建网络：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure>

<p>2.加载镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拉取镜像</span><br><span class="line">docker pull elasticsearch:7.12.1</span><br></pre></td></tr></table></figure>

<p>3.运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name es \</span><br><span class="line">-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">-v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">--privileged \</span><br><span class="line">--network es-net \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure>

<h3 id="部署kibana："><a href="#部署kibana：" class="headerlink" title="部署kibana："></a>部署kibana：</h3><p>kibana可以提供一个elasticsearch的可视化界面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=es-net \</span><br><span class="line">-p 5601:5601 \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure>

<p>中文分词器一般使用IK分词器</p>
<p>安装ik插件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#进入容器内部</span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"></span><br><span class="line">#在线下载并安装</span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br><span class="line"></span><br><span class="line">#退出</span><br><span class="line">exit</span><br><span class="line">#重启容器</span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure>

<h3 id="索引库操作："><a href="#索引库操作：" class="headerlink" title="索引库操作："></a>索引库操作：</h3><p>mapping<strong>映射属性</strong></p>
<p>对索引库中文档的约束，常见属性包括：</p>
<p>type：字段数据类型，简单类型：</p>
<p>​	字符串：text（可分词）、keyword（精确值）</p>
<p>​	数值：long、integer、short、byte、double、float</p>
<p>​	布尔：boolean</p>
<p>​	日期：date</p>
<p>​	对象：object</p>
<p>index：是否创建索引，默认为true</p>
<p>analyzer：使用哪种分词器</p>
<p>properties：一个字段的子字段</p>
<h4 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h4><p>通过Restful请求操作索引库、文档。请求内容用DSL语句来表示。创建索引库和mapping的DSL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line">&#123;</span><br><span class="line">	&quot;mappings&quot;:&#123;</span><br><span class="line">		&quot;properties&quot;:&#123;</span><br><span class="line">			&quot;字段名&quot;:&#123;</span><br><span class="line">				&quot;type&quot;:&quot;text&quot;,</span><br><span class="line">				&quot;analyzer&quot;:&quot;ik_smart&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;字段名2&quot;:&#123;</span><br><span class="line">				&quot;type&quot;:&quot;keyword&quot;,</span><br><span class="line">				&quot;index&quot;:&quot;false&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;字段名3&quot;:&#123;</span><br><span class="line">				&quot;properties&quot;:&#123;</span><br><span class="line">					&quot;子字段&quot;:&#123;</span><br><span class="line">						&quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查看、删除索引库："><a href="#查看、删除索引库：" class="headerlink" title="查看、删除索引库："></a>查看、删除索引库：</h4><p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure>

<h4 id="修改索引库："><a href="#修改索引库：" class="headerlink" title="修改索引库："></a>修改索引库：</h4><p>不允许修改索引库</p>
<p>但可以添加新字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line">&#123;</span><br><span class="line">	&quot;properties&quot;:&#123;</span><br><span class="line">		&quot;新字段名&quot;：&#123;</span><br><span class="line">			&quot;type&quot;:&quot;integer&quot;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文档操作："><a href="#文档操作：" class="headerlink" title="文档操作："></a>文档操作：</h3><h4 id="新增文档："><a href="#新增文档：" class="headerlink" title="新增文档："></a>新增文档：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">	&quot;字段1&quot;:&quot;值1&quot;,</span><br><span class="line">	&quot;字段2&quot;:&quot;值2&quot;,</span><br><span class="line">	&quot;字段3&quot;:&#123;</span><br><span class="line">		&quot;子属性1&quot;:&quot;值3&quot;,</span><br><span class="line">		&quot;子属性2&quot;:&quot;值4&quot;,</span><br><span class="line">		&#125;,</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h4><p>全量修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">	&quot;字段1&quot;:&quot;值1&quot;,</span><br><span class="line">	&quot;字段2&quot;:&quot;值2&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">	&quot;doc&quot;:&#123;</span><br><span class="line">		&quot;字段名&quot;:&quot;新的值&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RestClient"><a href="#RestClient" class="headerlink" title="RestClient:"></a>RestClient:</h3><p>一个客户端用来操作文档</p>
<p>初始化JavaRestClient:</p>
<p>1.引入es的RestHighLevelClient依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.因为SpringBoot默认的ES版本是7.6.2，所以需要覆盖默认的ES版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;java.version&gt;1.8&lt;/java.version&gt;     &lt;elasticsearch.version&gt;7.12.1&lt;/elasticsearch.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<p>3.初始化RestHighLevelClient：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RestHighLevelClient client=new RestHighLevelClient(RestClient.builder(HttpHost.create(&quot;http://192.168.150.101:9200&quot;)));</span><br></pre></td></tr></table></figure>

<h3 id="DSL查询语法："><a href="#DSL查询语法：" class="headerlink" title="DSL查询语法："></a>DSL查询语法：</h3><h4 id="全文检索查询："><a href="#全文检索查询：" class="headerlink" title="全文检索查询："></a>全文检索查询：</h4><p>match查询：全文检索查询的一种，会对用户输入内容分词，然后去倒排索引库检索，语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&quot;TEXT&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="精确查询："><a href="#精确查询：" class="headerlink" title="精确查询："></a>精确查询：</h4><p>term查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;term&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&#123;</span><br><span class="line">				&quot;value&quot;:&quot;VALUE&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>range查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;range&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&#123;</span><br><span class="line">				&quot;gte&quot;:10,</span><br><span class="line">				&quot;lte&quot;:20</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>地理查询：</p>
<p>根据经纬度查询</p>
<p>geo_bounding_box:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;geo_bounding_box&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&#123;</span><br><span class="line">				&quot;top_left&quot;:&#123;</span><br><span class="line">                    &quot;lat&quot;:10.1,</span><br><span class="line">                    &quot;lon&quot;:20.6</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;bottom_right&quot;:&#123;</span><br><span class="line">                    &quot;lat&quot;:10.1,</span><br><span class="line">                    &quot;lon&quot;:20.6</span><br><span class="line">				&#125;,</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复合查询：</p>
<p>function score：</p>
<h3 id="搜索结果处理："><a href="#搜索结果处理：" class="headerlink" title="搜索结果处理："></a>搜索结果处理：</h3><p>默认是根据额相关度算分来排序。可排序的字段类型有：keyword类型、数值类型、地理坐标类型和日期类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;sort&quot;:[</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;FIELD&quot;:&quot;desc&quot; //排序字段和排序方式ASC,DESC</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分页：</strong></p>
<p>默认情况下只返回top10的数据</p>
<p>通过修改from、size参数来控制要返回的分页结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match_all&quot;:&#123;&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;from&quot;:990,</span><br><span class="line">	&quot;size&quot;:10,</span><br><span class="line">	&quot;sort&quot;:[</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;FIELD&quot;:&quot;desc&quot; //排序字段和排序方式ASC,DESC</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>深度分页问题：</strong></p>
<p>ES是分布式，所以会面临深度分页问题。例如按price排序后，获取from&#x3D;990，size&#x3D;10的数据</p>
<p>1.首先在每个数据分片上都排序并查询前1000条文档</p>
<p>2.然后将所有节点的结果聚合，在内存中重新排序选出前1000条文档</p>
<p>3.最后从这1000条中，选取从990开始的10条文档</p>
<p><strong>高亮：</strong></p>
<p>就是在搜索结果中把搜索关键字突出显示</p>
<p>原理：将搜索结果中的关键字用标签标记出来；在页面中给标签添加css样式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;:&#123;</span><br><span class="line">		&quot;match&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&quot;TEXT&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;highlight&quot;:&#123;</span><br><span class="line">		&quot;fileds&quot;:&#123;</span><br><span class="line">			&quot;FIELD&quot;:&#123;</span><br><span class="line">				&quot;pre_tags&quot;:&quot;&lt;em&gt;&quot;;</span><br><span class="line">				&quot;post_tags&quot;:&quot;&lt;/em&gt;&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据聚合："><a href="#数据聚合：" class="headerlink" title="数据聚合："></a>数据聚合：</h3><p>聚合式实现对文档数据的统计、分析、运算。常见聚合有三类：</p>
<p>桶（Bucket）聚合：用来对文档做分组</p>
<p>​	TermAggregation：按照文档字段值分组</p>
<p>​	Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</p>
<p>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等</p>
<p>​	Avg：平均</p>
<p>​	Max：求最大</p>
<p>​	Min：求最小</p>
<p>​	Stats：同时求max、min、avg、sum等</p>
<p>管道（pipeline）聚合：其他聚合的结果为基础做聚合</p>
<h4 id="DSL实现Bucket聚合："><a href="#DSL实现Bucket聚合：" class="headerlink" title="DSL实现Bucket聚合："></a>DSL实现Bucket聚合：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;size&quot;:0, //设置size为0，结果中不包含文档，只包含聚合结果</span><br><span class="line">	&quot;aggs&quot;:&#123; //定义聚合</span><br><span class="line">		&quot;brandAgg&quot;:&#123; //给聚合设置的名字</span><br><span class="line">			&quot;terms&quot;:&#123; //聚合的类型，按照品牌值聚合，所以选择term</span><br><span class="line">				&quot;filed&quot;:&quot;brand&quot;, //参与聚合的字段</span><br><span class="line">				&quot;size&quot;:20 //聚合结果的数量</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动补全："><a href="#自动补全：" class="headerlink" title="自动补全："></a>自动补全：</h4><p>拼音分词器：</p>
<p>实现根据字母做补全，对文档按照拼音分词。</p>
<p>地址：<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p>
<p>安装类似ik分词器：</p>
<p>解压</p>
<p>上传到虚拟机中，elasticsearch的plugin目录</p>
<p>重启elasticsearch</p>
<p>测试</p>
<p>自定义分词器：</p>
<p>elasticsearch中分词器的组成包含三部分：</p>
<p>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</p>
<p>tokenizer：将文本按照一定的规则切割成词条。例如：keyword；ik_smart</p>
<p>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;analysis&quot;:&#123;</span><br><span class="line">			&quot;analyzer&quot;:&#123;</span><br><span class="line">				&quot;my_analyzer&quot;:&#123;</span><br><span class="line">					&quot;tokenizer&quot;:&quot;ik_max_word&quot;,</span><br><span class="line">					&quot;filter&quot;:&quot;pinyin&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据同步："><a href="#数据同步：" class="headerlink" title="数据同步："></a>数据同步：</h4><p>elasticsearch中的数据来自于mysql，因此mysql数据发生改变时，elasticsearch也必须改变，即数据同步</p>
<p>方案一：同步调用</p>
<p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MyBlog\图片\image-20230327162941480.png" alt="image-20230327162941480"></p>
<p>方案二：</p>
<p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MyBlog\图片\image-20230327163140280.png" alt="image-20230327163140280"></p>
<p>方案三：监听binlog</p>
<p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Users\peanut\AppData\Roaming\Typora\typora-user-images\image-20230327163230858.png" alt="image-20230327163230858"></p>
<h3 id="elasticsearch集群："><a href="#elasticsearch集群：" class="headerlink" title="elasticsearch集群："></a>elasticsearch集群：</h3><p>海量数据存储问题：将索引库从逻辑上拆分为N个分片，存储到多个节点</p>
<p>单点故障问题：将分片数据在不同节点备份</p>
<h2 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h2><h3 id="初识Sentinel："><a href="#初识Sentinel：" class="headerlink" title="初识Sentinel："></a>初识Sentinel：</h3><p>雪崩问题以及解决方案：</p>
<p>微服务链路中调用某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。</p>
<p>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。</p>
<p>舱壁模式：限定每个业务能使用的线程数，避免耗尽整个tomcat的资源，也叫线程隔离。</p>
<p>熔断降级：由短路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。</p>
<p>流量控制：限制业务访问的QPS，避免服务因流量的突增而故障。</p>
<h3 id="安装Sentinel控制台："><a href="#安装Sentinel控制台：" class="headerlink" title="安装Sentinel控制台："></a>安装Sentinel控制台：</h3><p>去github上下载：<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases/tag/1.8.1">https://github.com/alibaba/Sentinel/releases/tag/1.8.1</a></p>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure>

<p>访问本地8080端口，用户密码都是sentinel</p>
<h3 id="微服务整合Sentinel："><a href="#微服务整合Sentinel：" class="headerlink" title="微服务整合Sentinel："></a>微服务整合Sentinel：</h3><p>在order-server中整合Sentinel，并且连接Sentinel控制台，步骤如下：</p>
<p>1.引入sentinel依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.配置控制台地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	cloud:</span><br><span class="line">		sentinel:</span><br><span class="line">			transport:</span><br><span class="line">				dashboard: localhost:8080</span><br></pre></td></tr></table></figure>

<p>3.访问微服务的任意端点，触发sentinel监控</p>
<h3 id="限流规则："><a href="#限流规则：" class="headerlink" title="限流规则："></a>限流规则：</h3><p>簇点链路：</p>
<p>项目中的调用链路，链路中被监控的每个接口就是一个资源。默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint），因此SpringMVC的每一个端点就是调用链路中的一个资源。</p>
<p>流控模是-关联：</p>
<p>关联模式：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流。</p>
<p>使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p>
<p>流控模式-链路：</p>
<p>链路模式：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p>
<h3 id="隔离和降级："><a href="#隔离和降级：" class="headerlink" title="隔离和降级："></a>隔离和降级：</h3><p>Feign整合Sentinel</p>
<p>在SpringCloud中，微服务调用都是通过Feign来实现的，客户端保护必须整合Feign和Sentinel，步骤如下：</p>
<p>1.修改OrderService的application.yml文件，开启Feign的Sentinel功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">	sentinel:</span><br><span class="line">		enabled: true</span><br></pre></td></tr></table></figure>

<p>2.给FeignClient编写失败后的降级逻辑</p>
<p>方式一：FallbackClass，无法对远程调用的异常做处理</p>
<p>方式二：FallbackFactory，可以对远程调用的异常做处理，一般选这个</p>
<p>熔断降级：</p>
<p>其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求；当服务恢复时，断路器会放行访问该服务的请求。</p>
<h2 id="分布式事务："><a href="#分布式事务：" class="headerlink" title="分布式事务："></a>分布式事务：</h2><p>事务的ACID原则：</p>
<p>CAP定理：</p>
<p>分布式系统有三个指标：</p>
<p>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致</p>
<p>Availability（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</p>
<p>Partition tolerance（分区容错性）：因为网络故障或其他原因导致分布式系统中的部分节点与其他节点失去连接，形成独立分区，在集群出现分区时，整个系统也要持续对外提供服务</p>
<p>分布式系统无法同时满足这三个指标</p>
<p>BASE理论：</p>
<p>对CAP的一种解决思路，包含三个思想：</p>
<p>Basically Available：分布式系统在出现故障时，允许损失部分可用性，保证核心可用</p>
<p>Soft State：在一定时间内，允许出现中间状态，比如临时的不一致状态</p>
<p>Eventually Consistent：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</p>
<h3 id="分布式事务模型："><a href="#分布式事务模型：" class="headerlink" title="分布式事务模型："></a>分布式事务模型：</h3><p>解决分布式事务，各个子系统之间必须能感知到彼此事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）。</p>
<h3 id="初识Seata："><a href="#初识Seata：" class="headerlink" title="初识Seata："></a>初识Seata：</h3><p>由蚂蚁金服和阿里巴巴共同开发的开源分布式事务解决方案。</p>
<p>官网地址：<a target="_blank" rel="noopener" href="http://seata.io/">http://seata.io/</a></p>
<p>Seata事务管理中有三个重要的角色：</p>
<p>TC（Transaction Coordinator）-事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚</p>
<p>TM（Transaction Manager）-事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务</p>
<p>RM（Resource Manager）-资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<h3 id="部署TC："><a href="#部署TC：" class="headerlink" title="部署TC："></a>部署TC：</h3><p>修改seata中conf配置的registry.conf中的注册和配置改为nacoos</p>
<p>然后在nacos中添加seataServer.properties</p>
<h3 id="微服务集成Seata："><a href="#微服务集成Seata：" class="headerlink" title="微服务集成Seata："></a>微服务集成Seata：</h3><p>1.首先，引入seata相关依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--seata--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">                    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.seata&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>2.然后，配置application.yml，让微服务通过注册中心找到seata-tc-server:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">seata:</span><br><span class="line">  registry:</span><br><span class="line">    type: nacos</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: 127.0.0.1:8848</span><br><span class="line">      namespace: &quot;&quot;</span><br><span class="line">      group: DEFAULT_GROUP</span><br><span class="line">      application: seata-tc-server</span><br><span class="line">      username: nacos</span><br><span class="line">      password: nacos</span><br><span class="line">  tx-service-group: seata-demo # 事务组名称</span><br><span class="line">  service:</span><br><span class="line">    vgroup-mapping: # 事务组与cluster的映射关系</span><br><span class="line">      seata-demo: SH</span><br></pre></td></tr></table></figure>

<h3 id="几种模式原理："><a href="#几种模式原理：" class="headerlink" title="几种模式原理："></a>几种模式原理：</h3><h4 id="XA模式："><a href="#XA模式：" class="headerlink" title="XA模式："></a>XA模式：</h4><p>XA规范描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对XA规范提供了支持。</p>
<p>实现XA模式：</p>
<p>1.修改application.yml文件（要参与事务的微服务）开启XA模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seata:</span><br><span class="line">	data-source-proxy-mode: XA</span><br></pre></td></tr></table></figure>

<p>2.给发起全局事务的入口方法添加@GlobalTransaction注解，本例中是OrderServiceImpl中的create方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@GlobalTransactional</span><br><span class="line">public Long create(Order order)&#123;</span><br><span class="line">	orderMapper.insert(order);</span><br><span class="line">	</span><br><span class="line">	return order.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.重启服务并测试</p>
<h4 id="AT模式原理："><a href="#AT模式原理：" class="headerlink" title="AT模式原理："></a>AT模式原理：</h4><p>同样是分段提交的事务模型，弥补了XA模式中资源锁定周期过长的缺陷。</p>
<p>在RM中执行sql并提交，记录更新前后快照，undo-log</p>
<p>实现AT模式</p>
<p>AT模式的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，实现简单。</p>
<p>1.首先导入提供的测试Sql文件：seata-at.sql,其中lock_table导入到TC服务关联的数据库，undo_log表导入到微服务关联的数据库: seata-at.sql</p>
<p>2.修改application.yml，奖事务模式修改为AT模式即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seata：</span><br><span class="line">	data-source-proxy-mode: AT</span><br></pre></td></tr></table></figure>

<p>3.重启服务并测试</p>
<h4 id="TCC模式原理："><a href="#TCC模式原理：" class="headerlink" title="TCC模式原理："></a>TCC模式原理：</h4><p>TCC模式与AT模式相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p>
<p>Try：资源的检测和预留</p>
<p>Confirm：完成资源操作业务；要求Try成功Confirm一定能成功</p>
<p>Cancel：预留资源释放，可以理解为try的反向操作</p>
<h4 id="Saga模式："><a href="#Saga模式：" class="headerlink" title="Saga模式："></a>Saga模式：</h4><p>长事务解决方案。分为两个阶段：</p>
<p>一阶段：直接提交本地事务</p>
<p>二阶段：成功则什么都不做；失败则通过编写补偿业务回滚</p>
<h2 id="分布式缓存："><a href="#分布式缓存：" class="headerlink" title="分布式缓存："></a>分布式缓存：</h2><p>单点Redis的问题：</p>
<p>数据丢失问题：实现Redis数据持久化</p>
<p>并发能力问题：搭建主从集群，实现读写分离</p>
<p>存储能力问题：搭建分片集群，利用插槽机制实现动态扩容</p>
<p>故障恢复问题：利用Redis哨兵，实现健康检测和自动恢复</p>
<h3 id="Redis持久化："><a href="#Redis持久化：" class="headerlink" title="Redis持久化："></a>Redis持久化：</h3><h4 id="RDB持久化："><a href="#RDB持久化：" class="headerlink" title="RDB持久化："></a>RDB持久化：</h4><p>Redis Database Backup file （Redis数据备份文件），也叫Redis数据快照。简单来说就是把内存中的所有数据记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p>
<p>快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">save #由Redis主进程来执行RDB，会阻塞所有命令</span><br><span class="line">bgsave #开启子进程执行RDB，避免主进程收到影响</span><br></pre></td></tr></table></figure>

<p>Redis内部由触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#900秒内，如果至少有1个key被修改，则执行bgsave，如果是save &quot;&quot; 则表示禁用RDB</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>RDB的其他配置也可以在redis.conf文件中设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#是否压缩，建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">#RDB文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#文件保存的路径目录</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure>

<h4 id="RDB原理："><a href="#RDB原理：" class="headerlink" title="RDB原理："></a>RDB原理：</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件。</p>
<p>fork采用的是copy-on-write技术：</p>
<p>当主进程执行读操作时，访问共享内存</p>
<p>当主进程执行写操作时，则会拷贝一份数据，执行写操作</p>
<h4 id="AOF持久化："><a href="#AOF持久化：" class="headerlink" title="AOF持久化："></a>AOF持久化：</h4><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<p>AOF默认是关闭的，需要修改redis.conf配置文件来开启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>

<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#表示执行一次命令，立即记录到AOF文件</span><br><span class="line">appendfsync always</span><br><span class="line">#写命令执行完先放入AOF缓冲区，然后每隔1秒将缓冲数据写到AOF文件，是默认方案</span><br><span class="line">appendfsync everysec</span><br><span class="line">#写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br><span class="line">appendfsync no </span><br></pre></td></tr></table></figure>

<p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能</p>
<p>Redis也会在触发阈值时自动去重写AOF文件，阈值也可以在redis.conf中配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">#AOF文件体积最小多大以上才触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<h3 id="Redis主从："><a href="#Redis主从：" class="headerlink" title="Redis主从："></a>Redis主从：</h3><h4 id="搭建主从架构："><a href="#搭建主从架构：" class="headerlink" title="搭建主从架构："></a>搭建主从架构：</h4><p>单点Redis的并发能力有上限，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p>共三个节点，一个主节点，两个从节点。</p>
<p>为了模拟真实场景，在同一台虚拟机中开启3个redis实例，信息如下：</p>
<p>主机IP地址-三个PORT:7001-7003</p>
<p>1.准备实例和配置</p>
<p>在同一台虚拟机中开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录即工作目录。</p>
<p>例如创建三个文件夹，名字分别为7001，7002，7003</p>
<p>将redis-4.0.0&#x2F;redis.conf文件拷贝到三个目录中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp redis-4.0.0/redis.conf 7001</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e &#x27;s/6379/7001/g&#x27; -e &#x27;s/dir .\//dir \/local\/7001\//g&#x27; 7001/redis.conf</span><br><span class="line">sed -i -e &#x27;s/6379/7002/g&#x27; -e &#x27;s/dir .\//dir \/local\/7002\//g&#x27; 7002/redis.conf</span><br><span class="line">sed -i -e &#x27;s/6379/7003/g&#x27; -e &#x27;s/dir .\//dir \/local\/7003\//g&#x27; 7003/redis.conf</span><br></pre></td></tr></table></figure>

<p>修改每个实例的声明IP</p>
<p>虚拟机本身有多个IP，避免混乱，在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replica-announce-ip 192.168.124.100</span><br></pre></td></tr></table></figure>

<p>每个都修改，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;1a replica-announce-ip 192.168.124.100&#x27; 7001/redis.conf</span><br><span class="line">sed -i &#x27;1a replica-announce-ip 192.168.124.100&#x27; 7002/redis.conf</span><br><span class="line">sed -i &#x27;1a replica-announce-ip 192.168.124.100&#x27; 7003/redis.conf</span><br></pre></td></tr></table></figure>

<p>2.启动</p>
<p>redis-server .&#x2F;redis.conf</p>
<p>开启主从关系</p>
<p>三个实例没有任何关系，配置主从可以使用replicaof 或者slaveof 命令</p>
<p>有临时和永久两种模式：</p>
<p>修改配置文件（永久生效）</p>
<p>​	在redis.conf中添加一行配置：slaveof <masterip> <masterport></masterport></masterip></p>
<p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<h4 id="数据同步原理："><a href="#数据同步原理：" class="headerlink" title="数据同步原理："></a>数据同步原理：</h4><p>主从第一步同步是全量同步，slave重启后，则执行增量同步。</p>
<p><img src="/2023/08/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1/MyBlog\图片\image-20230402200837162.png" alt="image-20230402200837162"></p>
<p>master怎么判断slave是不是第一次同步数据？</p>
<p>Replication Id: 数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的id，slave则会集成master节点的id</p>
<p>offset: 偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时会记录当前同步的offset。如果slave的offset小于master的offset，则说明slave数据落后于mater，需要更新</p>
<h3 id="Redis哨兵："><a href="#Redis哨兵：" class="headerlink" title="Redis哨兵："></a>Redis哨兵：</h3><h4 id="哨兵的作用和原理："><a href="#哨兵的作用和原理：" class="headerlink" title="哨兵的作用和原理："></a>哨兵的作用和原理：</h4><p>实现主从集群的自动故障恢复。</p>
<p>监控：Sentinel会不断检查master和slave是否按照预期工作</p>
<p>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p>
<p>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p>
<p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p>
<p>​	主观下线：如果某Seniel节点发现某实例未在规定实践响应，则认为改实例主观下线</p>
<p>​	客观下线：若超过指定数量的sentinel都认为该实例主观下线，则该实例客观下线</p>
<p>选新的master：</p>
<p>​	首先判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds*10）则会排除该slave节点</p>
<p>​	然后，判断slave节点的slave-priority值，越小优先级越高</p>
<p>​	如果slave-priority一样，则判断slave节点的offset值，越大则数据越新，优先级别越高</p>
<p>​	最后判断slave节点的运行id大小，越小优先级越高</p>
<p>故障转移：</p>
<p>​	sentinel给备选的slave1节点发送 slaveof no one命令，使其成为master</p>
<p>​	sentinel给所有其他的slave发送slaveof <masterip> <masterport>，配置主从关系</masterport></masterip></p>
<p>​	最后，sentinel将故障节点标记未slave，当故障节点恢复后会自动成为新的master的slave节点</p>
<h4 id="搭建哨兵结构："><a href="#搭建哨兵结构：" class="headerlink" title="搭建哨兵结构："></a>搭建哨兵结构：</h4><p>搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。</p>
<p>准备三个Sentinel实例，配置ip地址和端口，PORT 为27001、27002、27003</p>
<p>准备实例和配置</p>
<p>创建Sentinel的文件目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mikdir s1 s2 s3</span><br></pre></td></tr></table></figure>

<p>在s1目录中创建一个sentinel.conf文件，添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.124.100</span><br><span class="line">sentinel monitor mymaster 192.168.124.100 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">dir &quot;/usr/local/s1&quot;</span><br></pre></td></tr></table></figure>

<p>启动</p>
<p>分别启动3个redis实例，启动命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第1个</span><br><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line"># 第2个</span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line"># 第3个</span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br></pre></td></tr></table></figure>

<p>测试</p>
<h4 id="Redis-Template的哨兵模式"><a href="#Redis-Template的哨兵模式" class="headerlink" title="Redis Template的哨兵模式"></a>Redis Template的哨兵模式</h4><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，即使更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p>
<p>首先，引入课前资料提供的Demo工程：</p>
<p>然后在pom文件中引入redis的starter依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;denpendency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>接着在配置文件application.yml中指定sentinel相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring：</span><br><span class="line">	redis：</span><br><span class="line">		sentinel:</span><br><span class="line">			master: mymaster</span><br><span class="line">			nodes:</span><br><span class="line">				-IP:27001</span><br><span class="line">				-IP:27002</span><br><span class="line">				-IP:27003</span><br></pre></td></tr></table></figure>

<p>配置主从读写分离</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public LettuceClientConfigurationBuilderCustomizer ConfigurationBuilderCustomizer()&#123;</span><br><span class="line">	return configBuilder -&gt; configBuilder.readForm(ReadForm.REPLICA_PREFERRED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadForm是配置Redis的读取策略，是一个枚举，有以下选项：</p>
<p>MASTER：主从节点读取</p>
<p>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</p>
<p>REPLICA：从slave节点读取</p>
<p>REPLICA_PREFERRED：优先从slave节点读取，所有的slave都不可用才读取master</p>
<h3 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<p>海量数据存储问题</p>
<p>高并发写的问题</p>
<p>使用分片集群可以解决上述问题，分片集群特征：</p>
<p>集群中有多个master，每个master保存不同数据</p>
<p>每个master都可以有多个slave节点</p>
<p>master之间通过ping监测彼此健康状态</p>
<p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
<h4 id="搭建分片集群："><a href="#搭建分片集群：" class="headerlink" title="搭建分片集群："></a>搭建分片集群：</h4><p>准备实例，创建6个文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 7001 7002 7003 8001 8002 8003</span><br></pre></td></tr></table></figure>

<p>在&#x2F;tmp下准备一个新的redis.conf文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">cluster-enabled yes</span><br><span class="line">#集群的配置文件，不需要我们创建，redis自己维护</span><br><span class="line">cluster-config-file /tmp/6379/nodes.conf</span><br><span class="line">#节点心跳失败时间</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">#持久化存放目录</span><br><span class="line">dir /tmp/6379</span><br><span class="line">#绑定地址</span><br><span class="line">bind 0.0.0.</span><br><span class="line">#redis后台运行</span><br><span class="line">daemonize yes</span><br><span class="line">#注册的实际IP</span><br><span class="line">replica-announce-ip 192.168.150.101</span><br><span class="line">#保护模式</span><br><span class="line">protected-mode no</span><br><span class="line">#数据库数量</span><br><span class="line">databases 1</span><br><span class="line">#日志</span><br><span class="line">logfile /tmp/6379/run.log</span><br></pre></td></tr></table></figure>

<p>将这个配置文件拷贝到每个目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 7001 7002 7003 8001 8002 8003 | xargs -t -n l cp redis.conf</span><br></pre></td></tr></table></figure>

<p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &#x27;%s\n&#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i &#x27;s/6379/&#123;&#125;/g&#x27; &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动</p>
<p>配置了后台启动模式，所以可以直接启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &#x27;%s\n&#x27; 7001 7002 7003 8001 8002 8003 |xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure>

<h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><p>Redis5.0以后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas l 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></td></tr></table></figure>

<p>注释：</p>
<p>redis-cli –cluster 或者 .&#x2F;redis-trib.rb ：代表集群操作命令</p>
<p>查看集群状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>

<h4 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h4><p>Redis会把每一个master节点映射到0~16383共16384个插槽上，查看集群信息时就能看到</p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<p>key中包含“{}”且“{}”中至少包含1个字符，“{}”中的部分是有效部分</p>
<p>key中不包含“{}”，整个key都是有效部分</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>当集群中有一个master挂了的场景：</p>
<p>1.首先是该实例与其他实例失去连接</p>
<p>2.然后是疑似宕机</p>
<p>3.最后是确定下线，自动提升一个slave为新的master</p>
<p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。</p>
<h4 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群</h4><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<p>1.引入redis的starter依赖</p>
<p>2.配置分片集群地址</p>
<p>3.配置读写分离</p>
<h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>传统缓存的问题：请求到达Tomcat，先查询redis，如果未命中则查询数据库，这样的话，Tomcat的性能成为整个系统的瓶颈；而且Redis失效时，会对数据库产生冲击</p>
<p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能</p>
<h4 id="JVM进程缓存"><a href="#JVM进程缓存" class="headerlink" title="JVM进程缓存"></a>JVM进程缓存</h4><p>缓存：</p>
<p>分布式缓存：</p>
<p>优点：存储容量更大、可靠性更好、可以在集群间共享</p>
<p>缺点：访问缓存有网络开销</p>
<p>场景：缓存数据量较大、可靠性要求高、需要在集群间共享</p>
<p>进程本地缓存：</p>
<p>优点：读取本地内存，没有网络开销，速度更快</p>
<p>缺点：存储容量有限，可靠性较低，无法共享</p>
<p>场景：性能要求较高，缓存数据量较小</p>
<p>Caffeine是一个近乎最佳命中率性能的本地缓存技术。</p>
<p>Caffeine提供了三种缓存驱逐策略：</p>
<p>基于容量：设置缓存的数量上限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cacha&lt;String,String&gt; cache = Caffeine.newBuilder().maximumSize(1).build();</span><br></pre></td></tr></table></figure>

<p>基于时间：设置缓存的有效时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cacha&lt;String,String&gt; cache = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(10)).build();</span><br></pre></td></tr></table></figure>

<p>基于引用：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差</p>
<h4 id="Lua语法入门"><a href="#Lua语法入门" class="headerlink" title="Lua语法入门"></a>Lua语法入门</h4><p>Lua是一种轻量小巧的脚本语言，用标准C语言编写并以源代买形式开放，其设计的目的是为了嵌入式应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
<p>编写Helloworld</p>
<p>1.在Linux虚拟机的任意目录下，新建一个helloworld.lua</p>
<p>2.在文件中写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello World&quot;)</span><br></pre></td></tr></table></figure>

<p>3.运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua helloworld.lua</span><br></pre></td></tr></table></figure>

<p>数据类型</p>
<p>nil——表示无效值，在条件表达式中相当于false</p>
<p>boolean——表示false和true</p>
<p>number——表示双精度类型的实浮点数</p>
<p>string——字符串由一对双引号或单引号来表示</p>
<p>function—–由C或Lua编写的函数</p>
<p>table——Lua中的表其实是一个“关联数组”，数组的索引可以是数字、字符串或表类型</p>
<h4 id="多级缓存-1"><a href="#多级缓存-1" class="headerlink" title="多级缓存"></a>多级缓存</h4><p>安装OpenResty</p>
<p>基于Nginx的高性能Web平台</p>
<p>1.安装依赖库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre-devel openssl-devel gaa --skip-broken</span><br></pre></td></tr></table></figure>

<p>2.安装仓库管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br></pre></td></tr></table></figure>

<p>3.安装OpenResty</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openresty</span><br></pre></td></tr></table></figure>

<p>4.安装opm工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openresty-opm</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<p>步骤一：修改nginx.conf文件</p>
<p>1.在nginx加载lua模块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#加载lua 模块</span><br><span class="line">Lua_package_path &quot;/usr/local/openresty/lualib/?.lua;;&quot;;</span><br><span class="line">#加载c模块</span><br><span class="line">lua_package_cpath &quot;/usr/local/openresty/lualib/?.so;;&quot;;</span><br></pre></td></tr></table></figure>

<p>2.在nginx.conf的server下面，添加对&#x2F;api&#x2F;item这个路径的监听</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /api/item &#123;</span><br><span class="line">	#响应类型 这里是返回json</span><br><span class="line">	default_type application/json;</span><br><span class="line">	#响应数据由 lua/item.lua这个文件来决定</span><br><span class="line">	content_by_lua_file lua/item.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤二：编写item.lua文件</p>
<p>1.在nginx目录创建文件夹:lua</p>
<p>2.在lua文件夹下，新建文件：item.lua</p>
<p>3.添加内容</p>
<p>4.重新加载配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h4 id="缓存同步"><a href="#缓存同步" class="headerlink" title="缓存同步"></a>缓存同步</h4><p>缓存同步策略：</p>
<p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p>
<p>优势：简单、方便</p>
<p>缺点：失效性差，缓存过期之前可能不一致</p>
<p>场景：更新频率较低，时效性要求低的业务</p>
<p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p>
<p>优势：时效性强，缓存与数据库强一致</p>
<p>缺点：有代码侵入，耦合度高</p>
<p>场景：对一致性、时效性要求较高的缓存数据</p>
<p><strong>异步通知</strong>：修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p>
<p>优势：低耦合，可以同时通知多个缓存服务</p>
<p>缺点：时效性一般，可能存在中间不一致状态</p>
<p>场景：失效性要求一般，有多个服务需要同步</p>
<h4 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h4><p>基于java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费。</p>
<p><strong>安装Canal</strong></p>
<p>1.创建一个网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一个网络，将Mysql、Canal、MQ放到同一个Docker网络中</span><br><span class="line">docker network create heima</span><br><span class="line">让mysql加入这个网络</span><br><span class="line">docker network connect heima mysql</span><br></pre></td></tr></table></figure>

<p>2.安装Canal</p>
<p>将canal.tar上传到虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i canal.tar</span><br></pre></td></tr></table></figure>

<p>然后运行命令创建Canal容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1111:1111 --name canal \</span><br><span class="line">-e canal.destinations=heima \</span><br><span class="line">-e canal.instance.master.address=mysql:3306 \</span><br><span class="line">-e canal.instance.dbUsername=canal \</span><br><span class="line">-e canal.instance.dbPassword=canal \</span><br><span class="line">-e canal.instance.connectionCharaset=UTF-8 \</span><br><span class="line">-e canal.instance.tsdb.enable=true \</span><br><span class="line">-e canal.instance.gtidon=false \</span><br><span class="line">-e canal.instance.filter.regex=heima\\..* \</span><br><span class="line">--network heima \</span><br><span class="line">-d canal/canal-server:v1.1.5</span><br></pre></td></tr></table></figure>

<h1 id="配置中心Apollo"><a href="#配置中心Apollo" class="headerlink" title="配置中心Apollo"></a>配置中心Apollo</h1><p>分布式配置中心，能过集成化管理应用不同环境、不同集群的配置，配置好后可以热发布。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="application应用"><a href="#application应用" class="headerlink" title="application应用"></a>application应用</h3><p>实际使用配置的应用，每个应用都需要有唯一的身份标识–appId</p>
<h3 id="environment环境"><a href="#environment环境" class="headerlink" title="environment环境"></a>environment环境</h3><p>配置对应的环境，环境就是读取机器上的配置（server.properties中的env属性）</p>
<h3 id="cluster集群"><a href="#cluster集群" class="headerlink" title="cluster集群"></a>cluster集群</h3><p>一个应用下不同实例的分组，对不同的cluster，同一个配置可以有不一样的</p>
<h3 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h3><p>一个应用下不同配置的分组，可以简单的namespace类比为文件，不同类型的配置存放在不同的文件中，如数据库配置文件，rpc配置文件，应用自身的配置文件等</p>
<h2 id="Apollo特性"><a href="#Apollo特性" class="headerlink" title="Apollo特性"></a>Apollo特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.apollo统一管理不同环境、不同集群的配置</span><br><span class="line">2.配置修改实时生效（热发布）</span><br><span class="line">3.版本发布管理</span><br><span class="line">4.灰度发布</span><br><span class="line">5.权限管理、发布审核、操作审计</span><br><span class="line">6.客户端配置信息监控</span><br><span class="line">7.提供Java和.Net原生客户端</span><br><span class="line">8.提供开放平台API</span><br><span class="line">9.部署简单</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>操作人员—发布配置—&gt;Portal—发布配置—&gt;Admin Service—发送ReleaseMessage—&gt;Config Service—通知客户端—&gt;酷虎端</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>操作人员—&gt;Apollo配置中心&lt;—&gt;本地应用容器</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>环境准备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk1.8+</span><br><span class="line">Mysql 5.6.0+</span><br><span class="line">github下载安装包：https://github.com/nobodyiam/apollo-build-scripts</span><br></pre></td></tr></table></figure>

<p>下载好后解压，运行两个sql脚本文件，创建出portaldb和configdb</p>
<p>安装apollo</p>
<p>1.创建数据库</p>
<p>apollo服务端共需要两个数据库：ApolloPortalDB和ApolloConfigDB</p>
<p>2.配置数据库连接信息</p>
<p>apollo服务端需要知道如何连接到你前面创建的数据库，所以需要编辑demo.sh，修改ApolloPortalDB和ApolloConfigDB相关的数据库连接信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#apollo config db info</span><br><span class="line">apollo.config_db_url=jdbc://mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">apollo_config_db_username=xxx</span><br><span class="line">apollo_config_db_password=xxx</span><br><span class="line"></span><br><span class="line">#apollo portal db info</span><br><span class="line">apollo.portal_db_url=jdbc://mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8</span><br><span class="line">apollo_portal_db_username=xxx</span><br><span class="line">apollo_portal_db_password=xxx</span><br></pre></td></tr></table></figure>

<p>搭建服务端</p>
<p>quick start脚本会在本地启动3个服务，分别是8070、8080、8090端口，确保3个端口未被占用</p>
<p>执行启动脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./demo.sh start</span><br></pre></td></tr></table></figure>

<h3 id="客户端接入服务端"><a href="#客户端接入服务端" class="headerlink" title="客户端接入服务端"></a>客户端接入服务端</h3><p>通过最简单的方式，Spring-Boot的集成方式来接入服务端</p>
<p>apollo-demo聚合工程：spring boot 2.2.4.RELEASE</p>
<p>order-service：订单服务端口：9090</p>
<p>order-service02：订单服务端口：9091</p>
<p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;apollo-client&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.6.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在启动类上添加注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableApolloConfig</span><br></pre></td></tr></table></figure>

<h1 id="应用监控CAT"><a href="#应用监控CAT" class="headerlink" title="应用监控CAT"></a>应用监控CAT</h1><p>由大众点评开源的一款调用链监控系统，基于java开发。</p>
<p>聚合报表功能，中文支持性好</p>
<h2 id="cat报表介绍"><a href="#cat报表介绍" class="headerlink" title="cat报表介绍"></a>cat报表介绍</h2><p>Transaction报表：一段代码的运行时间、次数；比如URL&#x2F;cache&#x2F;sql执行次数相应时间</p>
<p>Event报表：一段代码运行次数，比如出现一次异常</p>
<p>Problem报表：根据Transaction&#x2F;Event数据分析出系统可能出现的一次，慢程序</p>
<p>Heartbeat报表：JVM状态信息</p>
<p>Business报表：业务指标等，用户可以自己定制</p>
<h2 id="cat基础"><a href="#cat基础" class="headerlink" title="cat基础"></a>cat基础</h2><h3 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h3><p>下载地址(<a target="_blank" rel="noopener" href="https://github.com/dianping/cat/tree/master">https://github.com/dianping/cat/tree/master</a>)</p>
<p>环境要求：</p>
<p>Linux2.6及以上，线上服务端部署请使用Linux环境，Mac以及Windows环境可以作为开发环境，美团点评内部CentOS6.5</p>
<p>java 6，7，8</p>
<p>maven3及以上</p>
<p>Mysql5.6，5.7，高版本不清楚兼容性</p>
<h4 id="数据库安装"><a href="#数据库安装" class="headerlink" title="数据库安装"></a>数据库安装</h4><p>数据库脚本文件script&#x2F;CatApplication.sql</p>
<h3 id="windows下安装"><a href="#windows下安装" class="headerlink" title="windows下安装"></a>windows下安装</h3><p>禁用虚拟网卡</p>
<p>在windows下安装，首先将虚拟网卡都禁用，防止CAT使用虚拟网卡的ip地址</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>在windows的环境变量中，配置CAT_HOME变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\data\appdatas\cat</span><br></pre></td></tr></table></figure>

<p>修改中文乱码tomcat conf目录下server.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">	URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot;</span><br></pre></td></tr></table></figure>

<p>配置&#x2F;data&#x2F;appdatas&#x2F;cat&#x2F;client.xml</p>
<p>配置&#x2F;data&#x2F;appdatas&#x2F;cat&#x2F;datasource.xml</p>
<p>然后把war包放在tomcat的webapps下，然后启动tomcat即可</p>
<h3 id="客户端集成简单案例"><a href="#客户端集成简单案例" class="headerlink" title="客户端集成简单案例"></a>客户端集成简单案例</h3><p>1.新建一个springboot-cat的项目</p>
<p>2.在该项目中引入cat-client的依赖，可以在源码中maven install，也可以在网上下一个jar包</p>
<p>3.写一个log通知类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;test&quot;)</span><br><span class="line">    public String test()&#123;</span><br><span class="line">        Transaction t= Cat.newTransaction(&quot;URL&quot;,&quot;pageName&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            Cat.logEvent(&quot;URL.server&quot;,&quot;serverIp&quot;, Event.SUCCESS,&quot;ip=127.0.0.1&quot;);</span><br><span class="line">            Cat.logMetricForCount(&quot;metric.key&quot;);</span><br><span class="line">            Cat.logMetricForCount(&quot;metric.key&quot;,5);</span><br><span class="line">            int i=1/0;</span><br><span class="line">            t.setStatus(Transaction.SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            t.setStatus(e);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            t.complete();</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>就可以在cat中看到url的日志通知</p>
<h2 id="报表类"><a href="#报表类" class="headerlink" title="报表类"></a>报表类</h2><h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><p>适合记录跨越边界的程序访问行为，比如远程调用、数据库调用等，也适合执行时间较长的业务逻辑监控，Transaction用来记录一段代码的执行时间和次数</p>
<h4 id="扩展API"><a href="#扩展API" class="headerlink" title="扩展API"></a>扩展API</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addData 添加额外的数据显示</span><br><span class="line">setStatus 设置状态，成功可以设置SUCCESS,失败可以设置成异常</span><br><span class="line">setDurationInMills 设置执行耗时</span><br><span class="line">setTimestamp 设置执行时间</span><br><span class="line">complete 结束Transaction</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 23:50:59" itemprop="dateCreated datePublished" datetime="2023-08-13T23:50:59+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 00:48:02" itemprop="dateModified" datetime="2023-08-14T00:48:02+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表算法"><a href="#链表算法" class="headerlink" title="链表算法"></a>链表算法</h2><h3 id="双指针法："><a href="#双指针法：" class="headerlink" title="双指针法："></a>双指针法：</h3><h4 id="合并有序链表："><a href="#合并有序链表：" class="headerlink" title="合并有序链表："></a>合并有序链表：</h4><p><img src="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MyBlog\图片\title.jpg" alt="img"></p>
<p>虚拟头结点法：</p>
<p>避免处理空指针的情况，降低代码的复杂性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode dumpy = new ListNode(-1);</span><br><span class="line">dumpy.next = head;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dumpy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>),p = dumpy;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> l1,p2=l2;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">null</span>&amp;&amp;p2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.val&gt;p2.val)&#123;</span><br><span class="line">            p.next =p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1  = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并剩余的链表</span></span><br><span class="line">    p.next = (p1==<span class="literal">null</span>)?p2:p1;</span><br><span class="line">    retrun dumpy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并k个有序链表："><a href="#合并k个有序链表：" class="headerlink" title="合并k个有序链表："></a>合并k个有序链表：</h4><p><img src="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MyBlog\图片\title2.jpg" alt="img"></p>
<p>类似合并两个链表的情况，但是需要高效找到最小的节点，这里使用优先级队列（二叉堆），把节点放入最小堆中，就可以每次获得k个节点中的最小节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode mergeKLists(ListNode[] lists)&#123;</span><br><span class="line">	if(lists.length==0) return null;</span><br><span class="line">	ListNode dumpy = new ListNode(-1);</span><br><span class="line">	ListNode p = dumpy;</span><br><span class="line">	</span><br><span class="line">	//优先级队列</span><br><span class="line">	PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(</span><br><span class="line">		lists.length,(a,b)-&gt;(a.val-b.val)</span><br><span class="line">	);</span><br><span class="line">	for(ListNode head:lists)&#123;</span><br><span class="line">		if(head!=null)&#123;</span><br><span class="line">			pq.add(head);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(!pq.isEmpty())&#123;</span><br><span class="line">		ListNode node = pq.poll();</span><br><span class="line">		p.next = node;</span><br><span class="line">		if(node.next!=null)&#123;</span><br><span class="line">			pq.add(node.next);</span><br><span class="line">		&#125;</span><br><span class="line">		p = p.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return dumpy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="拆分链表："><a href="#拆分链表：" class="headerlink" title="拆分链表："></a>拆分链表：</h4><p><img src="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MyBlog\图片\title4.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ListNode partition(ListNode head,int x)&#123;</span><br><span class="line">	ListNode dumpy1 = new ListNode(-1);</span><br><span class="line">	ListNode dumpy2 = new ListNode(-1);</span><br><span class="line">	</span><br><span class="line">	ListNode p1 = dumpy1,p2 = dumpy2;</span><br><span class="line">	ListNode p = head;</span><br><span class="line">	while(p!=null)&#123;</span><br><span class="line">		if(p.val&gt;=x)&#123;</span><br><span class="line">			p2.next = p;</span><br><span class="line">			p2 = p2.next;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			p1.next = p;</span><br><span class="line">			p1 = p1.next;</span><br><span class="line">		&#125;</span><br><span class="line">		//断开每个节点的指针</span><br><span class="line">		ListNode temp = p.next;</span><br><span class="line">		p.next = null;</span><br><span class="line">		p = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	p1.next = dumpy2.next;</span><br><span class="line">	return dumpy1.next;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单链表的倒数第k个节点："><a href="#单链表的倒数第k个节点：" class="headerlink" title="单链表的倒数第k个节点："></a>单链表的倒数第k个节点：</h4><p>从n个节点，倒数第k个节点就是正数第n-k+1个节点，也是一个for循环，时间复杂度O（n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 返回链表的倒数第 k 个节点</span><br><span class="line">ListNode findFromEnd(ListNode head, int k) &#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    // p1 先走 k 步</span><br><span class="line">    for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    // p1 和 p2 同时走 n - k 步</span><br><span class="line">    while (p1 != null) &#123;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span><br><span class="line">    return p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单链表的中点："><a href="#单链表的中点：" class="headerlink" title="单链表的中点："></a>单链表的中点：</h4><p>让两个指针slow和fast分别指向链表头结点head</p>
<p>每当慢指针前进一步，快指针就前进两步，这样当快指针走到链表尾时，slow就指向了链表中点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode middleNode(ListNode head)&#123;</span><br><span class="line">	ListNode slow = head,fast = head;</span><br><span class="line">	while(fast!=null&amp;&amp;fast.next!=null)&#123;</span><br><span class="line">		slow = slow.next;</span><br><span class="line">		fast = fast.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断链表是否包含环："><a href="#判断链表是否包含环：" class="headerlink" title="判断链表是否包含环："></a>判断链表是否包含环：</h4><p>每当慢指针slow前进一步，快指针fast就前进两步</p>
<p>如果fast最终遇到空指针，说明链表中没有环；如果fast最终和slow相遇，那肯定是fast超过了slow一圈，说明链表中含有环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">boolean hasCycle(ListNode head)&#123;</span><br><span class="line">	ListNode slow = head,fast = head;</span><br><span class="line">	while(fast!=null&amp;&amp;fast.next!=null)&#123;</span><br><span class="line">		slow = slow.next;</span><br><span class="line">		fast = fast.next.next;</span><br><span class="line">		if(slow==fast)</span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶版，找到环结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ListNode detectCycle(ListNode head)&#123;</span><br><span class="line">	ListNode fast,slow;</span><br><span class="line">	fast = slow = head;</span><br><span class="line">	while(fast!=null&amp;&amp;fast.next!=null)&#123;</span><br><span class="line">		fast = fast.next.next;</span><br><span class="line">		slow = slow.next;</span><br><span class="line">		if(fast == slow) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if(fast==null||fast.next==null)&#123;</span><br><span class="line">		return null</span><br><span class="line">	&#125;</span><br><span class="line">	slow = head;</span><br><span class="line">	while(slow!=fast)&#123;</span><br><span class="line">		fast = fast.next;</span><br><span class="line">		slow = slow.next;</span><br><span class="line">	&#125;</span><br><span class="line">	return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="两个链表是否相交："><a href="#两个链表是否相交：" class="headerlink" title="两个链表是否相交："></a>两个链表是否相交：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListNode getIntersectionNode(ListNode headA,ListNode headB)&#123;</span><br><span class="line">	ListNode p1 = headA,p2 = headB;</span><br><span class="line">	while(p1!=p2)&#123;</span><br><span class="line">		if(p1==null)&#123;</span><br><span class="line">			p1 = headB;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			p1 = p1.next;</span><br><span class="line">		&#125; </span><br><span class="line">		if(p2==null)&#123;</span><br><span class="line">			p2 = headA;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			p2 = p2.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="递归算法："><a href="#递归算法：" class="headerlink" title="递归算法："></a>递归算法：</h3><h4 id="反转链表："><a href="#反转链表：" class="headerlink" title="反转链表："></a>反转链表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverse(ListNode head)&#123;</span><br><span class="line">	if(head==null||head.next==null)&#123;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode last = reverse(head.next);</span><br><span class="line">	head.next.next = head;</span><br><span class="line">	head.next = null;</span><br><span class="line">	return last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="反转前n个节点链表："><a href="#反转前n个节点链表：" class="headerlink" title="反转前n个节点链表："></a>反转前n个节点链表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//后驱节点，第n+1个节点</span><br><span class="line">ListNode successor = null;</span><br><span class="line">ListNode reverse(ListNode head，int n)&#123;</span><br><span class="line">	if(n==1)&#123;</span><br><span class="line">		successor = head.next;</span><br><span class="line">		return head;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode last = reverse(head.next,n-1);</span><br><span class="line">	head.next.next = head;</span><br><span class="line">	head.next = successor;</span><br><span class="line">	return last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反转链表的一部分："><a href="#反转链表的一部分：" class="headerlink" title="反转链表的一部分："></a>反转链表的一部分：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverseBetween(ListNode head,int m,int n)&#123;</span><br><span class="line">	if(m==1)&#123;</span><br><span class="line">		return reverseN(head,n);</span><br><span class="line">	&#125;</span><br><span class="line">	head.next = reverseBetween(head.next,m-1,n-1);</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="k个一组反转链表："><a href="#k个一组反转链表：" class="headerlink" title="k个一组反转链表："></a>k个一组反转链表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ListNode reverseKGroup(ListNode head,int k)&#123;</span><br><span class="line">	if(head==null) return null;</span><br><span class="line">	ListNode a,b;</span><br><span class="line">	a=b=head;</span><br><span class="line">	for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">		if(b==null) return head;</span><br><span class="line">		b = b.next;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode newHead = reverse(a,b);</span><br><span class="line">	a.next = reverseKGroup(b,k);</span><br><span class="line">	return newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode reverse(ListNode a,ListNode b)&#123;</span><br><span class="line">	ListNode pre,cur,nxt;</span><br><span class="line">	pre=null;cur=a;nxt=a;</span><br><span class="line">	while(cur!=b)&#123;</span><br><span class="line">		nxt=cur.next;</span><br><span class="line">		cur.next = pre;</span><br><span class="line">		pre = cur;</span><br><span class="line">		cur = nxt;</span><br><span class="line">	&#125;</span><br><span class="line">	return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判断回文链表："><a href="#判断回文链表：" class="headerlink" title="判断回文链表："></a>判断回文链表：</h3><p>1.把一条链表反转存入一条新的链表，然后比较这两条链表是否相同</p>
<p>2.后序遍历链表，在后序遍历时进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 左侧指针</span><br><span class="line">ListNode left;</span><br><span class="line"></span><br><span class="line">boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">    left = head;</span><br><span class="line">    return traverse(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean traverse(ListNode right) &#123;</span><br><span class="line">    if (right == null) return true;</span><br><span class="line">    boolean res = traverse(right.next);</span><br><span class="line">    // 后序遍历代码</span><br><span class="line">    res = res &amp;&amp; (right.val == left.val);</span><br><span class="line">    left = left.next;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.双指针找到中点，然后反转后半部分链表，进行比较</p>
<h2 id="数组算法"><a href="#数组算法" class="headerlink" title="数组算法"></a>数组算法</h2><h3 id="双指针法：-1"><a href="#双指针法：-1" class="headerlink" title="双指针法："></a>双指针法：</h3><h4 id="快慢指针："><a href="#快慢指针：" class="headerlink" title="快慢指针："></a>快慢指针：</h4><p>去重，移除某元素</p>
<p><img src="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/MyBlog\图片\title26.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int removeDuplicates(int[] nums)&#123;</span><br><span class="line">	if(nums.length==0)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int slow=0,fast=0;</span><br><span class="line">	while(fast&lt;nums.length)&#123;</span><br><span class="line">		if(nums[fast]!=nums[slow])&#123;</span><br><span class="line">			slow++;</span><br><span class="line">			nums[slow]= nums[fast];</span><br><span class="line">		&#125;</span><br><span class="line">		fast++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左右指针："><a href="#左右指针：" class="headerlink" title="左右指针："></a>左右指针：</h4><p>1.二分查找</p>
<p>2.两数之和</p>
<p>3.反转数组</p>
<p>4.回文判断</p>
<h3 id="前缀和："><a href="#前缀和：" class="headerlink" title="前缀和："></a>前缀和：</h3><p><img src="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Apple\项目\研究生课程资料\Typora\图片\title304.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix &#123;</span><br><span class="line">    // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和</span><br><span class="line">    private int[][] preSum;</span><br><span class="line">    </span><br><span class="line">    public NumMatrix(int[][] matrix) &#123;</span><br><span class="line">        int m = matrix.length, n = matrix[0].length;</span><br><span class="line">        if (m == 0 || n == 0) return;</span><br><span class="line">        // 构造前缀和矩阵</span><br><span class="line">        preSum = new int[m + 1][n + 1];</span><br><span class="line">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">                // 计算每个矩阵 [0, 0, i, j] 的元素和</span><br><span class="line">                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算子矩阵 [x1, y1, x2, y2] 的元素和</span><br><span class="line">    public int sumRegion(int x1, int y1, int x2, int y2) &#123;</span><br><span class="line">        // 目标矩阵之和由四个相邻矩阵运算获得</span><br><span class="line">        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="差分数组："><a href="#差分数组：" class="headerlink" title="差分数组："></a>差分数组：</h3><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</p>
<p>类似前缀和技巧，先对数组构造一个diff差分数组，diff[i]就是nums[i]和nums[i-1]之差</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int[] diff = new int[nums.length];</span><br><span class="line">// 构造差分数组</span><br><span class="line">diff[0] = nums[0];</span><br><span class="line">for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以快速进行区间增减操作，例如对区间nums[i….j]的元素全部加3，可以让diff[i]+&#x3D;3,diff[j+1]-&#x3D;3即可</p>
<p><img src="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Apple\项目\研究生课程资料\Typora\图片\title1109.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int[] corpFlightBookings(int[][] bookings, int n) &#123;</span><br><span class="line">    // nums 初始化为全 0</span><br><span class="line">    int[] nums = new int[n];</span><br><span class="line">    // 构造差分解法</span><br><span class="line">    Difference df = new Difference(nums);</span><br><span class="line"></span><br><span class="line">    for (int[] booking : bookings) &#123;</span><br><span class="line">        // 注意转成数组索引要减一哦</span><br><span class="line">        int i = booking[0] - 1;</span><br><span class="line">        int j = booking[1] - 1;</span><br><span class="line">        int val = booking[2];</span><br><span class="line">        // 对区间 nums[i..j] 增加 val</span><br><span class="line">        df.increment(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回最终的结果数组</span><br><span class="line">    return df.result();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 差分数组工具类</span><br><span class="line">class Difference &#123;</span><br><span class="line">    // 差分数组</span><br><span class="line">    private int[] diff;</span><br><span class="line">    </span><br><span class="line">    /* 输入一个初始数组，区间操作将在这个数组上进行 */</span><br><span class="line">    public Difference(int[] nums) &#123;</span><br><span class="line">        assert nums.length &gt; 0;</span><br><span class="line">        diff = new int[nums.length];</span><br><span class="line">        // 根据初始数组构造差分数组</span><br><span class="line">        diff[0] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            diff[i] = nums[i] - nums[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 给闭区间 [i, j] 增加 val（可以是负数）*/</span><br><span class="line">    public void increment(int i, int j, int val) &#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        if (j + 1 &lt; diff.length) &#123;</span><br><span class="line">            diff[j + 1] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 返回结果数组 */</span><br><span class="line">    public int[] result() &#123;</span><br><span class="line">        int[] res = new int[diff.length];</span><br><span class="line">        // 根据差分数组构造结果数组</span><br><span class="line">        res[0] = diff[0];</span><br><span class="line">        for (int i = 1; i &lt; diff.length; i++) &#123;</span><br><span class="line">            res[i] = res[i - 1] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的花式遍历："><a href="#二维数组的花式遍历：" class="headerlink" title="二维数组的花式遍历："></a>二维数组的花式遍历：</h3><p>顺时针旋转矩阵：</p>
<p>将二维数组进行旋转，例如要求顺时针旋转90度，原地修改。</p>
<p>可以将其按对角线对称，然后每行进行反转</p>
<p>矩阵的螺旋遍历：</p>
<p>核心思路是按照右，下左，上的顺序遍历数组，并使用四个变量圈定未遍历元素的边界</p>
<h3 id="滑动窗口算法："><a href="#滑动窗口算法：" class="headerlink" title="滑动窗口算法："></a>滑动窗口算法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* 滑动窗口算法框架 */</span><br><span class="line">void slidingWindow(string s) &#123;</span><br><span class="line">    Map&lt;char, int&gt; window;</span><br><span class="line">    </span><br><span class="line">    int left = 0, right = 0;</span><br><span class="line">    while (right &lt; s.size()) &#123;</span><br><span class="line">        // c 是将移入窗口的字符</span><br><span class="line">        char c = s[right];</span><br><span class="line">        // 增大窗口</span><br><span class="line">        right++;</span><br><span class="line">        // 进行窗口内数据的一系列更新</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        /*** debug 输出的位置 ***/</span><br><span class="line">        printf(&quot;window: [%d, %d)\n&quot;, left, right);</span><br><span class="line">        /********************/</span><br><span class="line">        </span><br><span class="line">        // 判断左侧窗口是否要收缩</span><br><span class="line">        while (window needs shrink) &#123;</span><br><span class="line">            // d 是将移出窗口的字符</span><br><span class="line">            char d = s[left];</span><br><span class="line">            // 缩小窗口</span><br><span class="line">            left++;</span><br><span class="line">            // 进行窗口内数据的一系列更新</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Apple\项目\研究生课程资料\Typora\图片\title76.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public String minWindow(String s, String t) &#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hs = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; ht = new HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        for(int i = 0;i &lt; t.length();i ++)&#123;</span><br><span class="line">            ht.put(t.charAt(i),ht.getOrDefault(t.charAt(i), 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = &quot;&quot;;</span><br><span class="line">        int len = Integer.MAX_VALUE,cnt = 0,start = 0;</span><br><span class="line">        int left =0,right=0;</span><br><span class="line">        while(right&lt;s.length())&#123;</span><br><span class="line">            char c = s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            if(ht.containsKey(c))&#123;</span><br><span class="line">                hs.put(c,hs.getOrDefault(c,0)+1);</span><br><span class="line">                if (hs.get(c).equals(ht.get(c)))</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(cnt==ht.size())&#123;</span><br><span class="line">                if (right - left &lt; len) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">                char d = s.charAt(left);</span><br><span class="line">                // 缩小窗口</span><br><span class="line">                left++;</span><br><span class="line">                // 进行窗口内数据的一系列更新</span><br><span class="line">                if (ht.containsKey(d)) &#123;</span><br><span class="line">                    if (hs.get(d).equals(ht.get(d)))</span><br><span class="line">                        cnt--;</span><br><span class="line">                    hs.put(d,hs.get(d)-1);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        return len == Integer.MAX_VALUE ? &quot;&quot; : s.substring(start, start+len); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分搜索："><a href="#二分搜索：" class="headerlink" title="二分搜索："></a>二分搜索：</h3><p>二分查找不要出现else，而是把所有的情况用else if写清楚，这样可以清楚地展现所有细节。</p>
<p>计算mid时需要防止溢出，代码中使用left+(right-left)&#x2F;2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left = 0; </span><br><span class="line">    int right = nums.length - 1; // 注意</span><br><span class="line"></span><br><span class="line">    while(left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if(nums[mid] == target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left = mid + 1; // 注意</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right = mid - 1; // 注意</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>前，中，后序遍历的基本思想</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    if (root == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 前序位置</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    // 中序位置</span><br><span class="line">    traverse(root.right);</span><br><span class="line">    // 后序位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h3><p>算法思路</p>
<p>和二叉树的后序遍历很像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 定义：排序 nums[lo..hi]</span><br><span class="line">void sort(int[] nums, int lo, int hi) &#123;</span><br><span class="line">    if (lo == hi) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = (lo + hi) / 2;</span><br><span class="line">    // 利用定义，排序 nums[lo..mid]</span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    // 利用定义，排序 nums[mid+1..hi]</span><br><span class="line">    sort(nums, mid + 1, hi);</span><br><span class="line"></span><br><span class="line">    /****** 后序位置 ******/</span><br><span class="line">    // 此时两部分子数组已经被排好序</span><br><span class="line">    // 合并两个有序数组，使 nums[lo..hi] 有序</span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    /*********************/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]</span><br><span class="line">// 合并为有序数组 nums[lo..hi]</span><br><span class="line">void merge(int[] nums, int lo, int mid, int hi);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>归并排序的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Merge &#123;</span><br><span class="line"></span><br><span class="line">    // 用于辅助合并有序数组，全局变量temp数组</span><br><span class="line">    private static int[] temp;</span><br><span class="line"></span><br><span class="line">    public static void sort(int[] nums) &#123;</span><br><span class="line">        // 先给辅助数组开辟内存空间</span><br><span class="line">        temp = new int[nums.length];</span><br><span class="line">        // 排序整个数组（原地修改）</span><br><span class="line">        sort(nums, 0, nums.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 定义：将子数组 nums[lo..hi] 进行排序</span><br><span class="line">    private static void sort(int[] nums, int lo, int hi) &#123;</span><br><span class="line">        if (lo == hi) &#123;</span><br><span class="line">            // 单个元素不用排序</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2</span><br><span class="line">        int mid = lo + (hi - lo) / 2;</span><br><span class="line">        // 先对左半部分数组 nums[lo..mid] 排序</span><br><span class="line">        sort(nums, lo, mid);</span><br><span class="line">        // 再对右半部分数组 nums[mid+1..hi] 排序</span><br><span class="line">        sort(nums, mid + 1, hi);</span><br><span class="line">        // 将两部分有序数组合并成一个有序数组</span><br><span class="line">        merge(nums, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组</span><br><span class="line">    private static void merge(int[] nums, int lo, int mid, int hi) &#123;</span><br><span class="line">        // 先把 nums[lo..hi] 复制到辅助数组中</span><br><span class="line">        // 以便合并后的结果能够直接存入 nums</span><br><span class="line">        for (int i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 数组双指针技巧，合并两个有序数组</span><br><span class="line">        int i = lo, j = mid + 1;</span><br><span class="line">        for (int p = lo; p &lt;= hi; p++) &#123;</span><br><span class="line">            if (i == mid + 1) &#123;</span><br><span class="line">                // 左半边数组已全部被合并</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; else if (j == hi + 1) &#123;</span><br><span class="line">                // 右半边数组已全部被合并</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125; else if (temp[i] &gt; temp[j]) &#123;</span><br><span class="line">                nums[p] = temp[j++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[p] = temp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="回溯算法（DFS）和BFS"><a href="#回溯算法（DFS）和BFS" class="headerlink" title="回溯算法（DFS）和BFS"></a>回溯算法（DFS）和BFS</h1><h2 id="回溯算法的框架"><a href="#回溯算法的框架" class="headerlink" title="回溯算法的框架"></a>回溯算法的框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><h3 id="元素无重复不可复选"><a href="#元素无重复不可复选" class="headerlink" title="元素无重复不可复选"></a>元素无重复不可复选</h3><p> 子集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">// 记录回溯算法的递归路径</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">    backtrack(nums, 0);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回溯算法核心函数，遍历子集问题的回溯树</span><br><span class="line">void backtrack(int[] nums, int start) &#123;</span><br><span class="line"></span><br><span class="line">    // 前序位置，每个节点的值都是一个子集</span><br><span class="line">    res.add(new LinkedList&lt;&gt;(track));</span><br><span class="line">    </span><br><span class="line">    // 回溯算法标准框架</span><br><span class="line">    for (int i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        // 通过 start 参数控制树枝的遍历，避免产生重复的子集</span><br><span class="line">        backtrack(nums, i + 1);</span><br><span class="line">        // 撤销选择</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合</p>
<p>只需要修改base case即可，控制算法仅仅收集第k层节点即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">// 记录回溯算法的递归路径</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">    backtrack(nums, 0);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回溯算法核心函数，遍历子集问题的回溯树</span><br><span class="line">void backtrack(int[] nums, int start) &#123;</span><br><span class="line"></span><br><span class="line">    // 前序位置，每个节点的值都是一个子集</span><br><span class="line">    res.add(new LinkedList&lt;&gt;(track));</span><br><span class="line">    </span><br><span class="line">    // 回溯算法标准框架</span><br><span class="line">    for (int i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        // 通过 start 参数控制树枝的遍历，避免产生重复的子集</span><br><span class="line">        backtrack(nums, i + 1);</span><br><span class="line">        // 撤销选择</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">// 记录回溯算法的递归路径</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line">// track 中的元素会被标记为 true</span><br><span class="line">boolean[] used;</span><br><span class="line"></span><br><span class="line">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">    used = new boolean[nums.length];</span><br><span class="line">    backtrack(nums);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回溯算法核心函数</span><br><span class="line">void backtrack(int[] nums) &#123;</span><br><span class="line">    // base case，到达叶子节点</span><br><span class="line">    if (track.size() == nums.length) &#123;</span><br><span class="line">        // 收集叶子节点上的值</span><br><span class="line">        res.add(new LinkedList(track));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回溯算法标准框架</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 已经存在 track 中的元素，不能重复选择</span><br><span class="line">        if (used[i]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 做选择</span><br><span class="line">        used[i] = true;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        // 进入下一层回溯树</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        // 取消选择</span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="元素可重不可复选"><a href="#元素可重不可复选" class="headerlink" title="元素可重不可复选"></a>元素可重不可复选</h3><p>子集</p>
<p>处理技巧：</p>
<p>先进行排序，让相同的元素靠在一起，如果发现nums[i]&#x3D;&#x3D;nums[i-1],则跳过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">    // 先排序，让相同的元素靠在一起</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(nums, 0);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(int[] nums, int start) &#123;</span><br><span class="line">    // 前序位置，每个节点的值都是一个子集</span><br><span class="line">    res.add(new LinkedList&lt;&gt;(track));</span><br><span class="line">    </span><br><span class="line">    for (int i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 剪枝逻辑，值相同的相邻树枝，只遍历第一条</span><br><span class="line">        if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        track.addLast(nums[i]);</span><br><span class="line">        backtrack(nums, i + 1);</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">// 记录回溯的路径</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line">// 记录 track 中的元素之和</span><br><span class="line">int trackSum = 0;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">    if (candidates.length == 0) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // 先排序，让相同的元素靠在一起</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtrack(candidates, 0, target);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回溯算法主函数</span><br><span class="line">void backtrack(int[] nums, int start, int target) &#123;</span><br><span class="line">    // base case，达到目标和，找到符合条件的组合</span><br><span class="line">    if (trackSum == target) &#123;</span><br><span class="line">        res.add(new LinkedList&lt;&gt;(track));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // base case，超过目标和，直接结束</span><br><span class="line">    if (trackSum &gt; target) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回溯算法标准框架</span><br><span class="line">    for (int i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 剪枝逻辑，值相同的树枝，只遍历第一条</span><br><span class="line">        if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        trackSum += nums[i];</span><br><span class="line">        // 递归遍历下一层回溯树</span><br><span class="line">        backtrack(nums, i + 1, target);</span><br><span class="line">        // 撤销选择</span><br><span class="line">        track.removeLast();</span><br><span class="line">        trackSum -= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line">boolean[] used;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">    // 先排序，让相同的元素靠在一起</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    used = new boolean[nums.length];</span><br><span class="line">    backtrack(nums);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(int[] nums) &#123;</span><br><span class="line">    if (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(new LinkedList(track));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (used[i]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = true;</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="元素无重可复选"><a href="#元素无重可复选" class="headerlink" title="元素无重可复选"></a>元素无重可复选</h3><p>子集&#x2F;组合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">// 记录回溯的路径</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line">// 记录 track 中的路径和</span><br><span class="line">int trackSum = 0;</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">    if (candidates.length == 0) &#123;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(candidates, 0, target);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回溯算法主函数</span><br><span class="line">void backtrack(int[] nums, int start, int target) &#123;</span><br><span class="line">    // base case，找到目标和，记录结果</span><br><span class="line">    if (trackSum == target) &#123;</span><br><span class="line">        res.add(new LinkedList&lt;&gt;(track));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // base case，超过目标和，停止向下遍历</span><br><span class="line">    if (trackSum &gt; target) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回溯算法标准框架</span><br><span class="line">    for (int i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 选择 nums[i]</span><br><span class="line">        trackSum += nums[i];</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        // 递归遍历下一层回溯树</span><br><span class="line">        // 同一元素可重复使用，注意参数</span><br><span class="line">        backtrack(nums, i, target);</span><br><span class="line">        // 撤销选择 nums[i]</span><br><span class="line">        trackSum -= nums[i];</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permuteRepeat(int[] nums) &#123;</span><br><span class="line">    backtrack(nums);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回溯算法核心函数</span><br><span class="line">void backtrack(int[] nums) &#123;</span><br><span class="line">    // base case，到达叶子节点</span><br><span class="line">    if (track.size() == nums.length) &#123;</span><br><span class="line">        // 收集叶子节点上的值</span><br><span class="line">        res.add(new LinkedList(track));</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 回溯算法标准框架</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        // 做选择</span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        // 进入下一层回溯树</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        // 取消选择</span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维矩阵遍历框架"><a href="#二维矩阵遍历框架" class="headerlink" title="二维矩阵遍历框架"></a>二维矩阵遍历框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 二叉树遍历框架</span><br><span class="line">void traverse(TreeNode root) &#123;</span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 二维矩阵遍历框架</span><br><span class="line">void dfs(int[][] grid, int i, int j, boolean[][] visited) &#123;</span><br><span class="line">    int m = grid.length, n = grid[0].length;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n) &#123;</span><br><span class="line">        // 超出索引边界</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (visited[i][j]) &#123;</span><br><span class="line">        // 已遍历过 (i, j)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 进入节点 (i, j)</span><br><span class="line">    visited[i][j] = true;</span><br><span class="line">    dfs(grid, i - 1, j, visited); // 上</span><br><span class="line">    dfs(grid, i + 1, j, visited); // 下</span><br><span class="line">    dfs(grid, i, j - 1, visited); // 左</span><br><span class="line">    dfs(grid, i, j + 1, visited); // 右</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS算法"><a href="#BFS算法" class="headerlink" title="BFS算法"></a>BFS算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 计算从起点 start 到终点 target 的最近距离</span><br><span class="line">int BFS(Node start, Node target) &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; // 核心数据结构</span><br><span class="line">    Set&lt;Node&gt; visited; // 避免走回头路</span><br><span class="line">    </span><br><span class="line">    q.offer(start); // 将起点加入队列</span><br><span class="line">    visited.add(start);</span><br><span class="line">    int step = 0; // 记录扩散的步数</span><br><span class="line"></span><br><span class="line">    while (q not empty) &#123;</span><br><span class="line">        int sz = q.size();</span><br><span class="line">        /* 将当前队列中的所有节点向四周扩散 */</span><br><span class="line">        for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            /* 划重点：这里判断是否到达终点 */</span><br><span class="line">            if (cur is target)</span><br><span class="line">                return step;</span><br><span class="line">            /* 将 cur 的相邻节点加入队列 */</span><br><span class="line">            for (Node x : cur.adj()) &#123;</span><br><span class="line">                if (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /* 划重点：更新步数在这里 */</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 23:49:13" itemprop="dateCreated datePublished" datetime="2023-08-13T23:49:13+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-01 00:07:48" itemprop="dateModified" datetime="2023-08-01T00:07:48+08:00">2023-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>设计模式：</p>
<p>创建型模式：将对象的创建与使用分离</p>
<p>单例、原型、工厂方法、抽象工厂、建造者</p>
<p>结构型模式：描述如何将类或对象按某种布局组成更大的结构</p>
<p>代理、适配器、桥接、装饰、外观、享元、组合等</p>
<p>行为模式：描述类或对象之间怎么协作共同完成单个对象无法完成的任务</p>
<p>模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器</p>
<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>统一建模语言</p>
<p>定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图</p>
<h2 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h2><p>显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
<h2 id="类图表示法："><a href="#类图表示法：" class="headerlink" title="类图表示法："></a>类图表示法：</h2><p>类使用包含类名、属性和方法且带有分割线的矩形表示。</p>
<p>属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性。</p>
<p>+：表示public</p>
<p>-：表示private</p>
<p>#：表示protected</p>
<h2 id="类之间的关系表示方式："><a href="#类之间的关系表示方式：" class="headerlink" title="类之间的关系表示方式："></a>类之间的关系表示方式：</h2><h3 id="关联关系："><a href="#关联关系：" class="headerlink" title="关联关系："></a>关联关系：</h3><p>1.单向关联</p>
<p>在UML中用一个带箭头的实线表示</p>
<p>2双向关联</p>
<p>在UML中用一个不带箭头的实线表示</p>
<p>3.自关联</p>
<h3 id="聚合关系："><a href="#聚合关系：" class="headerlink" title="聚合关系："></a>聚合关系：</h3><p>是关联关系的一种，强关联关系，是整体和部分之间的关系。</p>
<p>例如：学校与老师的关系，学校包含老师，学校停办，老师依然存在</p>
<p>在UML中，聚合关系用带空心的菱形实线表示，菱形指向整体</p>
<h3 id="组合关系："><a href="#组合关系：" class="headerlink" title="组合关系："></a>组合关系：</h3><p>组合关系表示类之间的整体与部分的关系，更强的聚合关系</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体不存在了，部分对象也将不存在了</p>
<p>在UML中，聚合关系用带实心的菱形实线表示，菱形指向整体</p>
<h3 id="依赖关系："><a href="#依赖关系：" class="headerlink" title="依赖关系："></a>依赖关系：</h3><p>一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性关系，在代码中，某个类的方法通过局部变量，方法的参数或者对静态方法的调用来访问另一个类中的某些方法来实现一些功能。</p>
<p>在UML中，使用带箭头的虚线来表示，箭头从使用类指向被依赖类。</p>
<h3 id="继承关系："><a href="#继承关系：" class="headerlink" title="继承关系："></a>继承关系：</h3><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系。</p>
<p>在UML中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。</p>
<h3 id="实现关系："><a href="#实现关系：" class="headerlink" title="实现关系："></a>实现关系：</h3><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>在UML类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</p>
<h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><h2 id="开闭原则："><a href="#开闭原则：" class="headerlink" title="开闭原则："></a>开闭原则：</h2><p>对扩展开放，对修改关闭。</p>
<p>要想达到这样的效果，我们需要使用接口和抽象类。</p>
<p>例子：搜狗输入法皮肤设计</p>
<h2 id="里氏代换原则："><a href="#里氏代换原则：" class="headerlink" title="里氏代换原则："></a>里氏代换原则：</h2><p>任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能，简单来说就是子类继承父类，尽量不要重写父类的方法</p>
<h2 id="依赖倒转原则："><a href="#依赖倒转原则：" class="headerlink" title="依赖倒转原则："></a>依赖倒转原则：</h2><p>高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实习进行编程，降低客户与实现模块间的耦合。</p>
<p>例子：组装电脑</p>
<p>电脑需要配件CPU，硬盘，内存条。cpu可以有intel，amd；硬盘可以有希捷，等</p>
<h2 id="接口隔离原则："><a href="#接口隔离原则：" class="headerlink" title="接口隔离原则："></a>接口隔离原则：</h2><p>客户端不应该被迫依赖于它不使用的方法，<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>。</p>
<p>例子：安全门</p>
<p>安全门具有防火，防水，防盗的功能，可以将防火，防水，防盗功能各提取成一个接口，形成一套规范。</p>
<h2 id="迪米特法则："><a href="#迪米特法则：" class="headerlink" title="迪米特法则："></a>迪米特法则：</h2><p>最少知识原则。</p>
<p>如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转法该调用。降低类之间的耦合度。</p>
<p>例：明星和经纪人的关系</p>
<h2 id="合成复用原则："><a href="#合成复用原则：" class="headerlink" title="合成复用原则："></a>合成复用原则：</h2><p>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>类加载就会导致单例被创建</p>
<p>方式一：静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：静态代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton01 &#123;</span><br><span class="line">    private Singleton01()&#123;&#125;</span><br><span class="line">    private static Singleton01 instance;</span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new Singleton01();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton01 getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>类加载不会导致单例被创建，首次调用才会创建。</p>
<p>方式一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line"></span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：加了synchronized锁，线程安全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton01 &#123;</span><br><span class="line">    private Singleton01()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton01 instance;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton01 getInstance()&#123;</span><br><span class="line"></span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance = new Singleton01();</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常见的一种单例模式。</p>
<p>方式三：双重锁也是一种比较常见的单例模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton02 &#123;</span><br><span class="line">    private Singleton02() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private  static volatile Singleton02 instance;</span><br><span class="line">    </span><br><span class="line">    public static Singleton02 getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            synchronized (Singleton02.class)&#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton02();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式四：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton03 &#123;</span><br><span class="line">    private Singleton03()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Singleton03Holder&#123;</span><br><span class="line">        private static final Singleton03 instance = new Singleton03();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton03 getInstance()&#123;</span><br><span class="line">        return Singleton03Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式五：枚举方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>序列化反序列化会破坏单例模式</p>
<p>在singleton类中添加readResolve方法，在序列化和反序列化时就会返回这个方法的值</p>
<p>反射模式也会破坏单例模式</p>
<p>添加一个静态boolean属性做标志</p>
<h2 id="2-工厂模式："><a href="#2-工厂模式：" class="headerlink" title="2.工厂模式："></a>2.工厂模式：</h2><p>使用工厂生产对象，我们就只和工厂打交道，彻底和对象耦合</p>
<h3 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h3><p>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</p>
<p>具体产品：实现或继承产品的子类</p>
<p>具体工厂：提供了创建产品的方法，调用者通过该方法来获取产品</p>
<p>优点：</p>
<p>封装了创建对象的过程，可以通过参数直接获取对象，把对象的创建和业务逻辑层分开，避免了修改客户代码，实现新产品，直接修改工厂类即可</p>
<p>缺点：</p>
<p>增加新产品时，需要修改工厂类的代码，违背了“开闭原则”</p>
<h3 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h3><p>解决简单工厂模式违反开闭原则</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象，工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<p>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂方法来创建产品</p>
<p>抽象产品：主要是实现抽象工厂中的抽象方法，完成具体产品的创建</p>
<p>具体工厂：定义了产品的规范，描述了产品的主要特性和功能</p>
<p>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应</p>
<p>优点：</p>
<p>用户只需知道具体工厂就可以获取所需产品</p>
<p>在增加新产品时，只需添加具体产品类和对应的具体工厂类即可</p>
<p>缺点：</p>
<p>每增加一个产品，都要新增具体产品类和对应的具体工厂类</p>
<h3 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h3><p>工厂模式考虑的是一类产品的生产。</p>
<p>抽象工厂模式考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族</p>
<p>提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级产品的模式结构</p>
<p>抽象工厂：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品</p>
<p>具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建</p>
<p>抽象产品：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式由多个抽象产品</p>
<p>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</p>
<h2 id="3-原型模式："><a href="#3-原型模式：" class="headerlink" title="3.原型模式："></a>3.原型模式：</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的对象</p>
<p>抽象原型类：规定了具体原型对象必须实现clone() 方法</p>
<p>具体原型类：实现抽象原型类的clone() 方法，它是可以被复制的对象</p>
<p>访问类：使用具体原型类中clone() 方法来复制新的对象</p>
<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所执行的对象的内存地址</p>
<p>深克隆：闯将一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址</p>
<h2 id="4-建造者模式："><a href="#4-建造者模式：" class="headerlink" title="4.建造者模式："></a>4.建造者模式：</h2><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>分离了部件的构造和装配。从而可以构建出复杂的对象。</p>
<p>抽象建造者类：这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建。</p>
<p>具体建造者类：实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p>
<p>产品类：要创建的复杂对象。</p>
<p>指挥者类：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各个部分完整创建或者按某种顺序创建。</p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>描述如何将类或者对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。</p>
<h2 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h2><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问，这时，访问对象不适合或者不能直接引用个目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</p>
<p>真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</p>
<p>代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或者扩展真实主题的功能。</p>
<h4 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h4><p>案例：火车站卖票</p>
<p>火车站是目标对象，代售点是代理对象。</p>
<h4 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h4><p>JDK动态代理：</p>
<p>Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法。</p>
<h2 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h2><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h4 id="类适配器模式："><a href="#类适配器模式：" class="headerlink" title="类适配器模式："></a>类适配器模式：</h4><p>定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<h4 id="对象适配器模式："><a href="#对象适配器模式：" class="headerlink" title="对象适配器模式："></a>对象适配器模式：</h4><p>实现方式：对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>注意：还有一个适配器模式</p>
<p>应用场景：</p>
<p>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致</p>
<p>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同</p>
<h4 id="JDK源码解析："><a href="#JDK源码解析：" class="headerlink" title="JDK源码解析："></a>JDK源码解析：</h4><p>Reader (字符流)、InputStream(字节流)的适配器使用的是InputStreamReader。</p>
<h2 id="装饰者模式："><a href="#装饰者模式：" class="headerlink" title="装饰者模式："></a>装饰者模式：</h2><p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<h3 id="装饰模式中的角色："><a href="#装饰模式中的角色：" class="headerlink" title="装饰模式中的角色："></a>装饰模式中的角色：</h3><p>抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象</p>
<p>具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责</p>
<p>抽象装饰角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</p>
<p>具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>比继承更加灵活的扩展性，继承是静态附加责任，装饰者是动态的附加责任</p>
<p>装饰类和被装饰类可以独立发展，不会互相耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类功能</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</p>
<p>不能继承的场景：扩展时造成子类爆炸，final修饰</p>
<p>在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责</p>
<p>当对象的功能可以动态地添加，也可以再动态地撤销</p>
<h3 id="JDK源码解析：-1"><a href="#JDK源码解析：-1" class="headerlink" title="JDK源码解析："></a>JDK源码解析：</h3><p>IO流中地包装类使用了装饰者模式。BufferedInputStream,BufferedOutputStream,BufferedReader,BufferedWriter</p>
<h2 id="桥接模式："><a href="#桥接模式：" class="headerlink" title="桥接模式："></a>桥接模式：</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>需要创建不同地图形，并且每个图形都可能有不同的颜色。</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</p>
<h3 id="主要角色："><a href="#主要角色：" class="headerlink" title="主要角色："></a>主要角色：</h3><p>抽象化角色：定义抽象类，并包含一个对实现化对象的引用</p>
<p>扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</p>
<p>实现化角色：定义实现化角色的接口，供扩展抽象化角色调用</p>
<p>具体实现化角色：给出实现化角色的具体实现</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>提高了系统的可扩充性，在两个变化的维度中任意扩展一个维度，都不需要修改原有系统</p>
<p>实现细节对客户透明</p>
<h3 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h3><p>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时</p>
<p>当一个系统不希望使用继承或者因为多层次继承导致系统类的个数急剧增加时</p>
<p>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系</p>
<h2 id="外观模式："><a href="#外观模式：" class="headerlink" title="外观模式："></a>外观模式：</h2><h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><p>类似基金聚合了多个股票，我们买基金不用关心到底买了哪些股票</p>
<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节</p>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><p>降低了子系统与客户端之间的耦合，使得子系统的变化不会影响调用它的客户端</p>
<p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用容易</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>不符合开闭原则，修改麻烦</p>
<h2 id="组合模式："><a href="#组合模式：" class="headerlink" title="组合模式："></a>组合模式：</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
<h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p>抽象根节点：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性</p>
<p>树枝节点：定义树枝节点的行为，存储字节点，组合树枝节点和叶子节点形成一个树形结构</p>
<p>叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位</p>
<h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p>软件菜单：</p>
<p>管理系统中，经常可以看到类似的菜单，一个菜单包含菜单项，也包含其他菜单项</p>
<h3 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h3><p>组合模式可以清楚定义分层次的复杂对象，表示对象的全部或部分层次</p>
<p>客户端可以一致地使用一个组合结构或者其中单个对象，不必关心处理的单个对象还是整个组合结构，简化了客户端代码</p>
<p>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类进行任何修改，符合“开闭原则”</p>
<p>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单</p>
<h2 id="享元模式："><a href="#享元模式：" class="headerlink" title="享元模式："></a>享元模式：</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>运用共享技术来有效地支持大量细粒度对象地复用。它通过共享已经存在的对象大幅度减少需要创建的对象数量，避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<h3 id="结构：-1"><a href="#结构：-1" class="headerlink" title="结构："></a>结构：</h3><p>内部状态：即不会随着环境的改变而改变的可共享部分</p>
<p>外部状态：指随着环境改变而改变的不可可共享的部分</p>
<p>主要角色：</p>
<p>抽象享元角色：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据，同时可以通过这些方法来设置外部数据</p>
<p>具体享元角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。</p>
<p>非享元角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建</p>
<p>享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在，则创建一个新的享元对象</p>
<h3 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h3><p>极大减少了内存中相似或相同对象数量，节约系统资源，提高系统性能</p>
<p>享元模式中外部状态相对独立，且不影响内部状态</p>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，它涉及算法与对象间职责的分配</p>
<p>行为模式分为类行为模式和对象行为模式。前者采用继承机制在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式有更大的灵活性。</p>
<h2 id="模板方法模式："><a href="#模板方法模式：" class="headerlink" title="模板方法模式："></a>模板方法模式：</h2><p>设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体环境相关</p>
<h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<h3 id="结构：-2"><a href="#结构：-2" class="headerlink" title="结构："></a>结构：</h3><p>抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成</p>
<p>​	模板方法：定义了算法骨架，按照某种顺序调用其包含的基本方法</p>
<p>​	基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。</p>
<p>​		抽象方法：一个抽象方法由抽象类声明，由其具体子类实现</p>
<p>​		具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承</p>
<p>​		钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种</p>
<p>​		一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXXX，返回类型为boolean</p>
<p>具体子类：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤</p>
<h3 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h3><p>提高代码复用性</p>
<p>实现了反转控制</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>每个实现都需要定义一个子类</p>
<p>提高了代码阅读的难度</p>
<h2 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h2><h3 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h3><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h3 id="结构：-3"><a href="#结构：-3" class="headerlink" title="结构："></a>结构：</h3><p>抽象策略类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有具体策略所需的接口</p>
<p>具体策略类：实现了抽象策略定义的接口，提供具体的算法实现或行为</p>
<p>环境类：持有一个策略类的引用，最终给客户端调用</p>
<h3 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h3><p>策略类直接按可以自由切换</p>
<p>易于扩展</p>
<p>避免使用多重条件选择语句，充分体现面向对象设计思想</p>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><p>客户端必须知道所有策略类，并自行决定使用哪一个策略类</p>
<p>策略模式将造成产生很多策略，可以通过使用享元模式在一定程度上减少对象的数量</p>
<h2 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>日常生活中，顾客点餐后把订单给服务员，服务员将订单给厨师，厨师出餐</p>
<h3 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h3><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开。这样两者之间通过命令对象进行沟通，这样方便命令对象进行存储，传递，调用，增加与管理</p>
<h3 id="结构：-4"><a href="#结构：-4" class="headerlink" title="结构："></a>结构：</h3><p>抽象命令类角色：定义命令的接口，声明执行的方法</p>
<p>具体命令角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成要执行的操作</p>
<p>实现者&#x2F;接收者角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能</p>
<p>调用者&#x2F;请求者角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多命令对象。这个客户端真正触发命令并要求命令执行相应操作的地方，也就是使用命令对象的入口</p>
<h3 id="优点：-7"><a href="#优点：-7" class="headerlink" title="优点："></a>优点：</h3><p>降低系统的耦合度</p>
<p>增减或删除命令非常方便</p>
<p>可以实现宏命令。命令模式可以和组合模式结合将多个命令装配成一个组合命令，即宏命令</p>
<p>方便实现undo和redo操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复</p>
<h3 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h3><p>使用命令模式可能会导致某些系统有过多的具体命令类</p>
<p>系统结构更加复杂</p>
<h3 id="JDK源码解析：-2"><a href="#JDK源码解析：-2" class="headerlink" title="JDK源码解析："></a>JDK源码解析：</h3><p>Runable是一个典型的命令模式</p>
<h2 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p>现实生活中，一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。</p>
<h3 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h3><p>为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一个对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿这条链传递，直到有对象处理它为止</p>
<h3 id="结构：-5"><a href="#结构：-5" class="headerlink" title="结构："></a>结构：</h3><p>抽象处理者角色：定义一个处理请求的接口，包含抽象处理方法和后一个连接</p>
<p>具体处理者角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者</p>
<p>客户类角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和传递过程</p>
<h3 id="优点：-8"><a href="#优点：-8" class="headerlink" title="优点："></a>优点：</h3><p>降低了对象之间的耦合度</p>
<p>增强了系统的可扩展性</p>
<p>增强了给对象指派职责的灵活性</p>
<p>责任链简化了对象之间的连接</p>
<p>责任分担</p>
<h3 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h3><p>不能保证每一个请求一定被处理</p>
<p>对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</p>
<p>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错</p>
<p>JavaWeb中的FilterChain就是职责链模式</p>
<h2 id="状态模式："><a href="#状态模式：" class="headerlink" title="状态模式："></a>状态模式：</h2><h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><p>通过按钮来控制电梯的状态，一个电梯门有开门，关门，运行，停止，每一种状态都需要根据其他状态来改变</p>
<h3 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h3><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象种，允许状态对象在其内部状态发生改变时改变其行为</p>
<h3 id="结构：-6"><a href="#结构：-6" class="headerlink" title="结构："></a>结构：</h3><p>环境角色：定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象处理</p>
<p>抽象状态角色：定义一个接口，用以封装环境对象种的特定状态所对应的行为</p>
<p>具体状态角色：实现抽象状态所对应的行为</p>
<h3 id="优点：-9"><a href="#优点：-9" class="headerlink" title="优点："></a>优点：</h3><p>将所有与某个状态有关的行为放到一个类种，并且可以方便增加新的状态，只需要改变对象状态即可改变对象的行为</p>
<p>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块</p>
<h3 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h3><p>状态模式的使用必然会增加系统类和对象的个数</p>
<p>状态模式和结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱</p>
<p>状态模式对“开闭原则”并不太支持</p>
<h2 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h2><h3 id="定义：-7"><a href="#定义：-7" class="headerlink" title="定义："></a>定义：</h3><p>发布订阅模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象变化时，会通知所有的观察者对象，使他们能够自动更新自己</p>
<h3 id="结构：-7"><a href="#结构：-7" class="headerlink" title="结构："></a>结构：</h3><p>抽象主题（被观察者）：抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象</p>
<p>具体主题（具体观察者）：该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知</p>
<p>抽象观察者：是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己</p>
<p>具体观察者：实现抽象观察者定义的更新接口，以便得到主题更改通知时更新自身的状态</p>
<h3 id="优点：-10"><a href="#优点：-10" class="headerlink" title="优点："></a>优点：</h3><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</p>
<p>被观察者发送通知，所有注册的观察者都会收到信息</p>
<h3 id="缺点：-6"><a href="#缺点：-6" class="headerlink" title="缺点："></a>缺点：</h3><p>如果观察者非常多，那么所有的观察者收到被观察者发送的通知会耗时</p>
<p>如果被观察者有循环依赖，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</p>
<h3 id="JDK实现："><a href="#JDK实现：" class="headerlink" title="JDK实现："></a>JDK实现：</h3><p>java.util.Observable类和java.util.Observer接口定义了观察者模式，只要实现他们的子类就可以编写观察者模式实例</p>
<h2 id="中介者模式："><a href="#中介者模式：" class="headerlink" title="中介者模式："></a>中介者模式：</h2><p>一般来说，多个类之间相互关联时，他们之间的关系会呈现复杂的网状结构，引入中介者模式，那么多个类之间通过中介者类相互关联</p>
<h3 id="定义：-8"><a href="#定义：-8" class="headerlink" title="定义："></a>定义：</h3><p>定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立改变他们之间的交互</p>
<h3 id="结构：-8"><a href="#结构：-8" class="headerlink" title="结构："></a>结构：</h3><p>抽象中介者：它是中介者的接口，提供了同事对象注册与转发信息的抽象方法</p>
<p>具体中介者：实现中介者接口，定义一个List来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同时角色</p>
<p>抽象同事类：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</p>
<p>具体同事类：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互</p>
<h3 id="优点：-11"><a href="#优点：-11" class="headerlink" title="优点："></a>优点：</h3><p>松散耦合</p>
<p>集中控制交互</p>
<p>一对多关联转变为一对一的关联</p>
<h3 id="缺点：-7"><a href="#缺点：-7" class="headerlink" title="缺点："></a>缺点：</h3><p>当同事类太多，中介者的职责将很大，它会变得复杂庞大，以至于系统难以维护</p>
<h2 id="迭代器模式："><a href="#迭代器模式：" class="headerlink" title="迭代器模式："></a>迭代器模式：</h2><h3 id="定义：-9"><a href="#定义：-9" class="headerlink" title="定义："></a>定义：</h3><p>提供了一个对象来顺序访问聚合对象的一系列数据，而不暴露聚合对象的内部表示</p>
<h3 id="结构：-9"><a href="#结构：-9" class="headerlink" title="结构："></a>结构：</h3><p>抽象聚合角色：定义存储，添加，删除聚合元素以及创建迭代器对象的接口</p>
<p>具体聚合角色：实现抽象聚合类，返回一个具体迭代器的实例</p>
<p>抽象迭代器角色：定义访问和遍历聚合元素的接口，通常包含hasNext（），next（）等方法</p>
<p>具体迭代器角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</p>
<h3 id="优点：-12"><a href="#优点：-12" class="headerlink" title="优点："></a>优点：</h3><p>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来代替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式</p>
<p>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方式，这样可以简化聚合类的设计</p>
<p>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求</p>
<h2 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h2><h3 id="定义：-10"><a href="#定义：-10" class="headerlink" title="定义："></a>定义：</h3><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新操作</p>
<h3 id="结构：-10"><a href="#结构：-10" class="headerlink" title="结构："></a>结构：</h3><p>抽象访问者角色：定义了对每一个元素访问的行为，它的参数就时可以访问的元素，它的方法个数理论上来讲与元素个数是一样的，从这点不难看出，访问者模式要求元素的个数不能改变</p>
<p>具体访问者角色：给出对每一个元素类访问时所产生的具体行为</p>
<p>抽象元素角色：定义了一个接受访问者的方法，其意义指，每一个元素都要可以被访问者访问</p>
<p>具体元素角色：提供接受访问方法的具体实现，而这个具体实现，通常情况下是使用访问者提供的访问该元素类的方法</p>
<p>对象结构角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素，并且可以迭代这些元素，供访问者访问</p>
<h3 id="优点：-13"><a href="#优点：-13" class="headerlink" title="优点："></a>优点：</h3><p>扩展性好</p>
<p>复用性好</p>
<p>分离无关行为</p>
<h3 id="缺点：-8"><a href="#缺点：-8" class="headerlink" title="缺点："></a>缺点：</h3><p>对象结构变化很困难</p>
<p>违反了依赖倒置原则</p>
<h2 id="备忘录模式："><a href="#备忘录模式：" class="headerlink" title="备忘录模式："></a>备忘录模式：</h2><p>备往录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将记录状态复原，很多软件都提供撤销操作，如Word，记事本，Photoshop，IDEA等软件在编辑时按Ctrl+z组合键时能撤销当前操作</p>
<h3 id="定义：-11"><a href="#定义：-11" class="headerlink" title="定义："></a>定义：</h3><p>又叫快照模式。在不破坏封装性的前提下，铺货一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要将该对象恢复到原先保存的状态</p>
<h3 id="结构：-11"><a href="#结构：-11" class="headerlink" title="结构："></a>结构：</h3><p>发起人角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务，它可以访问备忘录里所有信息</p>
<p>备忘录角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人</p>
<p>管理者角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备往录的内容进行访问与修改</p>
<p>备忘录有两个等效接口：</p>
<p>窄接口：管理者对象看到的备忘录的窄接口，这个窄接口只允许他把备忘录对象传给其他对象</p>
<p>宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态</p>
<h2 id="解释器模式："><a href="#解释器模式：" class="headerlink" title="解释器模式："></a>解释器模式：</h2><h3 id="定义：-12"><a href="#定义：-12" class="headerlink" title="定义："></a>定义：</h3><p>给定一个语言，定义它的文法，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</p>
<h3 id="文法（语言）规则："><a href="#文法（语言）规则：" class="headerlink" title="文法（语言）规则："></a>文法（语言）规则：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expression::=value|plus|minus</span><br><span class="line">plus::=expression &#x27;+&#x27; expression</span><br></pre></td></tr></table></figure>

<h3 id="结构：-12"><a href="#结构：-12" class="headerlink" title="结构："></a>结构：</h3><p>抽象表达式角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法</p>
<p>终结符表达式角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每条规则都对应一个非终结符表达式</p>
<p>环境角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值</p>
<p>客户端：主要任务是将需要分析的句子或者表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 23:48:48" itemprop="dateCreated datePublished" datetime="2023-08-13T23:48:48+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 00:46:18" itemprop="dateModified" datetime="2023-08-14T00:46:18+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MySQL</p>
<p>关系型数据库</p>
<h1 id="SQL语句："><a href="#SQL语句：" class="headerlink" title="SQL语句："></a>SQL语句：</h1><h2 id="基本语句："><a href="#基本语句：" class="headerlink" title="基本语句："></a>基本语句：</h2><h3 id="SELECT语句："><a href="#SELECT语句：" class="headerlink" title="SELECT语句："></a>SELECT语句：</h3><p>select  字段 from 表</p>
<h3 id="列的别名："><a href="#列的别名：" class="headerlink" title="列的别名："></a>列的别名：</h3><p>有三种方式：什么都不加在列的字段后空一格，加AS ，加“”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id AS e_id FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="去除重复行："><a href="#去除重复行：" class="headerlink" title="去除重复行："></a>去除重复行：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id FROM employees;</span><br><span class="line"></span><br><span class="line">#去除重复</span><br><span class="line">SELECT DISTINC employee_id FROM employees;</span><br></pre></td></tr></table></figure>

<h3 id="空值参与运算："><a href="#空值参与运算：" class="headerlink" title="空值参与运算："></a>空值参与运算：</h3><p>空值：null</p>
<p>null不等同于0，’ ‘, ‘null’</p>
<p>运算结果就是空值</p>
<h3 id="着重号："><a href="#着重号：" class="headerlink" title="着重号："></a>着重号：</h3><p>&#96;&#96;   —– 1左边的符号  为了消除与关键字同名的情况</p>
<h3 id="查询常数："><a href="#查询常数：" class="headerlink" title="查询常数："></a>查询常数：</h3><h3 id="显示表结构："><a href="#显示表结构：" class="headerlink" title="显示表结构："></a>显示表结构：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DESCRIBE employees; #显示了表中字段的详细信息</span><br><span class="line">DESC employees;</span><br></pre></td></tr></table></figure>

<h3 id="过滤数据："><a href="#过滤数据：" class="headerlink" title="过滤数据："></a>过滤数据：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#过滤条件 where</span><br><span class="line">SELECT * FROM employees where id = 50;</span><br></pre></td></tr></table></figure>

<h3 id="算术运算符的使用："><a href="#算术运算符的使用：" class="headerlink" title="算术运算符的使用："></a>算术运算符的使用：</h3><p>+， - ，* ，&#x2F;</p>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><p>DDL：数据定义语言，用来定义数据库对象（数据库，表，字段）</p>
<p>DML：数据操作语言，用来对数据库表中的数据进行增删改</p>
<p>DQL：数据查询语言，用来查询数据库表中的记录</p>
<p>DCL：数据控制语言，用来创建数据库用户，控制数据库的访问权限</p>
<h2 id="DDL语句："><a href="#DDL语句：" class="headerlink" title="DDL语句："></a>DDL语句：</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<p>查询当前数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>

<p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集][COLLATE 排序规则];</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><p>查询当前数据库所有表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p>查询表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>

<p>查询指定表的建表语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure>

<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	字段1 字段1类型[COMMENT 字段1注释],</span><br><span class="line">	字段2 字段1类型[COMMENT 字段2注释],</span><br><span class="line">	字段3 字段1类型[COMMENT 字段3注释],</span><br><span class="line">	字段4 字段1类型[COMMENT 字段4注释]</span><br><span class="line">	</span><br><span class="line">)[commet 表注释];</span><br></pre></td></tr></table></figure>

<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>添加字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 字段名 类型（长度）</span><br></pre></td></tr></table></figure>

<p>修改字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 字段名 新数据类型（长度）</span><br></pre></td></tr></table></figure>

<p>修改字段名和字段类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 旧字段名 新字段名 类型（长度）</span><br></pre></td></tr></table></figure>

<p>删除字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段</span><br></pre></td></tr></table></figure>

<p>修改表名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename to 新表名</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table [if exists] 表名</span><br></pre></td></tr></table></figure>

<p>删除指定表，并重新创建该表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table 表名</span><br></pre></td></tr></table></figure>

<h2 id="DML语句："><a href="#DML语句：" class="headerlink" title="DML语句："></a>DML语句：</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>1.给指定字段添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(字段名1,字段名2,...) values(值1,值2,..);</span><br></pre></td></tr></table></figure>

<p>2.给全部字段添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values(值1,值2,...);</span><br></pre></td></tr></table></figure>

<p>3.批量添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(字段名1,字段名2,...) values(值1,值2,..),(值1,值2,..);</span><br><span class="line">insert into values(值1,值2,..),(值1,值2,..);</span><br></pre></td></tr></table></figure>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名1=值1,字段名2=值2,...[where 条件];</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [where 条件]</span><br></pre></td></tr></table></figure>

<h2 id="DQL语句："><a href="#DQL语句：" class="headerlink" title="DQL语句："></a>DQL语句：</h2><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">	字段列表</span><br><span class="line">from</span><br><span class="line">	表名列表</span><br><span class="line">where</span><br><span class="line">	条件列表</span><br><span class="line">group by</span><br><span class="line">	分组字段列表</span><br><span class="line">having</span><br><span class="line">	分组后条件列表</span><br><span class="line">order by</span><br><span class="line">	排序字段列表</span><br><span class="line">limit</span><br><span class="line">	分页参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><p>1.查询多个字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1，字段2，... from 表名;</span><br></pre></td></tr></table></figure>

<p>2.设置别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段1 [as 别名1]，字段2 [as 别名2] ...from 表名;</span><br></pre></td></tr></table></figure>

<p>3.去除重复记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct 字段列表 from 表名;</span><br></pre></td></tr></table></figure>

<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名 where 条件</span><br></pre></td></tr></table></figure>

<p>is null ，is not null</p>
<p>!&#x3D; , &lt;&gt;  —-不等于</p>
<p>&amp;&amp; ，and —–两个条件</p>
<p>|| , or —–或</p>
<p>in</p>
<p>模糊查询：</p>
<p>下划线_是占位符 百分号%是任意个字符</p>
<p>like </p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算</p>
<p>常见聚合函数</p>
<p>count</p>
<p>max</p>
<p>min</p>
<p>avg</p>
<p>sum</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 聚合函数(操作的字段) from 表名;</span><br></pre></td></tr></table></figure>

<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件]</span><br></pre></td></tr></table></figure>

<p>where 和 having的区别：</p>
<p>执行时机不同：where 是分组之前进行过滤，having是分组后</p>
<p>判断条件不同：where不能对聚合函数进行判断，而having可以</p>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名 order by 字段1 排序方式1，字段2 排序方式2;</span><br></pre></td></tr></table></figure>

<p>排序方式</p>
<p>ASC:升序</p>
<p>DESC:降序</p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名 limit 起始索引,查询记录数;</span><br></pre></td></tr></table></figure>

<h2 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h2><p>数据控制语句，用来管理数据库用户，控制数据库访问权限</p>
<h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><p>1.查询用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select * from user;</span><br></pre></td></tr></table></figure>

<p>2.创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>3.修改用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified where mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure>

<p>4.删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>1.查询权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>2.授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>3.撤销权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h1><p>指一段可以直接被另一段程序调用的程序或代码</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">concat(s1,s2,….,sn)</td>
<td align="center">字符串拼接</td>
</tr>
<tr>
<td align="center">lower(str)</td>
<td align="center">将字符串str全部转为小写</td>
</tr>
<tr>
<td align="center">upper(str)</td>
<td align="center">将字符串str全部转为大写</td>
</tr>
<tr>
<td align="center">lpad(str,n,pad)</td>
<td align="center">左填充，用字符串pad对str左填充，达到n个字符串</td>
</tr>
<tr>
<td align="center">rpad(str,n,pad)</td>
<td align="center">右填充，用字符串pad对str右填充，达到n个字符串</td>
</tr>
<tr>
<td align="center">trim(str)</td>
<td align="center">去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td align="center">substring(str,start,len)</td>
<td align="center">返回字符串str从start位置起的len个长度的字符串</td>
</tr>
</tbody></table>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ceil(x)</td>
<td align="center">向上取整</td>
</tr>
<tr>
<td align="center">floor(x)</td>
<td align="center">向下取整</td>
</tr>
<tr>
<td align="center">mod(x，y)</td>
<td align="center">返回x&#x2F;y的模</td>
</tr>
<tr>
<td align="center">rand</td>
<td align="center">返回0~1内的随机数</td>
</tr>
<tr>
<td align="center">round(x,y)</td>
<td align="center">求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody></table>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">curdate()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">curtime()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">now()</td>
<td align="center">返回当前日前和时间</td>
</tr>
<tr>
<td align="center">year(date)</td>
<td align="center">获取指定date的年份</td>
</tr>
<tr>
<td align="center">month(date)</td>
<td align="center">获取指定date的月份</td>
</tr>
<tr>
<td align="center">day(date)</td>
<td align="center">获取指定date的日期</td>
</tr>
<tr>
<td align="center">date_add(date,interval expr type)</td>
<td align="center">返回一个日期&#x2F;时间值加上一个时间间隔expr之后的时间值</td>
</tr>
<tr>
<td align="center">datediff(date1,date2)</td>
<td align="center">返回起始时间date1和结束时间date2之间的天数</td>
</tr>
</tbody></table>
<h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">if(value, t,f)</td>
<td align="center">如果value为true则返回t，否则返回f</td>
</tr>
<tr>
<td align="center">ifnull(value1,value2)</td>
<td align="center">如果value1不为空，否则返回value2</td>
</tr>
<tr>
<td align="center">case when [val1] then [res] …else [default] end</td>
<td align="center">如果val1为true，返回res1,…否则返回default</td>
</tr>
<tr>
<td align="center">case [expr] when [val1] then [res] …else [default] end</td>
<td align="center">如果expr的值等于val1，返回res1,..否则返回default</td>
</tr>
</tbody></table>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作用于表中字段上的规则，用于限制存储表中的数据</p>
<p>保证数据库中数据的正确，有效性和完整性</p>
<table>
<thead>
<tr>
<th align="center">约束</th>
<th align="center">描述</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">非空约束</td>
<td align="center">限制该字段的数据不能为null</td>
<td align="center">not null</td>
</tr>
<tr>
<td align="center">唯一约束</td>
<td align="center">保证该字段的所有数据都是唯一，不重复的</td>
<td align="center">unique</td>
</tr>
<tr>
<td align="center">主键约束</td>
<td align="center">主键是一行数据的唯一标识，要求非空且唯一</td>
<td align="center">primary key</td>
</tr>
<tr>
<td align="center">默认约束</td>
<td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td>
<td align="center">default</td>
</tr>
<tr>
<td align="center">检查约束</td>
<td align="center">保证字段值满足某一个条件</td>
<td align="center">check</td>
</tr>
<tr>
<td align="center">外键约束</td>
<td align="center">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td align="center">foreign key</td>
</tr>
</tbody></table>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(主表列名);</span><br></pre></td></tr></table></figure>

<h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><p>表的关系基本分为三种：</p>
<h3 id="一对多（多对一）"><a href="#一对多（多对一）" class="headerlink" title="一对多（多对一）"></a>一对多（多对一）</h3><p>将外键和另一张表主键连接</p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>例子：学生和课程关系</p>
<p>实现：建立第三张表</p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>例子：用户与用户详情的关系</p>
<p>实现：在任意一方加入外键，关联另一方的主键，并设置外键为唯一</p>
<h2 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h2><p>从多张表中查询</p>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>查询两张表交集部分</p>
<p>隐式内连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1, 表2 where 条件</span><br></pre></td></tr></table></figure>

<p>显示内连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1 inner join 表2 on 条件</span><br></pre></td></tr></table></figure>

<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>左外连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1 left outer join 表2 on 条件</span><br></pre></td></tr></table></figure>

<p>右外连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1 right outer join 表2 on 条件</span><br></pre></td></tr></table></figure>

<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表1 别名1 join 表1 别名2 on 条件</span><br></pre></td></tr></table></figure>

<h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表a ...</span><br><span class="line">union [all]</span><br><span class="line">select 字段列表 from 表b ...;</span><br></pre></td></tr></table></figure>

<p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p>
<p>union all 会将全部的数据直接合并在一起，union会对合并之后的数据去重</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>概念：SQL语句中嵌套select语句，称为嵌套查询，又称子查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 where column1 = (select column1 from t2);</span><br></pre></td></tr></table></figure>

<p>子查询外部的语句可以是insert &#x2F; update &#x2F; delete &#x2F; select 中的任何一个</p>
<p>子查询的结果，分为：</p>
<p>标量子查询（子查询结果为单个值）</p>
<p>列子查询（子查询结果为一列）</p>
<p>行子查询（子查询结果为一行）</p>
<p>表子查询（子查询结果为多行多列）</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>查看&#x2F;设置事务提交方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@autocommit;</span><br><span class="line">set @@autocommit =0;</span><br></pre></td></tr></table></figure>

<p>开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction; </span><br></pre></td></tr></table></figure>

<p>提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>回滚事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><p>原子性：事务是不可分割的最小操作单元</p>
<p>一致性：事务完成时，必须所有的数据都保持一致状态</p>
<p>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作的影响独立环境下运行</p>
<p>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</p>
<h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><p>脏读：一个事务读到另外一个事务还没有提交的数据</p>
<p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</p>
<p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>出现</td>
<td>出现</td>
<td>出现</td>
</tr>
<tr>
<td>Read committed</td>
<td></td>
<td>出现</td>
<td>出现</td>
</tr>
<tr>
<td>Repeatable Read(默认)</td>
<td></td>
<td></td>
<td>出现</td>
</tr>
<tr>
<td>Serializable</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 查看事务隔离级别</span><br><span class="line">select @@transaction_isolation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 设置事务隔离级别</span><br><span class="line">set [session|global] transaction isolation level &#123;read uncommitted|read committed|repeatable read|serializable&#125;</span><br></pre></td></tr></table></figure>

<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p>连接层：</p>
<p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、以及相关安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<p>服务层：</p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
<p>引擎层：</p>
<p>存储引擎真正负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
<p>存储层：</p>
<p>主要是将数据存储在文件系统之上，并完成于存储引擎的交互。</p>
<h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p>是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p>
<p>1.在创建表时，指定存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	....</span><br><span class="line">)engines = InnoDB;</span><br></pre></td></tr></table></figure>

<p>2.查询数据库支持的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines;</span><br></pre></td></tr></table></figure>

<h2 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>特点：</p>
<p>事务，行级锁，外键</p>
<p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220729154511649.png" alt="image-20220729154511649"></p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>特点</p>
<p>不支持事务，不支持外键，</p>
<p>支持表锁，不支持行锁</p>
<p>访问速度快</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>特点</p>
<p>内存存放o</p>
<h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>InnoDB：是MySQL的默认存储引擎，支持事务，外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新，删除操作，那么InnoDB存储引擎是比较适合的选择。</p>
<p>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常适合的。</p>
<p>Memory：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。memory的缺陷就是对表的大小有限制，太大无法缓存在内存中，而且无法保障数据的安全性。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p>索引是帮助Mysql高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<p>优缺点：</p>
<p>优点：</p>
<p>提高数据检索的效率，降低数据库的IO成本</p>
<p>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</p>
<p>缺点：</p>
<p>索引列也是要占用空间的</p>
<p>索引大大提高了查询效率，同时却也降低更新表的速度</p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+ Tree</td>
<td>最常见的索引类型，大部分引擎都支持B+Tree索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询</td>
</tr>
<tr>
<td>R-tree（空间索引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-text（全文索引）</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr,ES</td>
</tr>
</tbody></table>
<h3 id="B-Tree（多路平衡查找树）"><a href="#B-Tree（多路平衡查找树）" class="headerlink" title="B-Tree（多路平衡查找树）"></a>B-Tree（多路平衡查找树）</h3><p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220729162125455.png" alt="image-20220729162125455"></p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220729162534758.png" alt="image-20220729162534758"></p>
<p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220729162645274.png" alt="image-20220729162645274"></p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希索引就是采用一定hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。</p>
<p>如果两个（或多个键值），映射到同一个槽位上，他们就产生了hash冲突，通过链表解决。</p>
<p>特点：</p>
<p>hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&gt;,&lt;, …)</p>
<p>无法利用索引完成排序操作</p>
<p>查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree索引</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对于表中主键创建的索引</td>
<td>默认自动创建，只有一个</td>
<td>primary</td>
</tr>
<tr>
<td>唯一索引</td>
<td>避免同一个表中某数据列中的值重复</td>
<td>可以多个</td>
<td>unique</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位特定数据</td>
<td>可以多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td>
<td>可以多个</td>
<td>full text</td>
</tr>
</tbody></table>
<p>在InnoDB村粗引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<p>聚集索引：将数据存储与索引放到一块，索引结构的叶子节点保存了行数据，必须有，而且只有一个</p>
<p>二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键，可以存在多个</p>
<p>聚集索引选取规则：</p>
<p>如果存在主键，主键就是聚集索引</p>
<p>如果不存在主键，将使用第一个唯一索引作为聚集索引</p>
<p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</p>
<h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [unique|fulltext] index index_name on table_name (index_col_name,...);</span><br></pre></td></tr></table></figure>

<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from table_name;</span><br></pre></td></tr></table></figure>

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table_name;</span><br></pre></td></tr></table></figure>



<h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="sql执行频率"><a href="#sql执行频率" class="headerlink" title="sql执行频率"></a>sql执行频率</h3><p>增删改查的使用频率</p>
<p>MySQL客户端连接成功后，通过show[session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的insert ，update，delete ，select 的访问频率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status like &#x27;com_______&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL的慢查询日志默认是没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#开启MySQL中慢日志查询开关</span><br><span class="line">slow_query_log = 1</span><br><span class="line"></span><br><span class="line">#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time = 2</span><br></pre></td></tr></table></figure>

<h3 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h3><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费在哪。通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@having_profiling;</span><br></pre></td></tr></table></figure>

<p>默认profiling是关闭的，可以通过set语句在session&#x2F;global级别开启profiling：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set profiling=1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看每一条SQL的耗时基本情况</span><br><span class="line">show profiles;</span><br><span class="line"></span><br><span class="line">#查看指定query——id的SQL语句各个阶段的耗时情况</span><br><span class="line">show profile for query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定query——id的语句CPU使用情况</span><br><span class="line">show profile cpu for query query_id;</span><br></pre></td></tr></table></figure>

<h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3><p>explain或者desc命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select 字段列表 from 表名 where 条件;</span><br></pre></td></tr></table></figure>

<h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>如果索引了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳跃了某一列，索引将部分失效</p>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>联合索引中，出现范围查询（&gt;,&lt;），范围查询右侧的列索引失效</p>
<h3 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h3><p>不要在索引列上进行运算操作，索引将失效</p>
<h3 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h3><p>索引将失效</p>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引将失效</p>
<h3 id="or连接的条件"><a href="#or连接的条件" class="headerlink" title="or连接的条件"></a>or连接的条件</h3><p>用or分割开的条件，如果前面的列有索引，而后面的列没有索引，那么涉及的索引都不会被用到</p>
<h3 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h3><p>如果MySQL评估使用索引比全表更慢，则不使用索引</p>
<h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><p>SQL提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的</p>
<p>use index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user use index(id_user_pro) where username = &#x27;qian&#x27;;</span><br></pre></td></tr></table></figure>

<p>ignore index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user ignore index(id_user_pro) where username = &#x27;qian&#x27;;</span><br></pre></td></tr></table></figure>

<p>force index</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user force index(id_user_pro) where username = &#x27;qian&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select *</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串，有时需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量得磁盘IO，此时，可以只将一部分前缀，建立索引，节约索引空间，从而提高索引效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index id_xxxx on table_name(column(n));</span><br></pre></td></tr></table></figure>

<h3 id="单列索引和联合索引"><a href="#单列索引和联合索引" class="headerlink" title="单列索引和联合索引"></a>单列索引和联合索引</h3><p>如果存在多个查询条件，考虑使用联合索引</p>
<h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><p>1.针对于数据量较大，且查询频繁得表建立索引（100w）</p>
<p>2.针对于常作为查询条件（where），排序（order by) ，分组（group by）操作得字段建立索引</p>
<p>3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</p>
<p>4.如果是字符串类型的字段，字段的长度较长，可以针对字段的特点，建立前缀索引</p>
<p>5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表</p>
<p>6.要控制索引的数量，索引不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</p>
<p>7.如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值，它可以更好地确定哪个索引最有效地用于查询</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="insert优化"><a href="#insert优化" class="headerlink" title="insert优化"></a>insert优化</h3><p>（1）批量操作（500-1000条）</p>
<p>（2）手动提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into ....</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>（3）主键顺序插入</p>
<h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>使用load指令进行插入</p>
<p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220729203238888.png" alt="image-20220729203238888"></p>
<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><h3 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h3><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放地，这种存储方式地表称为索引组织表</p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据，根据主键排序。</p>
<p>主键乱序会插入会造成页分裂</p>
<h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>当删除一行记录时，实际上记录并没有被物理清除，只是标记为删除并且它地空间变得允许被其他记录声明使用。当页中删除地记录达到MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页看看是否可以将两个页合并以优化空间使用。</p>
<h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><p>（1）using filesort ：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</p>
<p>（2）using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index ，不需要额外排序，操作效率高</p>
<h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><h2 id="limit-优化"><a href="#limit-优化" class="headerlink" title="limit 优化"></a>limit 优化</h2><p>覆盖索引加子查询的方式优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table_name id in (select id from table_name order by id limit 20000,10);</span><br><span class="line"></span><br><span class="line">select s.* from table_name as s ,(select id from table_name order by id limit 20000,10) as a where s.id=a.id;</span><br></pre></td></tr></table></figure>

<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><p>InnoDB执行count（*）的时候，需要把数据一行一行地读出来，然后累计</p>
<p>优化思路：自己计数</p>
<h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁</p>
<h1 id="视图-存储过程-触发器"><a href="#视图-存储过程-触发器" class="headerlink" title="视图&#x2F;存储过程&#x2F;触发器"></a>视图&#x2F;存储过程&#x2F;触发器</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
<p>简单来说，视图只保存了查询的SQL逻辑，不保存查询结果，所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上</p>
<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [or replace] view 视图名称（列名列表） as select语句 [with[cascaded|local]check option]</span><br></pre></td></tr></table></figure>

<h3 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show create view 视图名称;</span><br><span class="line"></span><br><span class="line">select * from  视图名称;</span><br></pre></td></tr></table></figure>

<h3 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方式一：create [or replace] view 视图名称 as select语句 [with[cascaded|local]check option]</span><br><span class="line">方式二：alter view 视图名称 as select语句 [with[cascaded|local]check option]</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view [if exists] 视图名称;</span><br></pre></td></tr></table></figure>

<h3 id="视图更新"><a href="#视图更新" class="headerlink" title="视图更新"></a>视图更新</h3><p>要使视图可以更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，该视图不可更新：</p>
<p>1.聚合函数或窗口函数（sum(),min(),max(),count())</p>
<p>2.distinct</p>
<p>3.group by</p>
<p>4.having </p>
<p>5.union 或者 union all</p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>简单</p>
<p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p>
<p>安全</p>
<p>数据库可以授权，但不能授权到特定行和列上，通过视图用户只能查询和修改他们所能见的数据</p>
<p>数据独立</p>
<p>视图可以帮助用户屏蔽真实表格结构变化带来的影响</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p>
<p>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>封装，重用</p>
<p>可以接收参数，也可以返回数据</p>
<p>减少网络交互，提高效率</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建</p>
<p>参数类型 in&#x2F;out&#x2F;inout</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create procedure 存储过程名称([参数列表])</span><br><span class="line">begin</span><br><span class="line">	sql语句</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call 名称([参数])</span><br></pre></td></tr></table></figure>

<p>查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.routines where routine_schema = &#x27;数据库名称&#x27;</span><br><span class="line"></span><br><span class="line">show create procedure 存储过程名称;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure [if exists] 存储过程名称;</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>系统变量是MySQ服务器提供的，不是用户定义的，属于服务器层面。分为全局变量（global），会话变量（session）。</p>
<p>查看系统变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show [session|global] variables;         -- 查看所有系统变量</span><br><span class="line">show [session|global] variables like &#x27;...&#x27; ;   -- 可以通过like 模糊匹配方式查找变量</span><br><span class="line">select @@[session|global] 系统变量名;  -- 查看指定变量的值</span><br></pre></td></tr></table></figure>

<p>设置系统变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set [session|global] 系统变量名 = 值;</span><br><span class="line"></span><br><span class="line">set @@[session|global] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>

<p>用户定义变量</p>
<p>是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。</p>
<p>赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @var)name = expr [,@var_name = expr] ...;</span><br><span class="line">set @var)name := expr [,@var_name := expr] ...;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @var_name := expr [,@var_name := expr] ...;</span><br><span class="line">select 字段名 into @var_name from 表名;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @var_name；</span><br></pre></td></tr></table></figure>

<p>局部变量</p>
<p>根据需要定义在局部生效的变量，访问之前，需要declare声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的begin 。。。end块。</p>
<p>声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare 变量名 变量类型[default ...];</span><br></pre></td></tr></table></figure>

<p>变量类型就是数据库字段类型：int ，bigint ，char ，varchar ，date ， time </p>
<p>赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set 变量名=值;</span><br><span class="line">set 变量名 :=值;</span><br><span class="line">select 字段名 into 变量名 from 表名..;</span><br></pre></td></tr></table></figure>

<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件1 then</span><br><span class="line">	....</span><br><span class="line">elseif 条件2 then</span><br><span class="line">	....</span><br><span class="line">else</span><br><span class="line">	....</span><br><span class="line">end if;</span><br></pre></td></tr></table></figure>

<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220730125527750.png" alt="image-20220730125527750"></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line">	sql语句</span><br><span class="line">endwhile;</span><br></pre></td></tr></table></figure>

<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>当满足条件退出循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">	sql语句</span><br><span class="line">	until 条件</span><br><span class="line">end repeat;</span><br></pre></td></tr></table></figure>

<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是计算机协调多个进程或线程并访问某一资源的机制。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1.全局锁：锁定数据库中的所有表</p>
<p>2.表级锁：每次操作锁住整张表</p>
<p>3.行级锁：每次操作锁住对应的行数据</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock; -- 加锁</span><br><span class="line"></span><br><span class="line">unlock tables; -- 释放锁</span><br></pre></td></tr></table></figure>

<p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --single-transaction -uroot -p密码 数据库名&gt;存储位置/名字.sql</span><br></pre></td></tr></table></figure>

<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>每次操作锁住整张表</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>1.表共享读锁</p>
<p>加了读锁，不能写，只能读</p>
<p>2.表独占写锁</p>
<p>加了写锁，不能写，不能读</p>
<p>语法</p>
<p>加锁：lock tables 表名 … read&#x2F;write</p>
<p>释放锁：unlock tables &#x2F; 客户端断开连接</p>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>meta data lock ，MDL</p>
<p>MDL加锁过程是系统自动控制，无需显示使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。</p>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向共享锁（IS）：与表级共享锁（read）兼容，与表锁排它锁（write）互斥</p>
<p>意向排它锁（IX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥</p>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>每次加锁操作锁住对应的行数据。应用在InnoDB存储引擎中</p>
<p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为三类：</p>
<p>1.行锁：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC,RR隔离级别下都支持。</p>
<p>2.间隙锁：锁定索引记录间隙，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p>
<p>3.临键锁：行锁和间隙锁的组合。在RR隔离级别下支持。</p>
<h3 id="行锁："><a href="#行锁：" class="headerlink" title="行锁："></a>行锁：</h3><p>1.共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p>
<p>2.排它锁（X）：允许获取排它锁的事务更新数据，阻止其他事务获得相同数据集得共享锁和排它锁。</p>
<h3 id="间隙锁-临键锁"><a href="#间隙锁-临键锁" class="headerlink" title="间隙锁&#x2F;临键锁"></a>间隙锁&#x2F;临键锁</h3><p>（1）索引上的等值查询（唯一索引），给不存在的记录加锁，优化为间隙锁</p>
<p>（2）索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</p>
<p>（3）索引上的范围查询（唯一索引）–会访问到不满足条件的第一个值为止</p>
<h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>表空间–ibd文件</p>
<p>段，分为数据段，索引段，回滚段。段用来管理区</p>
<p>区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p>
<p>页，是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB.为了保证页的连续性，InnoDB村粗引擎每次申请4-5个区</p>
<p>行，InnoDB存储数据是按行进行存放的</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
<p>该日志文件由两部分组成：重做日志缓冲以及重做日志文件，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p>
<p>undo log</p>
<p>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。</p>
<p>undo log和redo log 记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log 中逻辑记录读取到相应的内容并进行回滚。</p>
<p>undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志还可能用于MVCC</p>
<p>undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：</p>
<p>select … lock in share mode(共享锁)，select … for update， update，insert ，delete（排他锁）都是一种当前读。</p>
<h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>简单的select（不加锁）就是快照读，快照读，读取的记录数据的可见版本，有可能是历史数据，不加锁，就是非阻塞读。</p>
<p>Read Committed：每次select，都生成一个快照读</p>
<p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p>
<p>Serializable：快照读会退化为当前读。</p>
<h3 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h3><p>全称Multi-Version Concurrency Control,多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段，undo log ，readView。</p>
<p>记录中的隐藏字段</p>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DB_TRX_ID</td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td>
</tr>
</tbody></table>
<p>readview</p>
<p>视图读是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务id。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>m_ids</td>
<td>当前活跃的事务ID集合</td>
</tr>
<tr>
<td>min_trx_id</td>
<td>最小活跃事务ID</td>
</tr>
<tr>
<td>max_trx_id</td>
<td>预分配事务ID，当前最大事务ID+1</td>
</tr>
<tr>
<td>creator_trx_id</td>
<td>ReadView创建者的事务ID</td>
</tr>
</tbody></table>
<p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220730220458786.png" alt="image-20220730220458786"></p>
<h1 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h1><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><p>自带四个数据库，具体作用如下：</p>
<p><img src="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/MyBlog\图片\image-20220730221717911.png" alt="image-20220730221717911"></p>
<h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>记录了当mysql启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息</p>
<p>默认开启，默认存放目录&#x2F;var&#x2F;log&#x2F;mysqld.log</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%log_error%&#x27; --!查看日志位置</span><br></pre></td></tr></table></figure>

<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>记录了所有DDL语句和DML语句，但不包括数据查询（select ，show ）语句</p>
<p>作用：1.灾难时的数据恢复 2.主从复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%log_bin%&#x27;  --!查看日志位置</span><br></pre></td></tr></table></figure>

<p>日志查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog [参数选项] logfilename</span><br><span class="line"></span><br><span class="line">参数选项 ：</span><br><span class="line">	-d	指定数据库名称，只列出指定的数据库相关操作</span><br><span class="line">	-o	忽略掉日志中的前n行命令</span><br><span class="line">	-v	将行事件（数据变更）重构为SQL语句</span><br><span class="line">	-vv	将行事件重构为SQL语句，并输出注释信息</span><br></pre></td></tr></table></figure>

<p>日志删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reset master   删除全部binlog日志，删除之后，日志编号将从binlog.000001重新开始</span><br><span class="line">purge master logs to &#x27;binlog.*******&#x27;  删除*******编号之前的所有日志</span><br><span class="line">purge master logs before &#x27;yyyy-mm-dd hh24:mi:ss&#x27;   删除日志时间之前产生的所有日志</span><br></pre></td></tr></table></figure>

<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下，查询日志是未开启的。</p>
<p>开启配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修改mysql的配置文件 /etc/my.cnf文件，添加如下内容：</span><br><span class="line">general_log=1</span><br><span class="line"></span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure>

<h3 id="慢查询日志-1"><a href="#慢查询日志-1" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>记录了所有执行时间超过参数long_query_time设置值并且扫描记录数不小于min_examined_row_limit的所有SQL语句的日志，默认开启。long_query_time 默认为10秒，最小为0，精度可以到微秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log=1</span><br><span class="line"></span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行，从而使得从库和主库的数据保持同步</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>分为三步：</p>
<p>1.Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</p>
<p>2.从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log中</p>
<p>3.slave重做中继日志中的事件，将改变反映它自己的数据</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>问题分析：</p>
<p>1.IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率低，请求数据太多，带宽不够，网络IO瓶颈</p>
<p>2.CPU瓶颈：排序，分组，连接查询，聚合统计等SQL会消耗大量的CPU资源，请求数太多，CPU出现瓶颈</p>
<p>解决方案：</p>
<p>分库分表的中心思想都是将数据分散存储，使得单一数据库&#x2F;表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的</p>
<h4 id="垂直拆分："><a href="#垂直拆分：" class="headerlink" title="垂直拆分："></a>垂直拆分：</h4><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中</p>
<p>特点：</p>
<p>1.每个库的表结构都不一样</p>
<p>2.每个库的数据也不一样</p>
<p>2.所有库的并集是全量数据</p>
<p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中</p>
<p>特点：</p>
<p>1.每个表的结构都不一样</p>
<p>2.每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联</p>
<p>3.所有表的并集是全量数据</p>
<h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中</p>
<p>特点：</p>
<p>1.每个库的表结构一样</p>
<p>2.每个库的数据都不一样</p>
<p>3.所有库的并集是全量数据</p>
<p>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中</p>
<p>特点：</p>
<p>1.每个表的表结构都一样</p>
<p>2.每个表的数据都不一样</p>
<p>3.所有表的并集是全量数据</p>
<h4 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h4><p>shardingJDBC:基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析，改写，路由处理。需要自行编码配置实现，只支持java语言，性能较高</p>
<p>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者</p>
<h3 id="Mycat概述"><a href="#Mycat概述" class="headerlink" title="Mycat概述"></a>Mycat概述</h3><p>MyCat是开源的，活跃的，基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样使用mycat</p>
<p>下载链接：</p>
<p><a target="_blank" rel="noopener" href="http://dl.mycat.org.cn/">http://dl.mycat.org.cn/</a></p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>简单说就是把对数据库的读和写操作分开，以对应不用的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库地压力。</p>
<p>通过MyCat即可轻易实现上述功能</p>
<h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p>原理：MySQL的主从复制，是基于binlog的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/java%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/13/java%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 23:48:08" itemprop="dateCreated datePublished" datetime="2023-08-13T23:48:08+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 00:43:52" itemprop="dateModified" datetime="2023-08-14T00:43:52+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java的基础"><a href="#Java的基础" class="headerlink" title="Java的基础"></a>Java的基础</h2><p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png"></p>
<p>String类：不可修改，底层用final修饰，不可变</p>
<p>StringBuilder：可以修改，没有用final修饰，线程不安全，效率高</p>
<p>StringBuffer：可以修改，没有用final修饰，线程安全，效率低</p>
<h3 id="时间类的使用："><a href="#时间类的使用：" class="headerlink" title="时间类的使用："></a>时间类的使用：</h3><p>LocalData类：</p>
<p>​	这种时间的表示是我们熟悉的日历表示法，与用来表示时间点的Data类不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalData newYearsEve = LocalData.of(1999,12,31)</span><br><span class="line"></span><br><span class="line">int year = newYearsEve.getYear();</span><br><span class="line">int month = newYearsEve.getMonthValue();</span><br><span class="line">int day = newYearsEve.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">LocalData aThousandDayLater = newYearsEve.plusDays(1000)</span><br></pre></td></tr></table></figure>

<h3 id="变量和方法："><a href="#变量和方法：" class="headerlink" title="变量和方法："></a>变量和方法：</h3><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量，从本质上讲，变量就是内存中的一小块区域</p>
<h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量：方法的外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量</p>
<p>成员变量和局部变量的区别：</p>
<p>成员变量：针对整个类有效</p>
<p>局部变量：只在某个范围内有效</p>
<p>存储位置：</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中</p>
<p>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中，当方法调用完后，或者语句结束后，就会自动释放。</p>
<p>生命周期：</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p>
<p>局部变量：当方法调用完，或者语句结束后，就会自动释放</p>
<p>初始值：</p>
<p>成员变量：有默认初始值</p>
<p>局部变量：没有默认初始值，使用前必须赋值</p>
<h4 id="静态变量和实例变量和普通变量"><a href="#静态变量和实例变量和普通变量" class="headerlink" title="静态变量和实例变量和普通变量"></a>静态变量和实例变量和普通变量</h4><p>静态变量：由于不属于任何实例对像，属于类，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间</p>
<p>实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就会有几份成员变量</p>
<p>静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</p>
<p>静态方法和实例方法的区别主要体现在两个方面：</p>
<p>1.在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。<br>2.静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>成员内部类、局部内部类、匿名内部类和静态内部类</p>
<h4 id="静态内部类：定义在类内部的静态类"><a href="#静态内部类：定义在类内部的静态类" class="headerlink" title="静态内部类：定义在类内部的静态类"></a>静态内部类：定义在类内部的静态类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private static int radius = 1;</span><br><span class="line"> </span><br><span class="line">    static class StaticInner &#123;</span><br><span class="line">        public void visit() &#123;</span><br><span class="line">            System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<p>静态内部类的创建方式：new 外部类。静态内部类（）</p>
<h4 id="成员内部类：定义在类内部，成员位置上的非静态类"><a href="#成员内部类：定义在类内部，成员位置上的非静态类" class="headerlink" title="成员内部类：定义在类内部，成员位置上的非静态类"></a>成员内部类：定义在类内部，成员位置上的非静态类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private static  int radius = 1;</span><br><span class="line">    private int count =2;</span><br><span class="line">    </span><br><span class="line">     class Inner &#123;</span><br><span class="line">        public void visit() &#123;</span><br><span class="line">            System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">            System.out.println(&quot;visit outer   variable:&quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new Outer();</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<p>可以访问外部类的所有变量和方法，包括静态和非静态，创建方式new 内部类（）</p>
<h4 id="局部内部类：定义在方法中的内部类"><a href="#局部内部类：定义在方法中的内部类" class="headerlink" title="局部内部类：定义在方法中的内部类"></a>局部内部类：定义在方法中的内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private  int out_a = 1;</span><br><span class="line">    private static int STATIC_b = 2;</span><br><span class="line"> </span><br><span class="line">    public void testFunctionClass()&#123;</span><br><span class="line">        int inner_c =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void fun()&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void testStaticFunctionClass()&#123;</span><br><span class="line">        int d =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void fun()&#123;</span><br><span class="line">                // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void testStaticFunctionClass()&#123;</span><br><span class="line">   class Inner &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   Inner  inner = new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类-就是没有名字的内部类，日常开发中使用的比较多"><a href="#匿名内部类-就是没有名字的内部类，日常开发中使用的比较多" class="headerlink" title="匿名内部类:就是没有名字的内部类，日常开发中使用的比较多"></a>匿名内部类:就是没有名字的内部类，日常开发中使用的比较多</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private void test(final int i) &#123;</span><br><span class="line">        new Service() &#123;</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line"> interface Service&#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类/接口&#123; </span><br><span class="line">  //匿名内部类实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流："><a href="#IO流：" class="headerlink" title="IO流："></a>IO流：</h3><p>按照流的流向分，可以分为输入流和输出流</p>
<p>按照操作单元划分，可以划分为字节流和字符流</p>
<p>按照流的角色划分，可以划分为节点流和处理流</p>
<p>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<h4 id="BIO-NIO-AIO有什么区别："><a href="#BIO-NIO-AIO有什么区别：" class="headerlink" title="BIO,NIO,AIO有什么区别："></a>BIO,NIO,AIO有什么区别：</h4><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h4 id="需要掌握的16种："><a href="#需要掌握的16种：" class="headerlink" title="需要掌握的16种："></a>需要掌握的16种：</h4><h5 id="文件专属："><a href="#文件专属：" class="headerlink" title="文件专属："></a>文件专属：</h5><p>​	java.io.FileInputSteam</p>
<p>​	java.io.FileOutputSteam</p>
<p>​	java.io.FileReader</p>
<pre><code> java.io.FileWriter
</code></pre>
<h5 id="转换流："><a href="#转换流：" class="headerlink" title="转换流："></a>转换流：</h5><p>​	java.io.InputStreamReader</p>
<p>​	java.io.OutputStreamWriter</p>
<h5 id="缓冲流专属："><a href="#缓冲流专属：" class="headerlink" title="缓冲流专属："></a>缓冲流专属：</h5><p>​	java.io.BufferedReader</p>
<p>​	java.io.BufferedWriter</p>
<p>​	java.io.BufferedInputSteam</p>
<p>​	java.io.BufferedOutputSteam</p>
<h5 id="数据流专属："><a href="#数据流专属：" class="headerlink" title="数据流专属："></a>数据流专属：</h5><p>​	java.io.PrintWriter</p>
<p>​	java.io.PrintStream</p>
<h5 id="对象流专属："><a href="#对象流专属：" class="headerlink" title="对象流专属："></a>对象流专属：</h5><p>​	java.io.ObjectInputStream</p>
<p>​	java.io.ObjectOutputStream</p>
<h4 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h4><p>Serialize: java对象存储到文件中</p>
<p>DeSerialize: 将硬盘上的数据重新恢复到内存当中，恢复成java对象</p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h4><p>应用层的任务是通过应用进程间的交互来完成特定网络应用，应用层协议定义的应用进程间的通信和交互的规则。</p>
<p>运输层的主要任务是负责两台主机进程之间的通信提供通用的数据传输服务，运输层主要使用以下两种协议：</p>
<p>TCP-传输控制协议：面向连接的可靠的数据传输服务。</p>
<p>UDP-用户数据协议：提供无连接，尽最大努力的数据传输服务</p>
<p>TCP上运行的协议：</p>
<p>HTTP, HTTPS,FTP,POP3,SMTP,TELNET,SSH</p>
<p>UDP上运行的协议：</p>
<p>BOOTP, NTP,DHCP</p>
<p>注意：DNS域名服务，用于完成地址查找，邮件转发等工作，在TCP和UDP上都有运行</p>
<h3 id="集合容器"><a href="#集合容器" class="headerlink" title="集合容器"></a>集合容器</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>用于存储数据的容器</p>
<p>集合的特点：</p>
<p>对象封装数据，对象多了也需要存储，集合用于存储对象</p>
<p>对象的个数确定可以使用数组，对象的个数不确定的可以用集合，集合是可变长度的</p>
<p>常用的集合类型：</p>
<p>Map接口和Collection接口是所有集合框架的父接口：</p>
<p>1.Collection接口的子接口：Set接口和List接口</p>
<p>2.Map接口的实现类主要有：HashMap,TreeMap,Hashtable,ConcurrentHashMap,Properties</p>
<p>3.Set接口的实现类主要是：HashSet,TreeSet,LinkedHashSet</p>
<p>4.List接口的实现类主要是：ArrayList,LinkedList,Stack,Vector</p>
<p>List:一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector</p>
<p>Set:一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet</p>
<p>Map:一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象</p>
<p>哪些集合类是线程安全</p>
<p>vector：比arraylist多了个同步机制，因此线程安全，但效率比较低，不建议使用。</p>
<p>stack：堆栈类，先进后出</p>
<p>hashtable：比hashmap多了个线程安全</p>
<p>enumeration：枚举，相当于迭代器</p>
<h4 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h4><h5 id="1-List接口："><a href="#1-List接口：" class="headerlink" title="1.List接口："></a>1.List接口：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line">while(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">   *// do something*</span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList和LinkedList的区别：</p>
<p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。<br>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>总结：</p>
<p>读取较多时用ArrayList，插入和删除较多时使用LinkedList</p>
<h5 id="2-Set接口"><a href="#2-Set接口" class="headerlink" title="2.Set接口"></a>2.Set接口</h5><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值</p>
<h5 id="3-Queue接口"><a href="#3-Queue接口" class="headerlink" title="3.Queue接口"></a>3.Queue接口</h5><h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>主要了解HashMap</p>
<h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><p>单核CPU，执行多线程并发其实是分时抢占。</p>
<p>实现线程：</p>
<h4 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a>java.lang.Thread</h4><p>编写一个类，集成该接口，重写run方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		//写子线程运行的程序</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>！！！myThread.start() —-启动一个分支线程，再JVM中开辟一个新栈的空间和myThread.run() — 实际是单线程，不会启动线程，不会分配新的栈</p>
<h4 id="java-lang-Runable"><a href="#java-lang-Runable" class="headerlink" title="java.lang.Runable"></a>java.lang.Runable</h4><p>编写一个类，实现Runable接口，实现run方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunable implements Runable&#123;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = new Thread(new MyRunable)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<h4 id="java-util-concurrent-Callable"><a href="#java-util-concurrent-Callable" class="headerlink" title="java.util.concurrent.Callable:"></a>java.util.concurrent.Callable:</h4><p>可以获取子线程的返回结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//第一步：创建一个未来任务类</span><br><span class="line">FutureTask task = new FutureTask(new Callable()&#123;</span><br><span class="line">	public Object call() throws Exception&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//创建线程对象</span><br><span class="line">Thread t = new Thread(task);</span><br><span class="line"></span><br><span class="line">//启动线程</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">//获取t线程的返回结果</span><br><span class="line">Object obj = task.get();</span><br></pre></td></tr></table></figure>



<h4 id="线程安全："><a href="#线程安全：" class="headerlink" title="线程安全："></a>线程安全：</h4><p>同步代码块synchronized</p>
<p>在实例方法上，一定锁的是this，一般不常用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//线程同步代码块，必须是多线程共享的数据才能达到多线程排队</span><br><span class="line">//sychroized()括号中填共享的对象</span><br><span class="line">sychronized()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>！！！synchronized 在静态方法是类锁，类锁就只有一个 （排它锁）</p>
<h4 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLock&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Object o1 = new Object();</span><br><span class="line">		Object o1 = new Object();</span><br><span class="line">		Thread t1 = new MyThread1();</span><br><span class="line">		Thread t2 = new MyThread2();</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread1 extends Thread&#123;</span><br><span class="line">	Object 01;</span><br><span class="line">	Object o2;</span><br><span class="line">	public MyThread1(Object o1,Object o2)&#123;</span><br><span class="line">		this.o1 = o1;</span><br><span class="line">		this.o2 = o2;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		synchronized(o1)&#123;</span><br><span class="line">			sychronized(o2)&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread2 extends Thread&#123;</span><br><span class="line">	Object 01;</span><br><span class="line">	Object o2;</span><br><span class="line">	public MyThread1(Object o1,Object o2)&#123;</span><br><span class="line">		this.o1 = o1;</span><br><span class="line">		this.o2 = o2;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">        synchronized(o2)&#123;</span><br><span class="line">                sychronized(o1)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="守护线程："><a href="#守护线程：" class="headerlink" title="守护线程："></a>守护线程：</h4><p>又叫后台线程，一般守护线程是一个死循环，所有用户线程只要结束，守护线程自动结束</p>
<h4 id="生产者和消费者模式："><a href="#生产者和消费者模式：" class="headerlink" title="生产者和消费者模式："></a>生产者和消费者模式：</h4><h3 id="反射机制："><a href="#反射机制：" class="headerlink" title="反射机制："></a>反射机制：</h3><p>通过反射机制可以操作字节码文件。</p>
<p>java.lang.reflect.*包下</p>
<p>java.lang.Class: 代表整个字节码</p>
<p>java.lang.reflect.Method: 代表字节码中的方法字节码</p>
<p>java.lang.reflect.Constructor: 代表字节码中的构造方法</p>
<p>java.lang.reflect.Field: 代表字节码中属性的字节码</p>
<h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><p>Java中的锁分为显示锁和隐式锁。隐式锁由synchronized关键字实现，而显示锁是由实现了Lock接口和AQS框架等来实现。</p>
<h4 id="sychronized关键字："><a href="#sychronized关键字：" class="headerlink" title="sychronized关键字："></a>sychronized关键字：</h4><p>sychronized关键字的实现依赖于Java的对象头。</p>
<p>一个对象由三部分组成：对象头，实体数据，对齐填充。对象头的长度不是固定的，如果数据类型则对象头占12个字节，非数据类型对象头占8字节。</p>
<h4 id="无锁："><a href="#无锁：" class="headerlink" title="无锁："></a>无锁：</h4><p>不锁住资源，多个线程中有一个能修改资源成功，其他线程会重试</p>
<h4 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h4><p>一段同步代码、共享资源一直被一个线程方法调用，那么该线程自动获取锁，降低获取锁代价</p>
<h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h4><p>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。自旋次数有限，也就是我们所说的自适应锁。</p>
<h4 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h4><p>互斥锁，涉及到CPU的介入，获取不到锁的线程，会被阻塞</p>
<h4 id="AQS-AbstractQueuedSynchronizer-："><a href="#AQS-AbstractQueuedSynchronizer-：" class="headerlink" title="AQS(AbstractQueuedSynchronizer)："></a>AQS(AbstractQueuedSynchronizer)：</h4><p>是一种自旋锁，能确保无饥饿性，提供先来先服务的公平性。</p>
<h5 id="自旋锁-CLH-："><a href="#自旋锁-CLH-：" class="headerlink" title="自旋锁(CLH)："></a>自旋锁(CLH)：</h5><p>与互斥锁类似，在任何时候，最多只能有一个保持者。</p>
<p>互斥锁在资源被占用，资源申请者只能进入睡眠状态。</p>
<p>自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否自旋锁的保持者已经释放了锁。</p>
<p>CLH是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
<p><strong>具体流程：</strong></p>
<p>CLH队列中的节点QNode中含有一个locked字段，该字段若为true表示该线程需要获取锁，且不释放锁，为false表示线程释放了锁。节点之间通过隐形的链表相连(节点间没有明显的next指针)，通过myPred所指向的节点的变化情况来影响myNode的行为。</p>
<p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\a50f4bfbfbedab646e3082f0736ba6ca79311e22.png"></p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>​	Java 面向对象编程三大特性：封装 继承 多态</p>
<h4 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h4><p>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>
<h4 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h4><p>提高代码的复用性</p>
<p>关于继承如下 3 点请记住：</p>
<ol>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h4><p>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p>
<p>多态的两种形式：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）</p>
<p>方法<strong>重载</strong>（overload）实现的是编译时的多态性（也称为前绑定），而方法<strong>重写</strong>（override）实现的是运行时的多态性（也称为后绑定）。</p>
<h2 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h2><p>哈希表：</p>
<p>集合——Collection 和 Map</p>
<p>Collection : List(可重复){ArrayList,LinkList}，Set(不可重复){HashSet,TreeSet}</p>
<p>Map: HashMap, TreeMap</p>
<h3 id="hashCode-介绍："><a href="#hashCode-介绍：" class="headerlink" title="hashCode()介绍："></a>hashCode()介绍：</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置</p>
<h3 id="最有效率计算乘法："><a href="#最有效率计算乘法：" class="headerlink" title="最有效率计算乘法："></a>最有效率计算乘法：</h3><p>2&lt;&lt;3(左移3位相当与乘以2的3次方，右移3位相当于除以2的3次方)</p>
<h3 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h3><p>java语言的方法调用只支持值传递。</p>
<p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h3 id="强制转型："><a href="#强制转型：" class="headerlink" title="强制转型："></a>强制转型：</h3><p>例如：float f &#x3D; (float)3.4</p>
<p>访问修饰符的使用情况：</p>
<p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png"></p>
<h3 id="和-的区别："><a href="#和-的区别：" class="headerlink" title="&amp;和&amp;&amp;的区别："></a>&amp;和&amp;&amp;的区别：</h3><p>&amp;&amp;是短路运算，左边的表达式的值是false,就不用看右边的表达式</p>
<h3 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h3><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</p>
<h3 id="this关键字的用法："><a href="#this关键字的用法：" class="headerlink" title="this关键字的用法："></a>this关键字的用法：</h3><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<p>1.直接引用，this相当于指向当前对象本身</p>
<p>2.形参与成员名字重名，用this区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, int age)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.引用本类的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="super关键字的用法："><a href="#super关键字的用法：" class="headerlink" title="super关键字的用法："></a>super关键字的用法：</h3><p>super可以理解为是指向自己父类对象的一个指针，而这个父类指的是离自己最近的一个父类。</p>
<p>1.直接引用</p>
<p>与this类似，可以super.xxx来引用父类的成员</p>
<p>2.子类的成员变量或方法与父类中的成员变量或方法同名时，用super区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    protected String name;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public Student(String name, String name1) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void getInfo()&#123;</span><br><span class="line">        System.out.println(this.name);      //Child</span><br><span class="line">        System.out.println(super.name);     //Father</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Student s1 = new Student(&quot;Father&quot;,&quot;Child&quot;);</span><br><span class="line">       s1.getInfo();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.引用父类构造函数：</p>
<ul>
<li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li>
<li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li>
</ul>
<h3 id="static存在的主要意义："><a href="#static存在的主要意义：" class="headerlink" title="static存在的主要意义："></a>static存在的主要意义：</h3><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</p>
<p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<ul>
<li>静态只能访问静态。</li>
<li>非静态既可以访问非静态的，也可以访问静态的。</li>
</ul>
<h3 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h3><ul>
<li><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
</li>
<li><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
</li>
<li><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
</li>
<li><p>跳出多重嵌套循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ok:</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);</span><br><span class="line">            if (j == 5) &#123;</span><br><span class="line">                break ok;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先级队列："><a href="#优先级队列：" class="headerlink" title="优先级队列："></a>优先级队列：</h3><p>队列遵循先进先出(First-In-First-Out)模型，但有时需要根据优先级处理队列中的对象。那么可使用Java PriorityQueue对象来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类、接口"><a href="#类、接口" class="headerlink" title="类、接口"></a>类、接口</h2><h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p>相同点：</p>
<p>接口和抽象类都不能实例化</p>
<p>都位于继承的顶端，用于被其他实现或继承</p>
<p>都包含抽象方法，其他子类都必须覆写这些抽象方法</p>
<p>不同点：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody></table>
<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>类和类之间叫做继承，类和接口之间叫做实现</p>
<p>非抽象类实现接口的话，必须将接口中所有的抽象方法全部实现</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h4><p>指向下一条jvm指令的执行地址</p>
<p>特点：</p>
<p>线程私有</p>
<p>不会溢出</p>
<h4 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>每个线程运行时所需要的内存，称为虚拟机栈</p>
<p>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</p>
<p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>
<p>问题：方法内的局部变量是否是线程安全？</p>
<p>​	如果方法内局部变量没有逃离方法的作用范围，线程安全</p>
<p>​	如果方法内局部变量逃离了方法的作用范围，线程不安全</p>
<h5 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h5><p>递归没有设置终止条件</p>
<p>类的互相调用</p>
<h5 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h5><p>案例1：cpu占用过多</p>
<p>​	用top定位哪个进程对cpu占用过高</p>
<p>​	ps命令查看指定进程</p>
<p>​	jstack进程id找到有问题的进程</p>
<p>案例2：死锁</p>
<p>​	用jstack查找</p>
<h4 id="3本地方法栈"><a href="#3本地方法栈" class="headerlink" title="3本地方法栈"></a>3本地方法栈</h4><p>native 关键字标识的方法</p>
<h4 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h4><p>通过new关键字，创建对象都会使用堆内存</p>
<p>特点</p>
<p>它是线程共享，堆中对象需要考虑线程安全问题</p>
<p>垃圾回收机制会回收堆内的对象</p>
<h5 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h5><p>报错：java.lang.OutOfMemoryError:Java heap sapce</p>
<p>堆内存诊断</p>
<p>1.jps工具</p>
<p>​	查看当前系统中有哪些java进程</p>
<p>2.jmap工具</p>
<p>​	查看堆内存占用请款</p>
<p>3.jconsole工具</p>
<p>​	图形界面的，多功能的监测工具，可以连续监测</p>
<h4 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h4><p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\image-20220802220651850.png" alt="image-20220802220651850"></p>
<h5 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h5><p>1.8–java.lang.OutOfMemoryError:Metaspace</p>
<p>1.8以前–java.lang.OutOfMemoryError:PermGen space</p>
<h5 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h5><p>常量池就是一张表，虚拟机指令根据这张常量找到要执行的类名，方法名，参数类型，字面量等信息</p>
<p>运行时常量池，常量池是字节码文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p>
<h6 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h6><p>1.判断字符串是否相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &#x27;a&#x27;;</span><br><span class="line">String s2 = &#x27;b&#x27;;</span><br><span class="line">String s3 = &#x27;ab&#x27;;</span><br><span class="line">String s4 = s1+s2;</span><br><span class="line">String s5 = &#x27;a&#x27;+&#x27;b&#x27;;</span><br></pre></td></tr></table></figure>

<p>请问s3和s4相等吗？s3和s5呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3==s4 ; 错，s4是new出来的，在堆中，s3是在StringTable中</span><br><span class="line">s3==s5 ; 对，s3和s5都是在StringTable中</span><br></pre></td></tr></table></figure>

<h6 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调整 -XX:StringTableSize=桶的个数</span><br></pre></td></tr></table></figure>

<p>字符串入池</p>
<h4 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h4><p>常见于NIO操作时，用于数据缓冲区</p>
<p>分配回收成本较高，但读写性能高</p>
<p>不受JVM内存回收管理</p>
<p>底层使用了Unsafe对象完成直接内存的分配回收</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h4><p>1.1引用计数法</p>
<p>1.2可达性分析算法</p>
<p>扫描堆中的对象，看是否有root</p>
<p>1.3四种引用</p>
<p>强引用，软引用， 弱引用， 虚引用， 终结器引用</p>
<h4 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h4><p>（1）标记清除算法</p>
<p>（2）标记整理算法</p>
<p>（3）复制</p>
<h4 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3.分代垃圾回收机制"></a>3.分代垃圾回收机制</h4><p>MinorGC 处理新生代</p>
<p>FullGC 处理老年代和新生代</p>
<p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\image-20220804143839334.png" alt="image-20220804143839334"></p>
<h4 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h4><p>4.1串行</p>
<p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\image-20220804145417380.png" alt="image-20220804145417380"></p>
<p>4.2吞吐量</p>
<p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\image-20220804145458929.png" alt="image-20220804145458929"></p>
<p>4.3响应时间优先</p>
<p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\image-20220804150033003.png" alt="image-20220804150033003"></p>
<p>4.4 G1</p>
<p>适用场景：</p>
<p>同时注重吞吐量和低延迟，默认的暂停目标是200ms</p>
<p>超大堆内存，会将堆划分为多个大小相等的Region</p>
<p>整体上是标记+整理算法，两个区域之间是复制算法</p>
<p>相关JVM参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX：+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line">-XX:ManGCPauseMillis=time</span><br></pre></td></tr></table></figure>

<h3 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h3><p>javap工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v HelloWorld.class</span><br></pre></td></tr></table></figure>





<h2 id="Java并发-1"><a href="#Java并发-1" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="案例1：多线程提升效率"><a href="#案例1：多线程提升效率" class="headerlink" title="案例1：多线程提升效率"></a>案例1：多线程提升效率</h3><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><p>基准测试工具选择，使用了比较靠谱的JMH，他会执行程序预热，执行多次测试并平均</p>
<p>cpu核数限制，有两种思路</p>
<p>​	1.使用虚拟机，分配合适的核</p>
<p>​	2.使用msconfig，分配合适的核，需要重启比较麻烦</p>
<p>并行计算方式的选择</p>
<p>​	1.最初想直接使用parallel stream ，后来发现它自己有问题</p>
<p>​	2.改为了自己手动控制thread，实现简单的并行计算</p>
<h3 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h3><h4 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h4><p>1.直接使用Thread</p>
<p>2.使用Runable接口</p>
<p>Java8后可以使用lambda表达式精简</p>
<p>3.使用FutureTask 配合Thread</p>
<p>FutureTask能够接收Callable类型的参数，用来处理有返回结果的情况</p>
<h4 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h4><p>windows：</p>
<p>任务管理器可以产看进程和线程数</p>
<p>tasklist 查看进程</p>
<p>taskkill 杀死进程</p>
<p>linux：</p>
<p>ps -fe 查看进程</p>
<p>kill 杀死进程</p>
<p>Java：</p>
<p>jps 命令查看所有的Java进程</p>
<p>jstack <PID> 查看某个Java进程的所有线程状态</PID></p>
<p>jconsole 来查看某个Java进程中线程的运行情况</p>
<h4 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h4><p>压栈</p>
<h4 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h4><h5 id="run和start"><a href="#run和start" class="headerlink" title="run和start"></a>run和start</h5><p>start才会启动新的线程，run并不会</p>
<h5 id="sleep和yield"><a href="#sleep和yield" class="headerlink" title="sleep和yield"></a>sleep和yield</h5><p>调用sleep会让线程从运行状态到TIMED_WATIING</p>
<p>其他线程可以使用interrupt打断正在睡眠的线程</p>
<p>调用yield会让当前线程从Running进入到Runable状态，然后调度执行其他线程</p>
<p>具体实现依赖于操作系统的任务调度器</p>
<h5 id="join方法详解"><a href="#join方法详解" class="headerlink" title="join方法详解"></a>join方法详解</h5><p>在start方法之后使用，可以确保线程运行完</p>
<h5 id="interrupt方法详解"><a href="#interrupt方法详解" class="headerlink" title="interrupt方法详解"></a>interrupt方法详解</h5><p>打断sleep，wait，join的线程</p>
<h5 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h5><p>在一个线程T1中终止线程T2</p>
<p>错误思路：</p>
<p>使用线程对象的stop（）方法停止线程，注意stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就没有机会释放锁，其他线程将永远无法获取锁</p>
<p>使用System.exit（int ）方法停止线程，目的仅是停止一个线程，但这种做法会让整个程序都停止</p>
<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>线程优先级会提示调度器优先调度改线程，但仅仅是一个提示，调度器可以忽略</p>
<h4 id="主线程和守护线程"><a href="#主线程和守护线程" class="headerlink" title="主线程和守护线程"></a>主线程和守护线程</h4><p>垃圾回收器线程就是一种守护线程</p>
<p>Tomvat中Acceptor和Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待它们处理完当前请求</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>五种状态：初始状态，可运行状态（已经被创建），运行状态，阻塞状态（调用了阻塞API），终止状态</p>
<p>Java中六种状态：NEW,RUNNABLE,BLOKED,WAITING,TIMED_WAITING,TERMINATED</p>
<h3 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h3><h3 id="案例2-防止CPU占100"><a href="#案例2-防止CPU占100" class="headerlink" title="案例2-防止CPU占100%"></a>案例2-防止CPU占100%</h3><p>sleep实现</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>左子树&lt;根&lt;右子树</p>
<h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h4><p>每个左右子树的高度差不超过1</p>
<p>平衡因子BF，若BF&gt;1,平衡二叉树就失衡，需要旋转</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>一种自平衡二叉搜索树</p>
<p>查找、插入和删除操作，时间复杂度都是logN</p>
<h1 id="JDBC学习"><a href="#JDBC学习" class="headerlink" title="JDBC学习"></a>JDBC学习</h1><p>java语言操作关系型数据库的一套API</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>0.创建工程，导入jar包</p>
<p>1.注册驱动—-Class.forName(“com.mysql.jdbc.Driver”)</p>
<p>2.获取连接—-Connection conn &#x3D; DriverManager.getConnection(url,username,password)</p>
<p>3.定义SQL语句—-String sql &#x3D; “updata …”</p>
<p>4.获取执行SQL对象—Statement stmt &#x3D; conn.createStatament();</p>
<p>5.执行SQL—-stmt.executeUpdate(sql);</p>
<p>6.处理结果返回</p>
<p>7.释放资源</p>
<h2 id="api详解："><a href="#api详解：" class="headerlink" title="api详解："></a>api详解：</h2><h3 id="Connection对象："><a href="#Connection对象：" class="headerlink" title="Connection对象："></a>Connection对象：</h3><p>获取sql对象：</p>
<p>事务管理功能：</p>
<p>开启事务—setAutoCommit(true or false)  &#x2F;&#x2F;true–auto </p>
<p>提交事务—commit()</p>
<p>回滚事务—rollback()</p>
<h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象:"></a>Statement对象:</h3><p>1.执行SQL语句</p>
<p>​	int executeUpdate(sql)—执行DML,DDL语句</p>
<p>​	DML返回影响的行数，DDL执行成功后可能返回0</p>
<p>​	ResultSet executeQuery(sql)—执行DQL语句</p>
<pre><code> 返回值：ResultSet结果集对象
</code></pre>
<h3 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h3><p>1.封装了DQL查询语句的结果：</p>
<p>​	ResultSet  stmt.executeQuery(sql)—-执行DQL语句，返回ResultSet对象</p>
<h3 id="PreparedStatement对象："><a href="#PreparedStatement对象：" class="headerlink" title="PreparedStatement对象："></a>PreparedStatement对象：</h3><p>1.预编译SQL语句并执行，预防SQL注入问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义sql时用？作为占位符</span><br><span class="line">String sql = &quot;select * from tb_user where username = ? and password = ?&quot;</span><br><span class="line">PreparedStatement pstmt = conn.preparedStatement(sql);</span><br><span class="line"></span><br><span class="line">pstmt.setString(1,name);</span><br><span class="line">pstmt.setString(2,pwd);</span><br><span class="line"></span><br><span class="line">ResultSet rs = pstmt.excuteQuery();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Maven："><a href="#Maven：" class="headerlink" title="Maven："></a>Maven：</h1><p>Maven安装配置：</p>
<p>1.解压apache-maven-3.6.1.rar 既安装完成</p>
<p>2.配置环境变量 MAVEN_HOME 为安装路径的bin目录</p>
<p>3.配置本地仓库：修改 conf&#x2F;settings.xml 中的 <localRepository> 为一个指定目录</localRepository></p>
<p>4.配置阿里云私服： 修改conf&#x2F;settings.xml 中的 <mirrors> 标签，为其添加如下子标签</mirrors></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h2><p>complie —    clean—-   package—-</p>
<h2 id="IDEA配置MAVEN："><a href="#IDEA配置MAVEN：" class="headerlink" title="IDEA配置MAVEN："></a>IDEA配置MAVEN：</h2><p>1.选择IDEA中File—&gt;settings</p>
<p>2.搜索maven</p>
<p>3.设置IDEA使用本地安装的Maven，并修改配置文件路径</p>
<h2 id="Maven坐标详解："><a href="#Maven坐标详解：" class="headerlink" title="Maven坐标详解："></a>Maven坐标详解：</h2><p>Maven中坐标是资源的唯一标识</p>
<p>使用坐标来定义项目或引入项目中需要的依赖</p>
<p>坐标组成：</p>
<p>groupId —–&gt;定义当前Maven项目隶属组织名称</p>
<p>artifactId—–&gt;定义当前Maven项目名称（通常是模块名称，例如：order-service,goods-services）</p>
<p>version—–&gt;定义当前项目版本号</p>
<h2 id="依赖管理："><a href="#依赖管理：" class="headerlink" title="依赖管理："></a>依赖管理：</h2><p>使用坐标导入jar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入mysql 驱动jar包--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>！！！点击刷新按钮</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis:"></a>MyBatis:</h1><p>定义：是一款优秀的持久层框架，用于简化JDBC开发</p>
<h2 id="持久层："><a href="#持久层：" class="headerlink" title="持久层："></a>持久层：</h2><p>负责将数据保存到数据库的那一层代码</p>
<p>JavaEE三层架构：表现层，业务层，持久层</p>
<h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><p>1.创建user表，添加数据</p>
<p>2.创建模块，导入坐标</p>
<p>3.编写MyBatis核心配置文件—&gt;替换连接信息，解决连接信息  解决硬编码问题</p>
<p>4.编写SQL映射文件—&gt;统一管理sql语句，解决硬编码问题</p>
<p>5.编码</p>
<h2 id="Mapper代理开发："><a href="#Mapper代理开发：" class="headerlink" title="Mapper代理开发："></a>Mapper代理开发：</h2><p>1.定义SQL映射文件同名的Mapper接口，并且将Mapper接口各SQL映射文件放置在统一目录下</p>
<p>2.设置SQL映射文件的namespace属性为Mapper接口全限定名</p>
<p>3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</p>
<p>4.编码</p>
<p>​	1.通过 SqlSession 的 getMapper 方法获取 Mapper 接口的代理对象</p>
<p>​	2.调用对应方法完成sql的执行</p>
<h2 id="MyBatis核心配置："><a href="#MyBatis核心配置：" class="headerlink" title="MyBatis核心配置："></a>MyBatis核心配置：</h2><p>环境配置—&gt;可以配置多个环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://mybatis?useSSL=false&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br></pre></td></tr></table></figure>

<p>别名配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=&quot;com.qian.pojo&quot; /&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>那么在Resource-com.qian.mapper下的UserMapper.xml中resultType就可以不区分大小写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.qian.mapper.UserMapper&quot;&gt;</span><br><span class="line">	&lt;!-- &lt;select id=&quot;selectAll&quot; resultType=&quot;com.qian.pojo.User&quot;&gt; --&gt;</span><br><span class="line">    &lt;select id=&quot;selectAll&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from tb_user ;</span><br><span class="line">  	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>



<h2 id="配置文件完成增删改查："><a href="#配置文件完成增删改查：" class="headerlink" title="配置文件完成增删改查："></a>配置文件完成增删改查：</h2><h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>1.编写接口方法：Mapper接口</p>
<p>2.编写SQL语句：SQL映射文件：</p>
<p>3.执行方法，测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据</span><br></pre></td></tr></table></figure>

<p><img src="/2023/08/13/java%E5%AD%A6%E4%B9%A0/MyBlog\图片\image-20220617153339026.png" alt="image-20220617153339026"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据</span><br><span class="line"></span><br><span class="line">    1.解决方法：as 为实体类的属性名称</span><br><span class="line">        引用sql片段</span><br><span class="line">    2.使用resultMap</span><br><span class="line">    </span><br><span class="line">--&gt;</span><br><span class="line">&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;Brand&quot;&gt;</span><br><span class="line">    &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;sql id = &quot;brand_column&quot;&gt;id,brand_name as brandName,company_name as companyName,ordered,description,status&lt;/sql&gt;</span><br><span class="line">&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">    select * from tb_brand;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="详细查询："><a href="#详细查询：" class="headerlink" title="详细查询："></a>详细查询：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    参数占位符：</span><br><span class="line">    1.#&#123;&#125; 会将其替换为 ？ 防止 sql注入</span><br><span class="line">    2.$&#123;&#125;  拼sql，会存在SQL注入</span><br><span class="line">    特殊字符的处理：</span><br><span class="line">        1.转移字符：&lt; - &amp;lt</span><br><span class="line">        2.CDATA区  &lt;![CDATA[ &lt; ]]&gt;</span><br><span class="line">    </span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">    select * from tb_brand where id = #&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h5><p>多条件查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    条件查询</span><br><span class="line"> --&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">    select * from tb_brand</span><br><span class="line">    where status = #&#123;status&#125;</span><br><span class="line">      and company_name like #&#123;companyName&#125;</span><br><span class="line">      and brand_name like #&#123;brandName&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询;"></a>动态查询;</h5><p>SQL语句随着用户的输入或者外部条件的变化而变化，称为动态SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">        动态条件查询</span><br><span class="line">     --&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">        select * from tb_brand</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125; &lt;/if&gt;</span><br><span class="line">            and &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;company_name like #&#123;companyName&#125;&lt;/if&gt;</span><br><span class="line">            and &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;brand_name like #&#123;brandName&#125;&lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加："><a href="#添加：" class="headerlink" title="添加："></a>添加：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加--&gt;</span><br><span class="line">&lt;insert id=&quot;add&quot;&gt;</span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>主键返回</p>
<p>设置useGeneratedKeys&#x3D;”true” 和 keyProperty&#x3D;”id”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h3><h5 id="修改全部字段："><a href="#修改全部字段：" class="headerlink" title="修改全部字段："></a>修改全部字段：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--修改--&gt;</span><br><span class="line">&lt;update id=&quot;updata&quot;&gt;</span><br><span class="line">    update tb_brand set brand_name = #&#123;brandName&#125;,</span><br><span class="line">     company_name = #&#123;companyName&#125;,</span><br><span class="line">     ordered = #&#123;ordered&#125;,</span><br><span class="line">     description = #&#123;description&#125;,</span><br><span class="line">     status = #&#123;status&#125;</span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<h5 id="修改动态字段："><a href="#修改动态字段：" class="headerlink" title="修改动态字段："></a>修改动态字段：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--修改--&gt;</span><br><span class="line">&lt;update id=&quot;updata&quot;&gt;</span><br><span class="line">    update tb_brand &lt;set&gt;</span><br><span class="line">    &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;</span><br><span class="line">        brand_name = #&#123;brandName&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;</span><br><span class="line">        company_name = #&#123;companyName&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;ordered != null &quot;&gt;</span><br><span class="line">        ordered = #&#123;ordered&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;description != null and description != &#x27;&#x27; &quot;&gt;</span><br><span class="line">        description = #&#123;description&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;status != null &quot;&gt;</span><br><span class="line">        status = #&#123;status&#125;&lt;/if&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"></span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--删除--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteById&quot;&gt;</span><br><span class="line">    delete from tb_brand where id = #&#123;id&#125;;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p>批量删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis会将数组封装成一个Map集合</span><br><span class="line">    默认：array = 数组</span><br><span class="line">    使用@Param 注解改变map集合的默认key名称--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteByIds&quot;&gt;</span><br><span class="line">    delete from tb_brand where id in (</span><br><span class="line">    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot;  separator=&quot;,&quot;&gt;</span><br><span class="line">      #&#123;id&#125;</span><br><span class="line">    &lt;/foreach&gt;)</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<h1 id="HTML："><a href="#HTML：" class="headerlink" title="HTML："></a>HTML：</h1><p>（Hyper Text Markup Language）</p>
<p>推荐的学习网站：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></p>
<p>结构—-HTML</p>
<p>表现—-CSS</p>
<p>行为—-JavaScript</p>
<h2 id="基础标签："><a href="#基础标签：" class="headerlink" title="基础标签："></a>基础标签：</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><h1> ~ <h6></h6></h1></td>
<td>定义标题，h1最大，h6最小</td>
</tr>
<tr>
<td><font></font></td>
<td>定义文本的字体，字体尺寸，字体颜色</td>
</tr>
<tr>
<td><b></b></td>
<td>定义粗体文字</td>
</tr>
<tr>
<td><i></i></td>
<td>定义斜体文字</td>
</tr>
<tr>
<td><u></u></td>
<td>定义文本下划线</td>
</tr>
<tr>
<td><center></center></td>
<td>定义文本居中</td>
</tr>
<tr>
<td><p></p></td>
<td>定义段落</td>
</tr>
<tr>
<td><br></td>
<td>定义换行</td>
</tr>
<tr>
<td><hr></td>
<td>定义水平线</td>
</tr>
</tbody></table>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS:"></a>CSS:</h2><h3 id="CSS导入方式："><a href="#CSS导入方式：" class="headerlink" title="CSS导入方式："></a>CSS导入方式：</h3><p>1.内联样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;color:red&quot;&gt;Hello CSS&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>2.内部样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;dvi&#123;</span><br><span class="line">	dolor:red</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>3.外部样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript:"></a>JavaScript:</h2><h3 id="JavaScript引入方式"><a href="#JavaScript引入方式" class="headerlink" title="JavaScript引入方式"></a>JavaScript引入方式</h3><p>1.内部脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	alter(&quot;hello JS&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2.外部脚本：</p>
<p>将JS代码定义在外部JS文件中，然后引入到HTML页面中</p>
<p>外部文件：demo.js</p>
<p>引入外部文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;../js/demo.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="JavaScript基础语法："><a href="#JavaScript基础语法：" class="headerlink" title="JavaScript基础语法："></a>JavaScript基础语法：</h3><h4 id="书写语法："><a href="#书写语法：" class="headerlink" title="书写语法："></a>书写语法：</h4><p>1.区分大小写</p>
<p>2.每行分号可有可无</p>
<p>3.注释：同java一样</p>
<p>4.大括号表示代码块</p>
<h4 id="输出语句："><a href="#输出语句：" class="headerlink" title="输出语句："></a>输出语句：</h4><p>使用window.alert() —–写入警告框</p>
<p>使用document.write() —–写入HTML输出</p>
<p>使用console.log() ——写入浏览控制台</p>
<h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><p>JavaScript 中使用 var 关键字表示变量</p>
<p>作用域： 1.全局变量  2.可以重复定义</p>
<p>！！！数字不能开头</p>
<p>ECMAScript 中新增了 let 关键字定义变量，它的用法类似于 var ，声明的变量所在代码块有效，不能重复定义 </p>
<p>ECMAScript 中新增了 const 关键字定义常量，一旦声明就不能改变</p>
<h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p>原始类型和引用类型：</p>
<p>5种原始类型：</p>
<p>​	number：数字（整数，小数，NaN（Not a Number））</p>
<p>​	string：字符，字符串，单双引皆可</p>
<p>​	boolean：布尔，</p>
<p>​	null：空</p>
<p>​	undefined：当声明变量未初始化时，该变量的默认值时undefined</p>
<p>同样可以使用 typeof 获取变量类型</p>
<h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><p>一元运算符：++，–</p>
<p>算术运算符：+，-，*，&#x2F;，%</p>
<p>赋值运算符：&#x3D;，+&#x3D;，-&#x3D;</p>
<p>关系运算符：&gt; , &lt;, &gt;&#x3D;, &lt;&#x3D;, !&#x3D;, &#x3D;&#x3D;, &#x3D;&#x3D;&#x3D;(全等)</p>
<p>逻辑运算符：&amp;&amp;， ||， ！</p>
<p>三元运算符：条件表达式？trut_value:fasle_value</p>
<p>注意：&#x3D;&#x3D; 时会进行类型转化 ，&#x3D;&#x3D;&#x3D; 时不会类型转化</p>
<p>其他类型转number：</p>
<p>​	1.string ：按照字符串的字面值，转数字，如果字面值不是数字，转为NaN  —parseInt(）</p>
<p>​	2.boolean:true—1,false—-0</p>
<p>其他类型转boolean：</p>
<p>​	1.number：0和NaN—–false，其他数字—–true</p>
<p>​	2.string：空字符串—–false，其他字符串—-true</p>
<p>​	3.null: false</p>
<p>​	4.undefined: false</p>
<h4 id="流程控制语句："><a href="#流程控制语句：" class="headerlink" title="流程控制语句："></a>流程控制语句：</h4><p>​	if:</p>
<p>​	switch:</p>
<p>​	for:</p>
<p>​	while:</p>
<p>​	do while:</p>
<h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><p>形参不需要类型，返回值也不用返回类型</p>
<h3 id="Array对象："><a href="#Array对象：" class="headerlink" title="Array对象："></a>Array对象：</h3><p>长度和类型可以变化</p>
<h3 id="String对象："><a href="#String对象：" class="headerlink" title="String对象："></a>String对象：</h3><p>length—-是属性，不是方法</p>
<h3 id="自定义对象："><a href="#自定义对象：" class="headerlink" title="自定义对象："></a>自定义对象：</h3><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var 对象名称&#123;</span><br><span class="line">	属性名称1：属性值1；</span><br><span class="line">	属性名称2：属性值2；</span><br><span class="line">	...</span><br><span class="line">	函数名称：function(形参列表)&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BOM对象：（浏览器对象模型）"><a href="#BOM对象：（浏览器对象模型）" class="headerlink" title="BOM对象：（浏览器对象模型）"></a>BOM对象：（浏览器对象模型）</h2><h4 id="window-浏览器窗口对象"><a href="#window-浏览器窗口对象" class="headerlink" title="window:浏览器窗口对象"></a>window:浏览器窗口对象</h4><p>获取：直接使用window,其中window.可以省略</p>
<p>属性：获取其他DOM对象</p>
<p>history: —–&gt; 对History对象的只读引用。</p>
<p>Navigator:—–&gt;对Navigator对象的只读引用。</p>
<p>Screen:——&gt;对Screen对象的只读引用。</p>
<p>location:——-&gt;用于窗口或框架的Location对象。</p>
<p>方法：</p>
<p>alert():——&gt;显示带有一段消息和一个确认按钮的警告框。</p>
<p>confirm():——&gt;显示带有一段消息以及确认按钮和取消按钮的对话框。</p>
<p>setInterval():—–&gt;按照指定的周期来调用函数或者计算表达式。</p>
<p>setTimeout():—–&gt;在指定的毫秒数后调用函数或计算表达式。</p>
<h4 id="History"><a href="#History" class="headerlink" title="History:"></a>History:</h4><p>历史记录</p>
<p>获取：使用window.history获取，其中window.可以省略</p>
<p>方法：</p>
<p>back() :—–&gt;加载history列表中的前一个URL</p>
<p>forward() :——&gt;加载history列表中的下一个URL</p>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location:"></a>Location:</h4><p>获取：使用window.history获取，其中window.可以省略</p>
<p>属性：href </p>
<h2 id="DOM对象：-文档对象模型"><a href="#DOM对象：-文档对象模型" class="headerlink" title="DOM对象：(文档对象模型)"></a>DOM对象：(文档对象模型)</h2><h4 id="Document："><a href="#Document：" class="headerlink" title="Document："></a>Document：</h4><p>整个文档对象</p>
<h4 id="Element："><a href="#Element：" class="headerlink" title="Element："></a>Element：</h4><p>元素对象</p>
<p>获取：使用Document对象的方法来获取</p>
<p>​	1.getElementById:根据id属性获取，返回一个Element对象</p>
<p>​	2.getElementByTagName:根据标签名获取，返回Element对象数组</p>
<p>​	3.getElementByName:根据name属性值获取，返回Element对象数组</p>
<p>​	4.getElementByClassName:根据class属性值获取，返回Element对象数组</p>
<h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute:"></a>Attribute:</h4><p>属性对象</p>
<h4 id="Text"><a href="#Text" class="headerlink" title="Text:"></a>Text:</h4><p>文本对象</p>
<h4 id="Comment："><a href="#Comment：" class="headerlink" title="Comment："></a>Comment：</h4><p>注释对象</p>
<h3 id="事件监听："><a href="#事件监听：" class="headerlink" title="事件监听："></a>事件监听：</h3><p>事件绑定</p>
<p>方式一：通过HTML标签中的事件属性进行绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;buttom&quot; onclick=&#x27;on()&#x27;&gt;</span><br><span class="line"></span><br><span class="line">function on()&#123;</span><br><span class="line">	alert(&quot;someone click the button&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：通过DOM元素属性绑定 (推荐使用这种方式)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; id = &quot;btn&quot;&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btn&quot;).onclick = function()&#123;</span><br><span class="line">	alert(&quot;someone click the button&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见事件</p>
<h2 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>​	1.直接量：注意不要加引号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^\w&#123;6,12&#125;$/;</span><br></pre></td></tr></table></figure>

<p>​	2.创建RegExp对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&quot;^\\w&#123;6,12&#125;$&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>开始——– ^      结束———– $</p>
<p>[] ：——- 代表某个范围内的单个字符，比如：[0-9] 单个数字字符</p>
<p>. : ——— 代表任意单个字符，除了换行和行结束符</p>
<p>\w ：——– 代表单词字符：字母、数字、下划线(<em>)，相当于 [A-Za-z0-9</em>]</p>
<p>\d :代表数字字符：相当于[0-9]</p>
<p>量词</p>
<p>+：至少一个</p>
<p>*：零个或多个</p>
<p>？：零个或一个</p>
<p>{x}：x个</p>
<p>{m,}：至少m个</p>
<p>{m,n}：至少m个,最多n个</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>​	test(reg)</p>
<h1 id="Web核心："><a href="#Web核心：" class="headerlink" title="Web核心："></a>Web核心：</h1><h2 id="JavaWeb技术栈："><a href="#JavaWeb技术栈：" class="headerlink" title="JavaWeb技术栈："></a>JavaWeb技术栈：</h2><p>​	B&#x2F;S架构：Browser和Server，浏览器&#x2F;服务器架构模式</p>
<p>​		好处：容易维护升级，服务器端升级后，客户端无需任何部署就可以使用到新版本</p>
<p>​	静态资源：HTML，CSS，JavaScript，图片等，负责页面展示</p>
<p>​	动态资源：Sevlet，JSP等，负责逻辑处理</p>
<p>​	数据库：负责存储数据</p>
<p>​	HTTP协议：定义通信规则</p>
<p>​	Web服务器：负责解析HTTP协议，解析请求数据，并发送数据</p>
<h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><p>超文本传输协议，规定了浏览器和服务器之间数据传输的规则</p>
<h3 id="HTTP请求数据格式"><a href="#HTTP请求数据格式" class="headerlink" title="HTTP请求数据格式"></a>HTTP请求数据格式</h3><p>​	1.请求行：请求数据的第一行，其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本</p>
<p>​	2.请求头：第二行开始，格式为key:value形式</p>
<p>​	3.请求体：POST请求的最后一部分，存放请求参数</p>
<p>GET请求和POST请求：</p>
<p>​	1.GET请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</p>
<p>​	2.GET请求参数大小有限制，POST没有</p>
<h3 id="HTTP响应数据格式"><a href="#HTTP响应数据格式" class="headerlink" title="HTTP响应数据格式"></a>HTTP响应数据格式</h3><p>​	1.响应行：响应数据的第一行，其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述</p>
<p>​	2.响应头：第二行开始，格式为key:value</p>
<p>​	3.响应体：最后一部分，存放响应数据</p>
<h3 id="响应状态码："><a href="#响应状态码：" class="headerlink" title="响应状态码："></a>响应状态码：</h3><table>
<thead>
<tr>
<th>状态码分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>响应中–临时状态码，表示请求已经接受，告诉客户端应该继续请求或者已经完成则忽略</td>
</tr>
<tr>
<td>2xx</td>
<td>成功–表示请求已经被成功接收，处理完成</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向—重定向到其他地方：它让客户端再发起一个请求以完成整个处理</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误—处理发生错误，责任再客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器端错误—处理发生错误，责任再服务端，如服务端抛出异常，路由出错，HTTP版本不对等</td>
</tr>
</tbody></table>
<p>状态码大全：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a></p>
<h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>Tomcat</p>
<h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><p>官网：<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></p>
<h4 id="Tomcat–基本使用"><a href="#Tomcat–基本使用" class="headerlink" title="Tomcat–基本使用"></a>Tomcat–基本使用</h4><p>​	1.配置</p>
<p>​		1.修改启动端口号：conf&#x2F;server.xml</p>
<p>​		注意：HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，不用输入端口号</p>
<p>​	2.启动可能出现的问题</p>
<p>​		1.端口号冲突：找到对应程序，将其关闭掉</p>
<p>​		2.启动窗口一闪而过，检查JAVA_HOME环境变量是否配置正确</p>
<h4 id="项目部署："><a href="#项目部署：" class="headerlink" title="项目部署："></a>项目部署：</h4><h3 id="IDEA中创建Maven-Web项目"><a href="#IDEA中创建Maven-Web项目" class="headerlink" title="IDEA中创建Maven Web项目"></a>IDEA中创建Maven Web项目</h3><p>​	使用骨架：选择 create from apachetype</p>
<p>​	不使用骨架：不选择 create from apachetype</p>
<p>集成本地Tomcat：</p>
<p>使用Tomcat Maven插件：</p>
<p>在<plugins>中写下面代码，注意使用骨架时不能自动导包，把<pluginManagement>注释</pluginManagement></plugins></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><p>​	Java中提供的一门动态web资源开发技术</p>
<p>​	是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p>
<h3 id="快速入门：-1"><a href="#快速入门：-1" class="headerlink" title="快速入门："></a>快速入门：</h3><p>​	1.创建web项目，导入Servlet依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">	&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.创建：定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ServletDemo1 implements&#123;</span><br><span class="line">	public void service()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	3.配置：在类上使用@WebServlet 注解，配置该Servlet的访问路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/demo1&quot;)</span><br><span class="line">public class ServletDemo1 implements Servlet&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	4.访问：启动Tomcat，浏览器输入URL，访问Servlet</p>
<h3 id="Servlet执行流程："><a href="#Servlet执行流程：" class="headerlink" title="Servlet执行流程："></a>Servlet执行流程：</h3><p>​	1.servlet由web服务器创建，servlet方法由web服务器调用</p>
<p>​	2.服务器怎么知道servlet中一定由servlet方法？</p>
<p>​	我们定义的servlet，必须实现servlet接口并复写其方法，而servlet接口中有servlet方法</p>
<h3 id="Servlet生命周期："><a href="#Servlet生命周期：" class="headerlink" title="Servlet生命周期："></a>Servlet生命周期：</h3><p>​	对象被创建到被销毁的整个过程</p>
<p>​	1.加载和实列化：默认情况下，当Servlet第一次被访问时，由容器创建Servelt对象</p>
<p>​	2.初始化：在实列化后，容器将调用servlet的init（）方法初始化对象，完成一些如加载配置文件，创建连接等初始化的工作，该方法只调用一次</p>
<p>​	3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service（）方法对请求进行处理</p>
<p>​	4.终止服务：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。</p>
<h3 id="Servlet体系结构："><a href="#Servlet体系结构：" class="headerlink" title="Servlet体系结构："></a>Servlet体系结构：</h3><p>​	HttpServlet使用步骤：</p>
<p>​		1.继承HttpServlet</p>
<p>​		2.重写doGet和doPost方法</p>
<h3 id="Servlet-urlPattern配置："><a href="#Servlet-urlPattern配置：" class="headerlink" title="Servlet urlPattern配置："></a>Servlet urlPattern配置：</h3><p>​	urlPattern配置规则：</p>
<p>​		1.精确匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;/demo03&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>​		2.目录匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;/demo03/*&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>​		3.扩展名匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;*.do&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>​		4.任意匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;/&quot;&#125;)</span><br><span class="line">or</span><br><span class="line">@WebServlet(urlPatterns = &#123;&quot;/*&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Filter："><a href="#Filter：" class="headerlink" title="Filter："></a>Filter：</h2><p>过滤器可以把一些对资源的请求拦截，从而实现一些特殊功能</p>
<h3 id="快速入门：-2"><a href="#快速入门：-2" class="headerlink" title="快速入门："></a>快速入门：</h3><p>​	1.定义类，实现Filter接口，并重写方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class FilterDemo implemnets Filter&#123;</span><br><span class="line">	public void init(FilterConfig filterConfig);</span><br><span class="line">	public void doFilter(ServletRequest request,ServletResponse response);</span><br><span class="line">	public void destory()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	2.配置Filter拦截资源的路径，在类上定义@WebFilter注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(&quot;/*&quot;)</span><br><span class="line">public class FilterDemo implements Filter&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	3.在doFilter方法中输出一句话，并放行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest request,ServletResponse response)&#123;</span><br><span class="line">	print(&quot;you can pass&quot;);</span><br><span class="line">	chain.doFilter(request,response),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Request-Response："><a href="#Request-Response：" class="headerlink" title="Request &amp;Response："></a>Request &amp;Response：</h2><h3 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h3><p>继承体系：</p>
<p>​	ServletRequest &lt;——HttpServletRequest &lt;——-RequestFacade</p>
<p>​	java提供的请求对象接口—-java提供的对http协议封装的请求接口对象—–Tomcat定义的实现类</p>
<p>获取请求数据：</p>
<p>​	1.请求行：</p>
<p>​		String getMethod()：获取请求方式 </p>
<p>​		String getContextPath()：获取虚拟目录（项目访问路径）</p>
<p>​		StringBuffer getRequestURL()：获取URL（统一资源定位符）</p>
<p>​		String getRequestURI()：获取URI（统一资源标识符）</p>
<p>​		String getQueryString()：获取请求参数</p>
<p>​	2.请求头：</p>
<p>​		String getHeader(String name):根据请求头名称，获取值</p>
<p>​	3.请求体：</p>
<p>​		ServletInputStream getInputStream() :获取字节输入流</p>
<p>​		BufferedReader getReader() : 获取字符输入流</p>
<h3 id="Response："><a href="#Response：" class="headerlink" title="Response："></a>Response：</h3><p>转发和重定向</p>
<p>重定向：</p>
<p>​	找别人处理，状态码设置302，重定向的url </p>
<p>Response响应字符数据：</p>
<p>​	1.通过Response对象获取字符输出流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.获取字符输出流</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        resp.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);</span><br><span class="line">        writer.write(&quot;aaaa&quot;);</span><br><span class="line">        writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        //细节：流不需要关闭</span><br></pre></td></tr></table></figure>

<p>​	2.通过Response对象获取字节输出流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.读取文件</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(&quot;C:\\Users\\peanut\\Pictures\\test\\6.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        //2.获取字节输出流</span><br><span class="line">        ServletOutputStream outputStream = resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        //完成流的copy</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while((len = fileInputStream.read(bytes))!=-1)&#123;</span><br><span class="line">            outputStream.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fileInputStream.close();</span><br></pre></td></tr></table></figure>



<h2 id="JSP："><a href="#JSP：" class="headerlink" title="JSP："></a>JSP：</h2><p>全称Java Sever Pages ，java服务端页面</p>
<p>一种动态的网页技术，其中既可以定义HTML，JS，CSS等静态内容，还可以定义Java代码的动态内容</p>
<p>JSP&#x3D;HTML+Java</p>
<h2 id="MVC模式："><a href="#MVC模式：" class="headerlink" title="MVC模式："></a>MVC模式：</h2><p>​	Model：业务模式，处理业务</p>
<p>​	View：视图，展示页面</p>
<p>​	Controller：控制器，处理请求，调用模型和视图</p>
<h3 id="三层架构："><a href="#三层架构：" class="headerlink" title="三层架构："></a>三层架构：</h3><p>表现层：</p>
<p>​	接受请求，封装数据，调用业务逻辑层，响应数据</p>
<p>​	com.qian.web&#x2F;controller</p>
<p>业务逻辑层：</p>
<p>​	对业务逻辑进行封装，组合数据访问层的基本功能，形成复杂的业务逻辑功能</p>
<p>​	com.qian.service</p>
<p>数据访问层：</p>
<p>​	对数据库的CRUD基本操作</p>
<p>​	com.qian.mapper&#x2F;dao</p>
<h2 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h2><p>异步的JavaScript和XML</p>
<p>AJAX作用：</p>
<p>​	1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据</p>
<p>​	2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等。。。</p>
<h4 id="快速入门：-3"><a href="#快速入门：-3" class="headerlink" title="快速入门："></a>快速入门：</h4><p>​	1.编写AjaxServlet，并使用response输出字符串</p>
<p>​	2.创建XMLHttpRequest对象：用于和服务器交换数据</p>
<p>​	3.向服务器发送请求</p>
<p>​	4.获取服务器响应数据</p>
<h4 id="AXIOS异步框架："><a href="#AXIOS异步框架：" class="headerlink" title="AXIOS异步框架："></a>AXIOS异步框架：</h4><h5 id="快速入门：-4"><a href="#快速入门：-4" class="headerlink" title="快速入门："></a>快速入门：</h5><p>​	1.引入axios的js文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.使用axios发送请求，并获取响应结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	method:&quot;get&quot;,</span><br><span class="line">	url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span><br><span class="line">&#125;).then(function(resp)&#123;</span><br><span class="line">	alert(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	method:&quot;post&quot;,</span><br><span class="line">	url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;</span><br><span class="line">	data:&quot;username=zhangsan&quot;</span><br><span class="line">&#125;).then(function(resp)&#123;</span><br><span class="line">	alert(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h5><p>​	概念：JavaScript对象表示方式</p>
<p>​	由于结构简单，层次鲜明，现多用于作为数据载体，在网络中进行数据传输</p>
<p>JavaScript对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	name:&quot;zhangsan&quot;,</span><br><span class="line">	age:23,</span><br><span class="line">	city:&quot;北京&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:&quot;zhangsan&quot;,</span><br><span class="line">	&quot;age&quot;:23,</span><br><span class="line">	&quot;city&quot;:&quot;北京&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础语法：</p>
<p>JSON数据和Java对象转换：</p>
<p>​	Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，是目前Java语言中最快的JSON库，可以实现Java对象和JSON字符串的相互转换。</p>
<p>使用：</p>
<p>​	1.导入坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.Java对象转JSON</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String jsonstr = JSON.toJSONString(obj);</span><br></pre></td></tr></table></figure>

<p>​	3.JSON字符串转Java对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = JSON.parseObject(jsonStr,User.class);</span><br></pre></td></tr></table></figure>

<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue:"></a>Vue:</h2><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>Vue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写</p>
<p>基于MVVM思想，实现数据的双向绑定，将编程的关注点放在数据上</p>
<p>​	1.新建HTML页面，引入Vue.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.在JS代码区域中，创建Vue核心对象，进行数据绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">    	return &#123;username:&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​	3.编写视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;input name=&quot;username&quot; v-model=&quot;username&quot;&gt;</span><br><span class="line">	&#123;&#123;username&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="Element：-1"><a href="#Element：-1" class="headerlink" title="Element："></a>Element：</h2><p>饿了吗公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页</p>
<p>官网：<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a></p>
<h4 id="快速入门：-5"><a href="#快速入门：-5" class="headerlink" title="快速入门："></a>快速入门：</h4><p>​	1.引入Element的css，js文件和Vue.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.创建Vue核心对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​	3.复制官网</p>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><h3 id="表单验证："><a href="#表单验证：" class="headerlink" title="表单验证："></a>表单验证：</h3><p>1.当输入框失去焦点时，验证输入内容是否符合要求</p>
<p>​	获取表单输入框</p>
<p>​	绑定onblur事件</p>
<p>​	获取输入内容</p>
<p>​	判断是否符合规则</p>
<p>​	如果不符合规则，则显示错误提示信息</p>
<p>2.当点击注册按钮时，判断所有输入框的内容是否符合要求，如果不符合则阻止表单提交</p>
<p>​	获取表单对象</p>
<p>​	为表单对象绑定onsubmit</p>
<p>​	判断所有输入框是否符合要求，如果符合，则返回true，如果有一项不符合，则返回false</p>
<h3 id="用户登录："><a href="#用户登录：" class="headerlink" title="用户登录："></a>用户登录：</h3><h4 id="流程分析："><a href="#流程分析：" class="headerlink" title="流程分析："></a>流程分析：</h4><p>​	1.用户填写用户名和密码，提交到LoginServlet</p>
<p>​	2.在LoginServlet中使用MyBatis查询数据库，验证用户名和密码是否正确</p>
<p>​	3.如果正确，响应“登录成功，否则，登录失败</p>
<h4 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h4><p>1.准备html页面</p>
<p>2.在数据库中创建tb_user,在java包下的pojo下创建User类</p>
<p>3.在pom.xml中导入MyBatis，MySql驱动</p>
<p>4.创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件，UserMapper接口</p>
<h4 id="bug调试："><a href="#bug调试：" class="headerlink" title="bug调试："></a>bug调试：</h4><p>bug情况1：</p>
<p>Caused by: org.xml.sax.SAXParseException； lineNumber: 1； columnNumber: 1； 前言中不允许有内容。</p>
<p>​	检查<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=mybatis&spm=1001.2101.3001.7020">mybatis</a>-config.xml文件中<mapper resource="mapper\Mapper.xml">有没有引入对应的mapper.xml文件</mapper></p>
<h3 id="用户注册："><a href="#用户注册：" class="headerlink" title="用户注册："></a>用户注册：</h3><h4 id="流程分析：-1"><a href="#流程分析：-1" class="headerlink" title="流程分析："></a>流程分析：</h4><p>​	1.用户填写用户名，密码等，点击注册按钮，提交到RegisterServlet</p>
<p>​	2.在RegisterServlet中使用MyBatis保存数据</p>
<p>​	3，保存前，需要判断用户名是否已经存在</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-12 02:04:15" itemprop="dateCreated datePublished" datetime="2023-08-12T02:04:15+08:00">2023-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">乾</p>
  <div class="site-description" itemprop="description">写一个赚乾的程序</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
