<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="设计模式： 创建型模式：将对象的创建与使用分离 单例、原型、工厂方法、抽象工厂、建造者 结构型模式：描述如何将类或对象按某种布局组成更大的结构 代理、适配器、桥接、装饰、外观、享元、组合等 行为模式：描述类或对象之间怎么协作共同完成单个对象无法完成的任务 模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器 UML统一建模语言 定义了用例图、类图、对象图、状态图、活动">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2023/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="程序乾">
<meta property="og:description" content="设计模式： 创建型模式：将对象的创建与使用分离 单例、原型、工厂方法、抽象工厂、建造者 结构型模式：描述如何将类或对象按某种布局组成更大的结构 代理、适配器、桥接、装饰、外观、享元、组合等 行为模式：描述类或对象之间怎么协作共同完成单个对象无法完成的任务 模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器 UML统一建模语言 定义了用例图、类图、对象图、状态图、活动">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-13T15:49:13.699Z">
<meta property="article:modified_time" content="2023-08-14T13:05:05.654Z">
<meta property="article:author" content="乾">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>设计模式 | 程序乾</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序乾</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 23:49:13" itemprop="dateCreated datePublished" datetime="2023-08-13T23:49:13+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-14 21:05:05" itemprop="dateModified" datetime="2023-08-14T21:05:05+08:00">2023-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>设计模式：</p>
<p>创建型模式：将对象的创建与使用分离</p>
<p>单例、原型、工厂方法、抽象工厂、建造者</p>
<p>结构型模式：描述如何将类或对象按某种布局组成更大的结构</p>
<p>代理、适配器、桥接、装饰、外观、享元、组合等</p>
<p>行为模式：描述类或对象之间怎么协作共同完成单个对象无法完成的任务</p>
<p>模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器</p>
<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>统一建模语言</p>
<p>定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图</p>
<h2 id="类图："><a href="#类图：" class="headerlink" title="类图："></a>类图：</h2><p>显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
<h2 id="类图表示法："><a href="#类图表示法：" class="headerlink" title="类图表示法："></a>类图表示法：</h2><p>类使用包含类名、属性和方法且带有分割线的矩形表示。</p>
<p>属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性。</p>
<p>+：表示public</p>
<p>-：表示private</p>
<p>#：表示protected</p>
<h2 id="类之间的关系表示方式："><a href="#类之间的关系表示方式：" class="headerlink" title="类之间的关系表示方式："></a>类之间的关系表示方式：</h2><h3 id="关联关系："><a href="#关联关系：" class="headerlink" title="关联关系："></a>关联关系：</h3><p>1.单向关联</p>
<p>在UML中用一个带箭头的实线表示</p>
<p>2双向关联</p>
<p>在UML中用一个不带箭头的实线表示</p>
<p>3.自关联</p>
<h3 id="聚合关系："><a href="#聚合关系：" class="headerlink" title="聚合关系："></a>聚合关系：</h3><p>是关联关系的一种，强关联关系，是整体和部分之间的关系。</p>
<p>例如：学校与老师的关系，学校包含老师，学校停办，老师依然存在</p>
<p>在UML中，聚合关系用带空心的菱形实线表示，菱形指向整体</p>
<h3 id="组合关系："><a href="#组合关系：" class="headerlink" title="组合关系："></a>组合关系：</h3><p>组合关系表示类之间的整体与部分的关系，更强的聚合关系</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体不存在了，部分对象也将不存在了</p>
<p>在UML中，聚合关系用带实心的菱形实线表示，菱形指向整体</p>
<h3 id="依赖关系："><a href="#依赖关系：" class="headerlink" title="依赖关系："></a>依赖关系：</h3><p>一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性关系，在代码中，某个类的方法通过局部变量，方法的参数或者对静态方法的调用来访问另一个类中的某些方法来实现一些功能。</p>
<p>在UML中，使用带箭头的虚线来表示，箭头从使用类指向被依赖类。</p>
<h3 id="继承关系："><a href="#继承关系：" class="headerlink" title="继承关系："></a>继承关系：</h3><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系。</p>
<p>在UML中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。</p>
<h3 id="实现关系："><a href="#实现关系：" class="headerlink" title="实现关系："></a>实现关系：</h3><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>在UML类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</p>
<h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><h2 id="开闭原则："><a href="#开闭原则：" class="headerlink" title="开闭原则："></a>开闭原则：</h2><p>对扩展开放，对修改关闭。</p>
<p>要想达到这样的效果，我们需要使用接口和抽象类。</p>
<p>例子：搜狗输入法皮肤设计</p>
<h2 id="里氏代换原则："><a href="#里氏代换原则：" class="headerlink" title="里氏代换原则："></a>里氏代换原则：</h2><p>任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能，简单来说就是子类继承父类，尽量不要重写父类的方法</p>
<h2 id="依赖倒转原则："><a href="#依赖倒转原则：" class="headerlink" title="依赖倒转原则："></a>依赖倒转原则：</h2><p>高层模块不应该依赖底层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实习进行编程，降低客户与实现模块间的耦合。</p>
<p>例子：组装电脑</p>
<p>电脑需要配件CPU，硬盘，内存条。cpu可以有intel，amd；硬盘可以有希捷，等</p>
<h2 id="接口隔离原则："><a href="#接口隔离原则：" class="headerlink" title="接口隔离原则："></a>接口隔离原则：</h2><p>客户端不应该被迫依赖于它不使用的方法，<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>。</p>
<p>例子：安全门</p>
<p>安全门具有防火，防水，防盗的功能，可以将防火，防水，防盗功能各提取成一个接口，形成一套规范。</p>
<h2 id="迪米特法则："><a href="#迪米特法则：" class="headerlink" title="迪米特法则："></a>迪米特法则：</h2><p>最少知识原则。</p>
<p>如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转法该调用。降低类之间的耦合度。</p>
<p>例：明星和经纪人的关系</p>
<h2 id="合成复用原则："><a href="#合成复用原则：" class="headerlink" title="合成复用原则："></a>合成复用原则：</h2><p>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>类加载就会导致单例被创建</p>
<p>方式一：静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;&#125;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：静态代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton01 &#123;</span><br><span class="line">    private Singleton01()&#123;&#125;</span><br><span class="line">    private static Singleton01 instance;</span><br><span class="line">    static &#123;</span><br><span class="line">        instance = new Singleton01();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton01 getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>类加载不会导致单例被创建，首次调用才会创建。</p>
<p>方式一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line"></span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：加了synchronized锁，线程安全</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton01 &#123;</span><br><span class="line">    private Singleton01()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Singleton01 instance;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton01 getInstance()&#123;</span><br><span class="line"></span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            instance = new Singleton01();</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常见的一种单例模式。</p>
<p>方式三：双重锁也是一种比较常见的单例模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton02 &#123;</span><br><span class="line">    private Singleton02() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private  static volatile Singleton02 instance;</span><br><span class="line">    </span><br><span class="line">    public static Singleton02 getInstance()&#123;</span><br><span class="line">        if(instance==null)&#123;</span><br><span class="line">            synchronized (Singleton02.class)&#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton02();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式四：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton03 &#123;</span><br><span class="line">    private Singleton03()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Singleton03Holder&#123;</span><br><span class="line">        private static final Singleton03 instance = new Singleton03();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton03 getInstance()&#123;</span><br><span class="line">        return Singleton03Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式五：枚举方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton04 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>序列化反序列化会破坏单例模式</p>
<p>在singleton类中添加readResolve方法，在序列化和反序列化时就会返回这个方法的值</p>
<p>反射模式也会破坏单例模式</p>
<p>添加一个静态boolean属性做标志</p>
<h2 id="2-工厂模式："><a href="#2-工厂模式：" class="headerlink" title="2.工厂模式："></a>2.工厂模式：</h2><p>使用工厂生产对象，我们就只和工厂打交道，彻底和对象耦合</p>
<h3 id="简单工厂模式："><a href="#简单工厂模式：" class="headerlink" title="简单工厂模式："></a>简单工厂模式：</h3><p>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</p>
<p>具体产品：实现或继承产品的子类</p>
<p>具体工厂：提供了创建产品的方法，调用者通过该方法来获取产品</p>
<p>优点：</p>
<p>封装了创建对象的过程，可以通过参数直接获取对象，把对象的创建和业务逻辑层分开，避免了修改客户代码，实现新产品，直接修改工厂类即可</p>
<p>缺点：</p>
<p>增加新产品时，需要修改工厂类的代码，违背了“开闭原则”</p>
<h3 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h3><p>解决简单工厂模式违反开闭原则</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象，工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<p>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂方法来创建产品</p>
<p>抽象产品：主要是实现抽象工厂中的抽象方法，完成具体产品的创建</p>
<p>具体工厂：定义了产品的规范，描述了产品的主要特性和功能</p>
<p>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应</p>
<p>优点：</p>
<p>用户只需知道具体工厂就可以获取所需产品</p>
<p>在增加新产品时，只需添加具体产品类和对应的具体工厂类即可</p>
<p>缺点：</p>
<p>每增加一个产品，都要新增具体产品类和对应的具体工厂类</p>
<h3 id="抽象工厂模式："><a href="#抽象工厂模式：" class="headerlink" title="抽象工厂模式："></a>抽象工厂模式：</h3><p>工厂模式考虑的是一类产品的生产。</p>
<p>抽象工厂模式考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族</p>
<p>提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级产品的模式结构</p>
<p>抽象工厂：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品</p>
<p>具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建</p>
<p>抽象产品：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式由多个抽象产品</p>
<p>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</p>
<h2 id="3-原型模式："><a href="#3-原型模式：" class="headerlink" title="3.原型模式："></a>3.原型模式：</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的对象</p>
<p>抽象原型类：规定了具体原型对象必须实现clone() 方法</p>
<p>具体原型类：实现抽象原型类的clone() 方法，它是可以被复制的对象</p>
<p>访问类：使用具体原型类中clone() 方法来复制新的对象</p>
<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所执行的对象的内存地址</p>
<p>深克隆：闯将一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址</p>
<h2 id="4-建造者模式："><a href="#4-建造者模式：" class="headerlink" title="4.建造者模式："></a>4.建造者模式：</h2><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>分离了部件的构造和装配。从而可以构建出复杂的对象。</p>
<p>抽象建造者类：这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建。</p>
<p>具体建造者类：实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p>
<p>产品类：要创建的复杂对象。</p>
<p>指挥者类：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各个部分完整创建或者按某种顺序创建。</p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>描述如何将类或者对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。</p>
<h2 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h2><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问，这时，访问对象不适合或者不能直接引用个目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>抽象主题类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</p>
<p>真实主题类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</p>
<p>代理类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或者扩展真实主题的功能。</p>
<h4 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h4><p>案例：火车站卖票</p>
<p>火车站是目标对象，代售点是代理对象。</p>
<h4 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h4><p>JDK动态代理：</p>
<p>Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法。</p>
<h2 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h2><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h4 id="类适配器模式："><a href="#类适配器模式：" class="headerlink" title="类适配器模式："></a>类适配器模式：</h4><p>定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<h4 id="对象适配器模式："><a href="#对象适配器模式：" class="headerlink" title="对象适配器模式："></a>对象适配器模式：</h4><p>实现方式：对象适配器模式可采用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>注意：还有一个适配器模式</p>
<p>应用场景：</p>
<p>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致</p>
<p>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同</p>
<h4 id="JDK源码解析："><a href="#JDK源码解析：" class="headerlink" title="JDK源码解析："></a>JDK源码解析：</h4><p>Reader (字符流)、InputStream(字节流)的适配器使用的是InputStreamReader。</p>
<h2 id="装饰者模式："><a href="#装饰者模式：" class="headerlink" title="装饰者模式："></a>装饰者模式：</h2><p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<h3 id="装饰模式中的角色："><a href="#装饰模式中的角色：" class="headerlink" title="装饰模式中的角色："></a>装饰模式中的角色：</h3><p>抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象</p>
<p>具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责</p>
<p>抽象装饰角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</p>
<p>具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>比继承更加灵活的扩展性，继承是静态附加责任，装饰者是动态的附加责任</p>
<p>装饰类和被装饰类可以独立发展，不会互相耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类功能</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</p>
<p>不能继承的场景：扩展时造成子类爆炸，final修饰</p>
<p>在不影响其他对象的情况下，以动态，透明的方式给单个对象添加职责</p>
<p>当对象的功能可以动态地添加，也可以再动态地撤销</p>
<h3 id="JDK源码解析：-1"><a href="#JDK源码解析：-1" class="headerlink" title="JDK源码解析："></a>JDK源码解析：</h3><p>IO流中地包装类使用了装饰者模式。BufferedInputStream,BufferedOutputStream,BufferedReader,BufferedWriter</p>
<h2 id="桥接模式："><a href="#桥接模式：" class="headerlink" title="桥接模式："></a>桥接模式：</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>需要创建不同地图形，并且每个图形都可能有不同的颜色。</p>
<h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</p>
<h3 id="主要角色："><a href="#主要角色：" class="headerlink" title="主要角色："></a>主要角色：</h3><p>抽象化角色：定义抽象类，并包含一个对实现化对象的引用</p>
<p>扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</p>
<p>实现化角色：定义实现化角色的接口，供扩展抽象化角色调用</p>
<p>具体实现化角色：给出实现化角色的具体实现</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>提高了系统的可扩充性，在两个变化的维度中任意扩展一个维度，都不需要修改原有系统</p>
<p>实现细节对客户透明</p>
<h3 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h3><p>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时</p>
<p>当一个系统不希望使用继承或者因为多层次继承导致系统类的个数急剧增加时</p>
<p>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系</p>
<h2 id="外观模式："><a href="#外观模式：" class="headerlink" title="外观模式："></a>外观模式：</h2><h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><p>类似基金聚合了多个股票，我们买基金不用关心到底买了哪些股票</p>
<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节</p>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><p>降低了子系统与客户端之间的耦合，使得子系统的变化不会影响调用它的客户端</p>
<p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用容易</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>不符合开闭原则，修改麻烦</p>
<h2 id="组合模式："><a href="#组合模式：" class="headerlink" title="组合模式："></a>组合模式：</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
<h3 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h3><p>抽象根节点：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性</p>
<p>树枝节点：定义树枝节点的行为，存储字节点，组合树枝节点和叶子节点形成一个树形结构</p>
<p>叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位</p>
<h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p>软件菜单：</p>
<p>管理系统中，经常可以看到类似的菜单，一个菜单包含菜单项，也包含其他菜单项</p>
<h3 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h3><p>组合模式可以清楚定义分层次的复杂对象，表示对象的全部或部分层次</p>
<p>客户端可以一致地使用一个组合结构或者其中单个对象，不必关心处理的单个对象还是整个组合结构，简化了客户端代码</p>
<p>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类进行任何修改，符合“开闭原则”</p>
<p>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单</p>
<h2 id="享元模式："><a href="#享元模式：" class="headerlink" title="享元模式："></a>享元模式：</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>运用共享技术来有效地支持大量细粒度对象地复用。它通过共享已经存在的对象大幅度减少需要创建的对象数量，避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<h3 id="结构：-1"><a href="#结构：-1" class="headerlink" title="结构："></a>结构：</h3><p>内部状态：即不会随着环境的改变而改变的可共享部分</p>
<p>外部状态：指随着环境改变而改变的不可可共享的部分</p>
<p>主要角色：</p>
<p>抽象享元角色：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据，同时可以通过这些方法来设置外部数据</p>
<p>具体享元角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。</p>
<p>非享元角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建</p>
<p>享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在，则创建一个新的享元对象</p>
<h3 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h3><p>极大减少了内存中相似或相同对象数量，节约系统资源，提高系统性能</p>
<p>享元模式中外部状态相对独立，且不影响内部状态</p>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，它涉及算法与对象间职责的分配</p>
<p>行为模式分为类行为模式和对象行为模式。前者采用继承机制在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式有更大的灵活性。</p>
<h2 id="模板方法模式："><a href="#模板方法模式：" class="headerlink" title="模板方法模式："></a>模板方法模式：</h2><p>设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体环境相关</p>
<h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p>一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<h3 id="结构：-2"><a href="#结构：-2" class="headerlink" title="结构："></a>结构：</h3><p>抽象类：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成</p>
<p>​	模板方法：定义了算法骨架，按照某种顺序调用其包含的基本方法</p>
<p>​	基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。</p>
<p>​		抽象方法：一个抽象方法由抽象类声明，由其具体子类实现</p>
<p>​		具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承</p>
<p>​		钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种</p>
<p>​		一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXXX，返回类型为boolean</p>
<p>具体子类：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤</p>
<h3 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h3><p>提高代码复用性</p>
<p>实现了反转控制</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>每个实现都需要定义一个子类</p>
<p>提高了代码阅读的难度</p>
<h2 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h2><h3 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h3><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h3 id="结构：-3"><a href="#结构：-3" class="headerlink" title="结构："></a>结构：</h3><p>抽象策略类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有具体策略所需的接口</p>
<p>具体策略类：实现了抽象策略定义的接口，提供具体的算法实现或行为</p>
<p>环境类：持有一个策略类的引用，最终给客户端调用</p>
<h3 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h3><p>策略类直接按可以自由切换</p>
<p>易于扩展</p>
<p>避免使用多重条件选择语句，充分体现面向对象设计思想</p>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><p>客户端必须知道所有策略类，并自行决定使用哪一个策略类</p>
<p>策略模式将造成产生很多策略，可以通过使用享元模式在一定程度上减少对象的数量</p>
<h2 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>日常生活中，顾客点餐后把订单给服务员，服务员将订单给厨师，厨师出餐</p>
<h3 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h3><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开。这样两者之间通过命令对象进行沟通，这样方便命令对象进行存储，传递，调用，增加与管理</p>
<h3 id="结构：-4"><a href="#结构：-4" class="headerlink" title="结构："></a>结构：</h3><p>抽象命令类角色：定义命令的接口，声明执行的方法</p>
<p>具体命令角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成要执行的操作</p>
<p>实现者&#x2F;接收者角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能</p>
<p>调用者&#x2F;请求者角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多命令对象。这个客户端真正触发命令并要求命令执行相应操作的地方，也就是使用命令对象的入口</p>
<h3 id="优点：-7"><a href="#优点：-7" class="headerlink" title="优点："></a>优点：</h3><p>降低系统的耦合度</p>
<p>增减或删除命令非常方便</p>
<p>可以实现宏命令。命令模式可以和组合模式结合将多个命令装配成一个组合命令，即宏命令</p>
<p>方便实现undo和redo操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复</p>
<h3 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h3><p>使用命令模式可能会导致某些系统有过多的具体命令类</p>
<p>系统结构更加复杂</p>
<h3 id="JDK源码解析：-2"><a href="#JDK源码解析：-2" class="headerlink" title="JDK源码解析："></a>JDK源码解析：</h3><p>Runable是一个典型的命令模式</p>
<h2 id="责任链模式："><a href="#责任链模式：" class="headerlink" title="责任链模式："></a>责任链模式：</h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p>现实生活中，一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。</p>
<h3 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h3><p>为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一个对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿这条链传递，直到有对象处理它为止</p>
<h3 id="结构：-5"><a href="#结构：-5" class="headerlink" title="结构："></a>结构：</h3><p>抽象处理者角色：定义一个处理请求的接口，包含抽象处理方法和后一个连接</p>
<p>具体处理者角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者</p>
<p>客户类角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和传递过程</p>
<h3 id="优点：-8"><a href="#优点：-8" class="headerlink" title="优点："></a>优点：</h3><p>降低了对象之间的耦合度</p>
<p>增强了系统的可扩展性</p>
<p>增强了给对象指派职责的灵活性</p>
<p>责任链简化了对象之间的连接</p>
<p>责任分担</p>
<h3 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h3><p>不能保证每一个请求一定被处理</p>
<p>对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</p>
<p>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错</p>
<p>JavaWeb中的FilterChain就是职责链模式</p>
<h2 id="状态模式："><a href="#状态模式：" class="headerlink" title="状态模式："></a>状态模式：</h2><h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><p>通过按钮来控制电梯的状态，一个电梯门有开门，关门，运行，停止，每一种状态都需要根据其他状态来改变</p>
<h3 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h3><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象种，允许状态对象在其内部状态发生改变时改变其行为</p>
<h3 id="结构：-6"><a href="#结构：-6" class="headerlink" title="结构："></a>结构：</h3><p>环境角色：定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象处理</p>
<p>抽象状态角色：定义一个接口，用以封装环境对象种的特定状态所对应的行为</p>
<p>具体状态角色：实现抽象状态所对应的行为</p>
<h3 id="优点：-9"><a href="#优点：-9" class="headerlink" title="优点："></a>优点：</h3><p>将所有与某个状态有关的行为放到一个类种，并且可以方便增加新的状态，只需要改变对象状态即可改变对象的行为</p>
<p>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块</p>
<h3 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h3><p>状态模式的使用必然会增加系统类和对象的个数</p>
<p>状态模式和结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱</p>
<p>状态模式对“开闭原则”并不太支持</p>
<h2 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h2><h3 id="定义：-7"><a href="#定义：-7" class="headerlink" title="定义："></a>定义：</h3><p>发布订阅模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象变化时，会通知所有的观察者对象，使他们能够自动更新自己</p>
<h3 id="结构：-7"><a href="#结构：-7" class="headerlink" title="结构："></a>结构：</h3><p>抽象主题（被观察者）：抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象</p>
<p>具体主题（具体观察者）：该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知</p>
<p>抽象观察者：是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己</p>
<p>具体观察者：实现抽象观察者定义的更新接口，以便得到主题更改通知时更新自身的状态</p>
<h3 id="优点：-10"><a href="#优点：-10" class="headerlink" title="优点："></a>优点：</h3><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</p>
<p>被观察者发送通知，所有注册的观察者都会收到信息</p>
<h3 id="缺点：-6"><a href="#缺点：-6" class="headerlink" title="缺点："></a>缺点：</h3><p>如果观察者非常多，那么所有的观察者收到被观察者发送的通知会耗时</p>
<p>如果被观察者有循环依赖，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</p>
<h3 id="JDK实现："><a href="#JDK实现：" class="headerlink" title="JDK实现："></a>JDK实现：</h3><p>java.util.Observable类和java.util.Observer接口定义了观察者模式，只要实现他们的子类就可以编写观察者模式实例</p>
<h2 id="中介者模式："><a href="#中介者模式：" class="headerlink" title="中介者模式："></a>中介者模式：</h2><p>一般来说，多个类之间相互关联时，他们之间的关系会呈现复杂的网状结构，引入中介者模式，那么多个类之间通过中介者类相互关联</p>
<h3 id="定义：-8"><a href="#定义：-8" class="headerlink" title="定义："></a>定义：</h3><p>定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立改变他们之间的交互</p>
<h3 id="结构：-8"><a href="#结构：-8" class="headerlink" title="结构："></a>结构：</h3><p>抽象中介者：它是中介者的接口，提供了同事对象注册与转发信息的抽象方法</p>
<p>具体中介者：实现中介者接口，定义一个List来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同时角色</p>
<p>抽象同事类：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能</p>
<p>具体同事类：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互</p>
<h3 id="优点：-11"><a href="#优点：-11" class="headerlink" title="优点："></a>优点：</h3><p>松散耦合</p>
<p>集中控制交互</p>
<p>一对多关联转变为一对一的关联</p>
<h3 id="缺点：-7"><a href="#缺点：-7" class="headerlink" title="缺点："></a>缺点：</h3><p>当同事类太多，中介者的职责将很大，它会变得复杂庞大，以至于系统难以维护</p>
<h2 id="迭代器模式："><a href="#迭代器模式：" class="headerlink" title="迭代器模式："></a>迭代器模式：</h2><h3 id="定义：-9"><a href="#定义：-9" class="headerlink" title="定义："></a>定义：</h3><p>提供了一个对象来顺序访问聚合对象的一系列数据，而不暴露聚合对象的内部表示</p>
<h3 id="结构：-9"><a href="#结构：-9" class="headerlink" title="结构："></a>结构：</h3><p>抽象聚合角色：定义存储，添加，删除聚合元素以及创建迭代器对象的接口</p>
<p>具体聚合角色：实现抽象聚合类，返回一个具体迭代器的实例</p>
<p>抽象迭代器角色：定义访问和遍历聚合元素的接口，通常包含hasNext（），next（）等方法</p>
<p>具体迭代器角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</p>
<h3 id="优点：-12"><a href="#优点：-12" class="headerlink" title="优点："></a>优点：</h3><p>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来代替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式</p>
<p>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方式，这样可以简化聚合类的设计</p>
<p>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求</p>
<h2 id="访问者模式："><a href="#访问者模式：" class="headerlink" title="访问者模式："></a>访问者模式：</h2><h3 id="定义：-10"><a href="#定义：-10" class="headerlink" title="定义："></a>定义：</h3><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新操作</p>
<h3 id="结构：-10"><a href="#结构：-10" class="headerlink" title="结构："></a>结构：</h3><p>抽象访问者角色：定义了对每一个元素访问的行为，它的参数就时可以访问的元素，它的方法个数理论上来讲与元素个数是一样的，从这点不难看出，访问者模式要求元素的个数不能改变</p>
<p>具体访问者角色：给出对每一个元素类访问时所产生的具体行为</p>
<p>抽象元素角色：定义了一个接受访问者的方法，其意义指，每一个元素都要可以被访问者访问</p>
<p>具体元素角色：提供接受访问方法的具体实现，而这个具体实现，通常情况下是使用访问者提供的访问该元素类的方法</p>
<p>对象结构角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素，并且可以迭代这些元素，供访问者访问</p>
<h3 id="优点：-13"><a href="#优点：-13" class="headerlink" title="优点："></a>优点：</h3><p>扩展性好</p>
<p>复用性好</p>
<p>分离无关行为</p>
<h3 id="缺点：-8"><a href="#缺点：-8" class="headerlink" title="缺点："></a>缺点：</h3><p>对象结构变化很困难</p>
<p>违反了依赖倒置原则</p>
<h2 id="备忘录模式："><a href="#备忘录模式：" class="headerlink" title="备忘录模式："></a>备忘录模式：</h2><p>备往录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将记录状态复原，很多软件都提供撤销操作，如Word，记事本，Photoshop，IDEA等软件在编辑时按Ctrl+z组合键时能撤销当前操作</p>
<h3 id="定义：-11"><a href="#定义：-11" class="headerlink" title="定义："></a>定义：</h3><p>又叫快照模式。在不破坏封装性的前提下，铺货一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要将该对象恢复到原先保存的状态</p>
<h3 id="结构：-11"><a href="#结构：-11" class="headerlink" title="结构："></a>结构：</h3><p>发起人角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务，它可以访问备忘录里所有信息</p>
<p>备忘录角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人</p>
<p>管理者角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备往录的内容进行访问与修改</p>
<p>备忘录有两个等效接口：</p>
<p>窄接口：管理者对象看到的备忘录的窄接口，这个窄接口只允许他把备忘录对象传给其他对象</p>
<p>宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态</p>
<h2 id="解释器模式："><a href="#解释器模式：" class="headerlink" title="解释器模式："></a>解释器模式：</h2><h3 id="定义：-12"><a href="#定义：-12" class="headerlink" title="定义："></a>定义：</h3><p>给定一个语言，定义它的文法，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</p>
<h3 id="文法（语言）规则："><a href="#文法（语言）规则：" class="headerlink" title="文法（语言）规则："></a>文法（语言）规则：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expression::=value|plus|minus</span><br><span class="line">plus::=expression &#x27;+&#x27; expression</span><br></pre></td></tr></table></figure>

<h3 id="结构：-12"><a href="#结构：-12" class="headerlink" title="结构："></a>结构：</h3><p>抽象表达式角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法</p>
<p>终结符表达式角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每条规则都对应一个非终结符表达式</p>
<p>环境角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值</p>
<p>客户端：主要任务是将需要分析的句子或者表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5/" rel="prev" title="MySQL">
      <i class="fa fa-chevron-left"></i> MySQL
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/13/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="next" title="算法总结">
      算法总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#UML"><span class="nav-number">1.</span> <span class="nav-text">UML</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9B%BE%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">类图：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">类图表示法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">类之间的关系表示方式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">1.3.1.</span> <span class="nav-text">关联关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">1.3.2.</span> <span class="nav-text">聚合关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">1.3.3.</span> <span class="nav-text">组合关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">1.3.4.</span> <span class="nav-text">依赖关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">1.3.5.</span> <span class="nav-text">继承关系：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%EF%BC%9A"><span class="nav-number">1.3.6.</span> <span class="nav-text">实现关系：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">软件设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">开闭原则：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">里氏代换原则：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">2.3.</span> <span class="nav-text">依赖倒转原则：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">2.4.</span> <span class="nav-text">接口隔离原则：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%9A"><span class="nav-number">2.5.</span> <span class="nav-text">迪米特法则：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">2.6.</span> <span class="nav-text">合成复用原则：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">创建者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">1.单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">饿汉式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">懒汉式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.3.</span> <span class="nav-text">存在的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">2.工厂模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.2.1.</span> <span class="nav-text">简单工厂模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.2.2.</span> <span class="nav-text">工厂方法模式：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.2.3.</span> <span class="nav-text">抽象工厂模式：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.3.</span> <span class="nav-text">3.原型模式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">3.4.</span> <span class="nav-text">4.建造者模式：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.1.</span> <span class="nav-text">代理模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">静态代理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A"><span class="nav-number">4.1.0.2.</span> <span class="nav-text">动态代理：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.2.</span> <span class="nav-text">适配器模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.2.0.1.</span> <span class="nav-text">类适配器模式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.2.0.2.</span> <span class="nav-text">对象适配器模式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="nav-number">4.2.0.3.</span> <span class="nav-text">JDK源码解析：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.3.</span> <span class="nav-text">装饰者模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%EF%BC%9A"><span class="nav-number">4.3.1.</span> <span class="nav-text">装饰模式中的角色：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">4.3.2.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">4.3.3.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A-1"><span class="nav-number">4.3.4.</span> <span class="nav-text">JDK源码解析：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.4.</span> <span class="nav-text">桥接模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="nav-number">4.4.1.</span> <span class="nav-text">问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">4.4.2.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E8%A7%92%E8%89%B2%EF%BC%9A"><span class="nav-number">4.4.3.</span> <span class="nav-text">主要角色：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="nav-number">4.4.4.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="nav-number">4.4.5.</span> <span class="nav-text">使用场景：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.5.</span> <span class="nav-text">外观模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A-1"><span class="nav-number">4.5.1.</span> <span class="nav-text">问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="nav-number">4.5.2.</span> <span class="nav-text">概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="nav-number">4.5.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">4.5.4.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.6.</span> <span class="nav-text">组合模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9A-1"><span class="nav-number">4.6.1.</span> <span class="nav-text">概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">4.6.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-number">4.6.3.</span> <span class="nav-text">案例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="nav-number">4.6.4.</span> <span class="nav-text">优点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">4.7.</span> <span class="nav-text">享元模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="nav-number">4.7.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-1"><span class="nav-number">4.7.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-4"><span class="nav-number">4.7.3.</span> <span class="nav-text">优点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.1.</span> <span class="nav-text">模板方法模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-2"><span class="nav-number">5.1.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-2"><span class="nav-number">5.1.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-5"><span class="nav-number">5.1.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="nav-number">5.1.4.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.2.</span> <span class="nav-text">策略模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-3"><span class="nav-number">5.2.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-3"><span class="nav-number">5.2.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-6"><span class="nav-number">5.2.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="nav-number">5.2.4.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.3.</span> <span class="nav-text">命令模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="nav-number">5.3.1.</span> <span class="nav-text">问题描述：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-4"><span class="nav-number">5.3.2.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-4"><span class="nav-number">5.3.3.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-7"><span class="nav-number">5.3.4.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-3"><span class="nav-number">5.3.5.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9A-2"><span class="nav-number">5.3.6.</span> <span class="nav-text">JDK源码解析：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.4.</span> <span class="nav-text">责任链模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%EF%BC%9A-1"><span class="nav-number">5.4.1.</span> <span class="nav-text">问题描述：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-5"><span class="nav-number">5.4.2.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-5"><span class="nav-number">5.4.3.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-8"><span class="nav-number">5.4.4.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-4"><span class="nav-number">5.4.5.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.5.</span> <span class="nav-text">状态模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A-2"><span class="nav-number">5.5.1.</span> <span class="nav-text">问题：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-6"><span class="nav-number">5.5.2.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-6"><span class="nav-number">5.5.3.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-9"><span class="nav-number">5.5.4.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-5"><span class="nav-number">5.5.5.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.6.</span> <span class="nav-text">观察者模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-7"><span class="nav-number">5.6.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-7"><span class="nav-number">5.6.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-10"><span class="nav-number">5.6.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-6"><span class="nav-number">5.6.4.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">5.6.5.</span> <span class="nav-text">JDK实现：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.7.</span> <span class="nav-text">中介者模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-8"><span class="nav-number">5.7.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-8"><span class="nav-number">5.7.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-11"><span class="nav-number">5.7.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-7"><span class="nav-number">5.7.4.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.8.</span> <span class="nav-text">迭代器模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-9"><span class="nav-number">5.8.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-9"><span class="nav-number">5.8.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-12"><span class="nav-number">5.8.3.</span> <span class="nav-text">优点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.9.</span> <span class="nav-text">访问者模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-10"><span class="nav-number">5.9.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-10"><span class="nav-number">5.9.2.</span> <span class="nav-text">结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-13"><span class="nav-number">5.9.3.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-8"><span class="nav-number">5.9.4.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.10.</span> <span class="nav-text">备忘录模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-11"><span class="nav-number">5.10.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-11"><span class="nav-number">5.10.2.</span> <span class="nav-text">结构：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">5.11.</span> <span class="nav-text">解释器模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-12"><span class="nav-number">5.11.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E6%B3%95%EF%BC%88%E8%AF%AD%E8%A8%80%EF%BC%89%E8%A7%84%E5%88%99%EF%BC%9A"><span class="nav-number">5.11.2.</span> <span class="nav-text">文法（语言）规则：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%EF%BC%9A-12"><span class="nav-number">5.11.3.</span> <span class="nav-text">结构：</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">乾</p>
  <div class="site-description" itemprop="description">写一个赚乾的程序</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
