<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JavaJava的基础 String类：不可修改，底层用final修饰，不可变 StringBuilder：可以修改，没有用final修饰，线程不安全，效率高 StringBuffer：可以修改，没有用final修饰，线程安全，效率低 时间类的使用：LocalData类： ​	这种时间的表示是我们熟悉的日历表示法，与用来表示时间点的Data类不同。 1234567LocalData newYear">
<meta property="og:type" content="article">
<meta property="og:title" content="程序乾">
<meta property="og:url" content="http://example.com/2023/08/13/java%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="程序乾">
<meta property="og:description" content="JavaJava的基础 String类：不可修改，底层用final修饰，不可变 StringBuilder：可以修改，没有用final修饰，线程不安全，效率高 StringBuffer：可以修改，没有用final修饰，线程安全，效率低 时间类的使用：LocalData类： ​	这种时间的表示是我们熟悉的日历表示法，与用来表示时间点的Data类不同。 1234567LocalData newYear">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="f:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\a50f4bfbfbedab646e3082f0736ba6ca79311e22.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\image-20220802220651850.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\image-20220804143839334.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\image-20220804145417380.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\image-20220804145458929.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\image-20220804150033003.png">
<meta property="og:image" content="d:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\image-20220617153339026.png">
<meta property="article:published_time" content="2023-08-13T15:48:08.816Z">
<meta property="article:modified_time" content="2023-07-01T05:41:03.587Z">
<meta property="article:author" content="乾">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="f:\Apple\%E9%A1%B9%E7%9B%AE\%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%96%99\Typora\%E5%9B%BE%E7%89%87\aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png">

<link rel="canonical" href="http://example.com/2023/08/13/java%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | 程序乾</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序乾</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/java%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="乾">
      <meta itemprop="description" content="写一个赚乾的程序">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序乾">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-13 23:48:08" itemprop="dateCreated datePublished" datetime="2023-08-13T23:48:08+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-01 13:41:03" itemprop="dateModified" datetime="2023-07-01T13:41:03+08:00">2023-07-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java的基础"><a href="#Java的基础" class="headerlink" title="Java的基础"></a>Java的基础</h2><p><img src="F:\Apple\项目\研究生课程资料\Typora\图片\aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFNSU5RiVCQSVFNiU5QyVBQyVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCMSVCQiVFNSU5RSU4Qi5wbmc.png"></p>
<p>String类：不可修改，底层用final修饰，不可变</p>
<p>StringBuilder：可以修改，没有用final修饰，线程不安全，效率高</p>
<p>StringBuffer：可以修改，没有用final修饰，线程安全，效率低</p>
<h3 id="时间类的使用："><a href="#时间类的使用：" class="headerlink" title="时间类的使用："></a>时间类的使用：</h3><p>LocalData类：</p>
<p>​	这种时间的表示是我们熟悉的日历表示法，与用来表示时间点的Data类不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalData newYearsEve = LocalData.of(1999,12,31)</span><br><span class="line"></span><br><span class="line">int year = newYearsEve.getYear();</span><br><span class="line">int month = newYearsEve.getMonthValue();</span><br><span class="line">int day = newYearsEve.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">LocalData aThousandDayLater = newYearsEve.plusDays(1000)</span><br></pre></td></tr></table></figure>

<h3 id="变量和方法："><a href="#变量和方法：" class="headerlink" title="变量和方法："></a>变量和方法：</h3><p>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量，从本质上讲，变量就是内存中的一小块区域</p>
<h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量：方法的外部，类内部定义的变量</p>
<p>局部变量：类的方法中的变量</p>
<p>成员变量和局部变量的区别：</p>
<p>成员变量：针对整个类有效</p>
<p>局部变量：只在某个范围内有效</p>
<p>存储位置：</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中</p>
<p>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中，当方法调用完后，或者语句结束后，就会自动释放。</p>
<p>生命周期：</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p>
<p>局部变量：当方法调用完，或者语句结束后，就会自动释放</p>
<p>初始值：</p>
<p>成员变量：有默认初始值</p>
<p>局部变量：没有默认初始值，使用前必须赋值</p>
<h4 id="静态变量和实例变量和普通变量"><a href="#静态变量和实例变量和普通变量" class="headerlink" title="静态变量和实例变量和普通变量"></a>静态变量和实例变量和普通变量</h4><p>静态变量：由于不属于任何实例对像，属于类，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间</p>
<p>实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就会有几份成员变量</p>
<p>静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</p>
<p>静态方法和实例方法的区别主要体现在两个方面：</p>
<p>1.在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong>。<br>2.静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>成员内部类、局部内部类、匿名内部类和静态内部类</p>
<h4 id="静态内部类：定义在类内部的静态类"><a href="#静态内部类：定义在类内部的静态类" class="headerlink" title="静态内部类：定义在类内部的静态类"></a>静态内部类：定义在类内部的静态类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private static int radius = 1;</span><br><span class="line"> </span><br><span class="line">    static class StaticInner &#123;</span><br><span class="line">        public void visit() &#123;</span><br><span class="line">            System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner inner = new Outer.StaticInner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<p>静态内部类的创建方式：new 外部类。静态内部类（）</p>
<h4 id="成员内部类：定义在类内部，成员位置上的非静态类"><a href="#成员内部类：定义在类内部，成员位置上的非静态类" class="headerlink" title="成员内部类：定义在类内部，成员位置上的非静态类"></a>成员内部类：定义在类内部，成员位置上的非静态类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private static  int radius = 1;</span><br><span class="line">    private int count =2;</span><br><span class="line">    </span><br><span class="line">     class Inner &#123;</span><br><span class="line">        public void visit() &#123;</span><br><span class="line">            System.out.println(&quot;visit outer static  variable:&quot; + radius);</span><br><span class="line">            System.out.println(&quot;visit outer   variable:&quot; + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new Outer();</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br><span class="line">inner.visit();</span><br></pre></td></tr></table></figure>

<p>可以访问外部类的所有变量和方法，包括静态和非静态，创建方式new 内部类（）</p>
<h4 id="局部内部类：定义在方法中的内部类"><a href="#局部内部类：定义在方法中的内部类" class="headerlink" title="局部内部类：定义在方法中的内部类"></a>局部内部类：定义在方法中的内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private  int out_a = 1;</span><br><span class="line">    private static int STATIC_b = 2;</span><br><span class="line"> </span><br><span class="line">    public void testFunctionClass()&#123;</span><br><span class="line">        int inner_c =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void fun()&#123;</span><br><span class="line">                System.out.println(out_a);</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(inner_c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void testStaticFunctionClass()&#123;</span><br><span class="line">        int d =3;</span><br><span class="line">        class Inner &#123;</span><br><span class="line">            private void fun()&#123;</span><br><span class="line">                // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span><br><span class="line">                System.out.println(STATIC_b);</span><br><span class="line">                System.out.println(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner  inner = new Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void testStaticFunctionClass()&#123;</span><br><span class="line">   class Inner &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   Inner  inner = new Inner();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类-就是没有名字的内部类，日常开发中使用的比较多"><a href="#匿名内部类-就是没有名字的内部类，日常开发中使用的比较多" class="headerlink" title="匿名内部类:就是没有名字的内部类，日常开发中使用的比较多"></a>匿名内部类:就是没有名字的内部类，日常开发中使用的比较多</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line"> </span><br><span class="line">    private void test(final int i) &#123;</span><br><span class="line">        new Service() &#123;</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.println(&quot;匿名内部类&quot; );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> //匿名内部类必须继承或实现一个已有的接口 </span><br><span class="line"> interface Service&#123;</span><br><span class="line">    void method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类/接口&#123; </span><br><span class="line">  //匿名内部类实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IO流："><a href="#IO流：" class="headerlink" title="IO流："></a>IO流：</h3><p>按照流的流向分，可以分为输入流和输出流</p>
<p>按照操作单元划分，可以划分为字节流和字符流</p>
<p>按照流的角色划分，可以划分为节点流和处理流</p>
<p>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<h4 id="BIO-NIO-AIO有什么区别："><a href="#BIO-NIO-AIO有什么区别：" class="headerlink" title="BIO,NIO,AIO有什么区别："></a>BIO,NIO,AIO有什么区别：</h4><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h4 id="需要掌握的16种："><a href="#需要掌握的16种：" class="headerlink" title="需要掌握的16种："></a>需要掌握的16种：</h4><h5 id="文件专属："><a href="#文件专属：" class="headerlink" title="文件专属："></a>文件专属：</h5><p>​	java.io.FileInputSteam</p>
<p>​	java.io.FileOutputSteam</p>
<p>​	java.io.FileReader</p>
<pre><code> java.io.FileWriter
</code></pre>
<h5 id="转换流："><a href="#转换流：" class="headerlink" title="转换流："></a>转换流：</h5><p>​	java.io.InputStreamReader</p>
<p>​	java.io.OutputStreamWriter</p>
<h5 id="缓冲流专属："><a href="#缓冲流专属：" class="headerlink" title="缓冲流专属："></a>缓冲流专属：</h5><p>​	java.io.BufferedReader</p>
<p>​	java.io.BufferedWriter</p>
<p>​	java.io.BufferedInputSteam</p>
<p>​	java.io.BufferedOutputSteam</p>
<h5 id="数据流专属："><a href="#数据流专属：" class="headerlink" title="数据流专属："></a>数据流专属：</h5><p>​	java.io.PrintWriter</p>
<p>​	java.io.PrintStream</p>
<h5 id="对象流专属："><a href="#对象流专属：" class="headerlink" title="对象流专属："></a>对象流专属：</h5><p>​	java.io.ObjectInputStream</p>
<p>​	java.io.ObjectOutputStream</p>
<h4 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h4><p>Serialize: java对象存储到文件中</p>
<p>DeSerialize: 将硬盘上的数据重新恢复到内存当中，恢复成java对象</p>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h4><p>应用层的任务是通过应用进程间的交互来完成特定网络应用，应用层协议定义的应用进程间的通信和交互的规则。</p>
<p>运输层的主要任务是负责两台主机进程之间的通信提供通用的数据传输服务，运输层主要使用以下两种协议：</p>
<p>TCP-传输控制协议：面向连接的可靠的数据传输服务。</p>
<p>UDP-用户数据协议：提供无连接，尽最大努力的数据传输服务</p>
<p>TCP上运行的协议：</p>
<p>HTTP, HTTPS,FTP,POP3,SMTP,TELNET,SSH</p>
<p>UDP上运行的协议：</p>
<p>BOOTP, NTP,DHCP</p>
<p>注意：DNS域名服务，用于完成地址查找，邮件转发等工作，在TCP和UDP上都有运行</p>
<h3 id="集合容器"><a href="#集合容器" class="headerlink" title="集合容器"></a>集合容器</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>用于存储数据的容器</p>
<p>集合的特点：</p>
<p>对象封装数据，对象多了也需要存储，集合用于存储对象</p>
<p>对象的个数确定可以使用数组，对象的个数不确定的可以用集合，集合是可变长度的</p>
<p>常用的集合类型：</p>
<p>Map接口和Collection接口是所有集合框架的父接口：</p>
<p>1.Collection接口的子接口：Set接口和List接口</p>
<p>2.Map接口的实现类主要有：HashMap,TreeMap,Hashtable,ConcurrentHashMap,Properties</p>
<p>3.Set接口的实现类主要是：HashSet,TreeSet,LinkedHashSet</p>
<p>4.List接口的实现类主要是：ArrayList,LinkedList,Stack,Vector</p>
<p>List:一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector</p>
<p>Set:一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet</p>
<p>Map:一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象</p>
<p>哪些集合类是线程安全</p>
<p>vector：比arraylist多了个同步机制，因此线程安全，但效率比较低，不建议使用。</p>
<p>stack：堆栈类，先进后出</p>
<p>hashtable：比hashmap多了个线程安全</p>
<p>enumeration：枚举，相当于迭代器</p>
<h4 id="Collection接口："><a href="#Collection接口：" class="headerlink" title="Collection接口："></a>Collection接口：</h4><h5 id="1-List接口："><a href="#1-List接口：" class="headerlink" title="1.List接口："></a>1.List接口：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line">while(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">   *// do something*</span><br><span class="line">   it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(Integer i : list)&#123;</span><br><span class="line">   list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList和LinkedList的区别：</p>
<p>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。<br>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。<br>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。<br>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；<br>总结：</p>
<p>读取较多时用ArrayList，插入和删除较多时使用LinkedList</p>
<h5 id="2-Set接口"><a href="#2-Set接口" class="headerlink" title="2.Set接口"></a>2.Set接口</h5><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值</p>
<h5 id="3-Queue接口"><a href="#3-Queue接口" class="headerlink" title="3.Queue接口"></a>3.Queue接口</h5><h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>主要了解HashMap</p>
<h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><p>单核CPU，执行多线程并发其实是分时抢占。</p>
<p>实现线程：</p>
<h4 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a>java.lang.Thread</h4><p>编写一个类，集成该接口，重写run方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		//写子线程运行的程序</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>！！！myThread.start() —-启动一个分支线程，再JVM中开辟一个新栈的空间和myThread.run() — 实际是单线程，不会启动线程，不会分配新的栈</p>
<h4 id="java-lang-Runable"><a href="#java-lang-Runable" class="headerlink" title="java.lang.Runable"></a>java.lang.Runable</h4><p>编写一个类，实现Runable接口，实现run方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunable implements Runable&#123;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread t = new Thread(new MyRunable)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<h4 id="java-util-concurrent-Callable"><a href="#java-util-concurrent-Callable" class="headerlink" title="java.util.concurrent.Callable:"></a>java.util.concurrent.Callable:</h4><p>可以获取子线程的返回结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//第一步：创建一个未来任务类</span><br><span class="line">FutureTask task = new FutureTask(new Callable()&#123;</span><br><span class="line">	public Object call() throws Exception&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//创建线程对象</span><br><span class="line">Thread t = new Thread(task);</span><br><span class="line"></span><br><span class="line">//启动线程</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">//获取t线程的返回结果</span><br><span class="line">Object obj = task.get();</span><br></pre></td></tr></table></figure>



<h4 id="线程安全："><a href="#线程安全：" class="headerlink" title="线程安全："></a>线程安全：</h4><p>同步代码块synchronized</p>
<p>在实例方法上，一定锁的是this，一般不常用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//线程同步代码块，必须是多线程共享的数据才能达到多线程排队</span><br><span class="line">//sychroized()括号中填共享的对象</span><br><span class="line">sychronized()&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>！！！synchronized 在静态方法是类锁，类锁就只有一个 （排它锁）</p>
<h4 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class DeadLock&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Object o1 = new Object();</span><br><span class="line">		Object o1 = new Object();</span><br><span class="line">		Thread t1 = new MyThread1();</span><br><span class="line">		Thread t2 = new MyThread2();</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread1 extends Thread&#123;</span><br><span class="line">	Object 01;</span><br><span class="line">	Object o2;</span><br><span class="line">	public MyThread1(Object o1,Object o2)&#123;</span><br><span class="line">		this.o1 = o1;</span><br><span class="line">		this.o2 = o2;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">		synchronized(o1)&#123;</span><br><span class="line">			sychronized(o2)&#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread2 extends Thread&#123;</span><br><span class="line">	Object 01;</span><br><span class="line">	Object o2;</span><br><span class="line">	public MyThread1(Object o1,Object o2)&#123;</span><br><span class="line">		this.o1 = o1;</span><br><span class="line">		this.o2 = o2;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;</span><br><span class="line">        synchronized(o2)&#123;</span><br><span class="line">                sychronized(o1)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="守护线程："><a href="#守护线程：" class="headerlink" title="守护线程："></a>守护线程：</h4><p>又叫后台线程，一般守护线程是一个死循环，所有用户线程只要结束，守护线程自动结束</p>
<h4 id="生产者和消费者模式："><a href="#生产者和消费者模式：" class="headerlink" title="生产者和消费者模式："></a>生产者和消费者模式：</h4><h3 id="反射机制："><a href="#反射机制：" class="headerlink" title="反射机制："></a>反射机制：</h3><p>通过反射机制可以操作字节码文件。</p>
<p>java.lang.reflect.*包下</p>
<p>java.lang.Class: 代表整个字节码</p>
<p>java.lang.reflect.Method: 代表字节码中的方法字节码</p>
<p>java.lang.reflect.Constructor: 代表字节码中的构造方法</p>
<p>java.lang.reflect.Field: 代表字节码中属性的字节码</p>
<h3 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h3><p>Java中的锁分为显示锁和隐式锁。隐式锁由synchronized关键字实现，而显示锁是由实现了Lock接口和AQS框架等来实现。</p>
<h4 id="sychronized关键字："><a href="#sychronized关键字：" class="headerlink" title="sychronized关键字："></a>sychronized关键字：</h4><p>sychronized关键字的实现依赖于Java的对象头。</p>
<p>一个对象由三部分组成：对象头，实体数据，对齐填充。对象头的长度不是固定的，如果数据类型则对象头占12个字节，非数据类型对象头占8字节。</p>
<h4 id="无锁："><a href="#无锁：" class="headerlink" title="无锁："></a>无锁：</h4><p>不锁住资源，多个线程中有一个能修改资源成功，其他线程会重试</p>
<h4 id="偏向锁："><a href="#偏向锁：" class="headerlink" title="偏向锁："></a>偏向锁：</h4><p>一段同步代码、共享资源一直被一个线程方法调用，那么该线程自动获取锁，降低获取锁代价</p>
<h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h4><p>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。自旋次数有限，也就是我们所说的自适应锁。</p>
<h4 id="重量级锁："><a href="#重量级锁：" class="headerlink" title="重量级锁："></a>重量级锁：</h4><p>互斥锁，涉及到CPU的介入，获取不到锁的线程，会被阻塞</p>
<h4 id="AQS-AbstractQueuedSynchronizer-："><a href="#AQS-AbstractQueuedSynchronizer-：" class="headerlink" title="AQS(AbstractQueuedSynchronizer)："></a>AQS(AbstractQueuedSynchronizer)：</h4><p>是一种自旋锁，能确保无饥饿性，提供先来先服务的公平性。</p>
<h5 id="自旋锁-CLH-："><a href="#自旋锁-CLH-：" class="headerlink" title="自旋锁(CLH)："></a>自旋锁(CLH)：</h5><p>与互斥锁类似，在任何时候，最多只能有一个保持者。</p>
<p>互斥锁在资源被占用，资源申请者只能进入睡眠状态。</p>
<p>自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否自旋锁的保持者已经释放了锁。</p>
<p>CLH是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
<p><strong>具体流程：</strong></p>
<p>CLH队列中的节点QNode中含有一个locked字段，该字段若为true表示该线程需要获取锁，且不释放锁，为false表示线程释放了锁。节点之间通过隐形的链表相连(节点间没有明显的next指针)，通过myPred所指向的节点的变化情况来影响myNode的行为。</p>
<p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\a50f4bfbfbedab646e3082f0736ba6ca79311e22.png"></p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>​	Java 面向对象编程三大特性：封装 继承 多态</p>
<h4 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h4><p>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p>
<h4 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h4><p>提高代码的复用性</p>
<p>关于继承如下 3 点请记住：</p>
<ol>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h4 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h4><p>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p>
<p>多态的两种形式：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）</p>
<p>方法<strong>重载</strong>（overload）实现的是编译时的多态性（也称为前绑定），而方法<strong>重写</strong>（override）实现的是运行时的多态性（也称为后绑定）。</p>
<h2 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h2><p>哈希表：</p>
<p>集合——Collection 和 Map</p>
<p>Collection : List(可重复){ArrayList,LinkList}，Set(不可重复){HashSet,TreeSet}</p>
<p>Map: HashMap, TreeMap</p>
<h3 id="hashCode-介绍："><a href="#hashCode-介绍：" class="headerlink" title="hashCode()介绍："></a>hashCode()介绍：</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p>
<p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置</p>
<h3 id="最有效率计算乘法："><a href="#最有效率计算乘法：" class="headerlink" title="最有效率计算乘法："></a>最有效率计算乘法：</h3><p>2&lt;&lt;3(左移3位相当与乘以2的3次方，右移3位相当于除以2的3次方)</p>
<h3 id="值传递："><a href="#值传递：" class="headerlink" title="值传递："></a>值传递：</h3><p>java语言的方法调用只支持值传递。</p>
<p>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<p>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</p>
<h3 id="强制转型："><a href="#强制转型：" class="headerlink" title="强制转型："></a>强制转型：</h3><p>例如：float f &#x3D; (float)3.4</p>
<p>访问修饰符的使用情况：</p>
<p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlOUYlQkElRTclQTElODAlRTglQUYlQUQlRTYlQjMlOTUvSmF2YSVFOCVBRSVCRiVFOSU5NyVBRSVFNCVCRiVBRSVFOSVBNSVCMCVFNyVBQyVBNi5wbmc.png"></p>
<h3 id="和-的区别："><a href="#和-的区别：" class="headerlink" title="&amp;和&amp;&amp;的区别："></a>&amp;和&amp;&amp;的区别：</h3><p>&amp;&amp;是短路运算，左边的表达式的值是false,就不用看右边的表达式</p>
<h3 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="headerlink" title="final finally finalize区别"></a>final finally finalize区别</h3><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</p>
<h3 id="this关键字的用法："><a href="#this关键字的用法：" class="headerlink" title="this关键字的用法："></a>this关键字的用法：</h3><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p>
<p>1.直接引用，this相当于指向当前对象本身</p>
<p>2.形参与成员名字重名，用this区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person(String name, int age)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.引用本类的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this(name);</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="super关键字的用法："><a href="#super关键字的用法：" class="headerlink" title="super关键字的用法："></a>super关键字的用法：</h3><p>super可以理解为是指向自己父类对象的一个指针，而这个父类指的是离自己最近的一个父类。</p>
<p>1.直接引用</p>
<p>与this类似，可以super.xxx来引用父类的成员</p>
<p>2.子类的成员变量或方法与父类中的成员变量或方法同名时，用super区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    protected String name;</span><br><span class="line"> </span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public Student(String name, String name1) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.name = name1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void getInfo()&#123;</span><br><span class="line">        System.out.println(this.name);      //Child</span><br><span class="line">        System.out.println(super.name);     //Father</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Student s1 = new Student(&quot;Father&quot;,&quot;Child&quot;);</span><br><span class="line">       s1.getInfo();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.引用父类构造函数：</p>
<ul>
<li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li>
<li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li>
</ul>
<h3 id="static存在的主要意义："><a href="#static存在的主要意义：" class="headerlink" title="static存在的主要意义："></a>static存在的主要意义：</h3><p>static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！</p>
<p>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</p>
<ul>
<li>静态只能访问静态。</li>
<li>非静态既可以访问非静态的，也可以访问静态的。</li>
</ul>
<h3 id="break-continue-return-的区别及作用"><a href="#break-continue-return-的区别及作用" class="headerlink" title="break ,continue ,return 的区别及作用"></a>break ,continue ,return 的区别及作用</h3><ul>
<li><p>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</p>
</li>
<li><p>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</p>
</li>
<li><p>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</p>
</li>
<li><p>跳出多重嵌套循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ok:</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 10; j++) &#123;</span><br><span class="line">            System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);</span><br><span class="line">            if (j == 5) &#123;</span><br><span class="line">                break ok;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先级队列："><a href="#优先级队列：" class="headerlink" title="优先级队列："></a>优先级队列：</h3><p>队列遵循先进先出(First-In-First-Out)模型，但有时需要根据优先级处理队列中的对象。那么可使用Java PriorityQueue对象来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(</span><br><span class="line">        lists.length, (a, b)-&gt;(a.val - b.val));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类、接口"><a href="#类、接口" class="headerlink" title="类、接口"></a>类、接口</h2><h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><p>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</p>
<p>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<p>相同点：</p>
<p>接口和抽象类都不能实例化</p>
<p>都位于继承的顶端，用于被其他实现或继承</p>
<p>都包含抽象方法，其他子类都必须覆写这些抽象方法</p>
<p>不同点：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody></table>
<h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><p>类和类之间叫做继承，类和接口之间叫做实现</p>
<p>非抽象类实现接口的话，必须将接口中所有的抽象方法全部实现</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><h4 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h4><p>指向下一条jvm指令的执行地址</p>
<p>特点：</p>
<p>线程私有</p>
<p>不会溢出</p>
<h4 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>每个线程运行时所需要的内存，称为虚拟机栈</p>
<p>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</p>
<p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p>
<p>问题：方法内的局部变量是否是线程安全？</p>
<p>​	如果方法内局部变量没有逃离方法的作用范围，线程安全</p>
<p>​	如果方法内局部变量逃离了方法的作用范围，线程不安全</p>
<h5 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h5><p>递归没有设置终止条件</p>
<p>类的互相调用</p>
<h5 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h5><p>案例1：cpu占用过多</p>
<p>​	用top定位哪个进程对cpu占用过高</p>
<p>​	ps命令查看指定进程</p>
<p>​	jstack进程id找到有问题的进程</p>
<p>案例2：死锁</p>
<p>​	用jstack查找</p>
<h4 id="3本地方法栈"><a href="#3本地方法栈" class="headerlink" title="3本地方法栈"></a>3本地方法栈</h4><p>native 关键字标识的方法</p>
<h4 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h4><p>通过new关键字，创建对象都会使用堆内存</p>
<p>特点</p>
<p>它是线程共享，堆中对象需要考虑线程安全问题</p>
<p>垃圾回收机制会回收堆内的对象</p>
<h5 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h5><p>报错：java.lang.OutOfMemoryError:Java heap sapce</p>
<p>堆内存诊断</p>
<p>1.jps工具</p>
<p>​	查看当前系统中有哪些java进程</p>
<p>2.jmap工具</p>
<p>​	查看堆内存占用请款</p>
<p>3.jconsole工具</p>
<p>​	图形界面的，多功能的监测工具，可以连续监测</p>
<h4 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h4><p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\image-20220802220651850.png" alt="image-20220802220651850"></p>
<h5 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h5><p>1.8–java.lang.OutOfMemoryError:Metaspace</p>
<p>1.8以前–java.lang.OutOfMemoryError:PermGen space</p>
<h5 id="运行常量池"><a href="#运行常量池" class="headerlink" title="运行常量池"></a>运行常量池</h5><p>常量池就是一张表，虚拟机指令根据这张常量找到要执行的类名，方法名，参数类型，字面量等信息</p>
<p>运行时常量池，常量池是字节码文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p>
<h6 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h6><p>1.判断字符串是否相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &#x27;a&#x27;;</span><br><span class="line">String s2 = &#x27;b&#x27;;</span><br><span class="line">String s3 = &#x27;ab&#x27;;</span><br><span class="line">String s4 = s1+s2;</span><br><span class="line">String s5 = &#x27;a&#x27;+&#x27;b&#x27;;</span><br></pre></td></tr></table></figure>

<p>请问s3和s4相等吗？s3和s5呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3==s4 ; 错，s4是new出来的，在堆中，s3是在StringTable中</span><br><span class="line">s3==s5 ; 对，s3和s5都是在StringTable中</span><br></pre></td></tr></table></figure>

<h6 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调整 -XX:StringTableSize=桶的个数</span><br></pre></td></tr></table></figure>

<p>字符串入池</p>
<h4 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h4><p>常见于NIO操作时，用于数据缓冲区</p>
<p>分配回收成本较高，但读写性能高</p>
<p>不受JVM内存回收管理</p>
<p>底层使用了Unsafe对象完成直接内存的分配回收</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h4><p>1.1引用计数法</p>
<p>1.2可达性分析算法</p>
<p>扫描堆中的对象，看是否有root</p>
<p>1.3四种引用</p>
<p>强引用，软引用， 弱引用， 虚引用， 终结器引用</p>
<h4 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h4><p>（1）标记清除算法</p>
<p>（2）标记整理算法</p>
<p>（3）复制</p>
<h4 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3.分代垃圾回收机制"></a>3.分代垃圾回收机制</h4><p>MinorGC 处理新生代</p>
<p>FullGC 处理老年代和新生代</p>
<p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\image-20220804143839334.png" alt="image-20220804143839334"></p>
<h4 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h4><p>4.1串行</p>
<p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\image-20220804145417380.png" alt="image-20220804145417380"></p>
<p>4.2吞吐量</p>
<p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\image-20220804145458929.png" alt="image-20220804145458929"></p>
<p>4.3响应时间优先</p>
<p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\image-20220804150033003.png" alt="image-20220804150033003"></p>
<p>4.4 G1</p>
<p>适用场景：</p>
<p>同时注重吞吐量和低延迟，默认的暂停目标是200ms</p>
<p>超大堆内存，会将堆划分为多个大小相等的Region</p>
<p>整体上是标记+整理算法，两个区域之间是复制算法</p>
<p>相关JVM参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX：+UseG1GC</span><br><span class="line">-XX:G1HeapRegionSize=size</span><br><span class="line">-XX:ManGCPauseMillis=time</span><br></pre></td></tr></table></figure>

<h3 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h3><p>javap工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v HelloWorld.class</span><br></pre></td></tr></table></figure>





<h2 id="Java并发-1"><a href="#Java并发-1" class="headerlink" title="Java并发"></a>Java并发</h2><h3 id="案例1：多线程提升效率"><a href="#案例1：多线程提升效率" class="headerlink" title="案例1：多线程提升效率"></a>案例1：多线程提升效率</h3><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1.环境搭建"></a>1.环境搭建</h4><p>基准测试工具选择，使用了比较靠谱的JMH，他会执行程序预热，执行多次测试并平均</p>
<p>cpu核数限制，有两种思路</p>
<p>​	1.使用虚拟机，分配合适的核</p>
<p>​	2.使用msconfig，分配合适的核，需要重启比较麻烦</p>
<p>并行计算方式的选择</p>
<p>​	1.最初想直接使用parallel stream ，后来发现它自己有问题</p>
<p>​	2.改为了自己手动控制thread，实现简单的并行计算</p>
<h3 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h3><h4 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h4><p>1.直接使用Thread</p>
<p>2.使用Runable接口</p>
<p>Java8后可以使用lambda表达式精简</p>
<p>3.使用FutureTask 配合Thread</p>
<p>FutureTask能够接收Callable类型的参数，用来处理有返回结果的情况</p>
<h4 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h4><p>windows：</p>
<p>任务管理器可以产看进程和线程数</p>
<p>tasklist 查看进程</p>
<p>taskkill 杀死进程</p>
<p>linux：</p>
<p>ps -fe 查看进程</p>
<p>kill 杀死进程</p>
<p>Java：</p>
<p>jps 命令查看所有的Java进程</p>
<p>jstack <PID> 查看某个Java进程的所有线程状态</p>
<p>jconsole 来查看某个Java进程中线程的运行情况</p>
<h4 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h4><p>压栈</p>
<h4 id="线程的方法"><a href="#线程的方法" class="headerlink" title="线程的方法"></a>线程的方法</h4><h5 id="run和start"><a href="#run和start" class="headerlink" title="run和start"></a>run和start</h5><p>start才会启动新的线程，run并不会</p>
<h5 id="sleep和yield"><a href="#sleep和yield" class="headerlink" title="sleep和yield"></a>sleep和yield</h5><p>调用sleep会让线程从运行状态到TIMED_WATIING</p>
<p>其他线程可以使用interrupt打断正在睡眠的线程</p>
<p>调用yield会让当前线程从Running进入到Runable状态，然后调度执行其他线程</p>
<p>具体实现依赖于操作系统的任务调度器</p>
<h5 id="join方法详解"><a href="#join方法详解" class="headerlink" title="join方法详解"></a>join方法详解</h5><p>在start方法之后使用，可以确保线程运行完</p>
<h5 id="interrupt方法详解"><a href="#interrupt方法详解" class="headerlink" title="interrupt方法详解"></a>interrupt方法详解</h5><p>打断sleep，wait，join的线程</p>
<h5 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h5><p>在一个线程T1中终止线程T2</p>
<p>错误思路：</p>
<p>使用线程对象的stop（）方法停止线程，注意stop方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就没有机会释放锁，其他线程将永远无法获取锁</p>
<p>使用System.exit（int ）方法停止线程，目的仅是停止一个线程，但这种做法会让整个程序都停止</p>
<h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><p>线程优先级会提示调度器优先调度改线程，但仅仅是一个提示，调度器可以忽略</p>
<h4 id="主线程和守护线程"><a href="#主线程和守护线程" class="headerlink" title="主线程和守护线程"></a>主线程和守护线程</h4><p>垃圾回收器线程就是一种守护线程</p>
<p>Tomvat中Acceptor和Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待它们处理完当前请求</p>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>五种状态：初始状态，可运行状态（已经被创建），运行状态，阻塞状态（调用了阻塞API），终止状态</p>
<p>Java中六种状态：NEW,RUNNABLE,BLOKED,WAITING,TIMED_WAITING,TERMINATED</p>
<h3 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h3><h3 id="案例2-防止CPU占100"><a href="#案例2-防止CPU占100" class="headerlink" title="案例2-防止CPU占100%"></a>案例2-防止CPU占100%</h3><p>sleep实现</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>左子树&lt;根&lt;右子树</p>
<h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h4><p>每个左右子树的高度差不超过1</p>
<p>平衡因子BF，若BF&gt;1,平衡二叉树就失衡，需要旋转</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>一种自平衡二叉搜索树</p>
<p>查找、插入和删除操作，时间复杂度都是logN</p>
<h1 id="JDBC学习"><a href="#JDBC学习" class="headerlink" title="JDBC学习"></a>JDBC学习</h1><p>java语言操作关系型数据库的一套API</p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>0.创建工程，导入jar包</p>
<p>1.注册驱动—-Class.forName(“com.mysql.jdbc.Driver”)</p>
<p>2.获取连接—-Connection conn &#x3D; DriverManager.getConnection(url,username,password)</p>
<p>3.定义SQL语句—-String sql &#x3D; “updata …”</p>
<p>4.获取执行SQL对象—Statement stmt &#x3D; conn.createStatament();</p>
<p>5.执行SQL—-stmt.executeUpdate(sql);</p>
<p>6.处理结果返回</p>
<p>7.释放资源</p>
<h2 id="api详解："><a href="#api详解：" class="headerlink" title="api详解："></a>api详解：</h2><h3 id="Connection对象："><a href="#Connection对象：" class="headerlink" title="Connection对象："></a>Connection对象：</h3><p>获取sql对象：</p>
<p>事务管理功能：</p>
<p>开启事务—setAutoCommit(true or false)  &#x2F;&#x2F;true–auto </p>
<p>提交事务—commit()</p>
<p>回滚事务—rollback()</p>
<h3 id="Statement对象"><a href="#Statement对象" class="headerlink" title="Statement对象:"></a>Statement对象:</h3><p>1.执行SQL语句</p>
<p>​	int executeUpdate(sql)—执行DML,DDL语句</p>
<p>​	DML返回影响的行数，DDL执行成功后可能返回0</p>
<p>​	ResultSet executeQuery(sql)—执行DQL语句</p>
<pre><code> 返回值：ResultSet结果集对象
</code></pre>
<h3 id="ResultSet对象"><a href="#ResultSet对象" class="headerlink" title="ResultSet对象"></a>ResultSet对象</h3><p>1.封装了DQL查询语句的结果：</p>
<p>​	ResultSet  stmt.executeQuery(sql)—-执行DQL语句，返回ResultSet对象</p>
<h3 id="PreparedStatement对象："><a href="#PreparedStatement对象：" class="headerlink" title="PreparedStatement对象："></a>PreparedStatement对象：</h3><p>1.预编译SQL语句并执行，预防SQL注入问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义sql时用？作为占位符</span><br><span class="line">String sql = &quot;select * from tb_user where username = ? and password = ?&quot;</span><br><span class="line">PreparedStatement pstmt = conn.preparedStatement(sql);</span><br><span class="line"></span><br><span class="line">pstmt.setString(1,name);</span><br><span class="line">pstmt.setString(2,pwd);</span><br><span class="line"></span><br><span class="line">ResultSet rs = pstmt.excuteQuery();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Maven："><a href="#Maven：" class="headerlink" title="Maven："></a>Maven：</h1><p>Maven安装配置：</p>
<p>1.解压apache-maven-3.6.1.rar 既安装完成</p>
<p>2.配置环境变量 MAVEN_HOME 为安装路径的bin目录</p>
<p>3.配置本地仓库：修改 conf&#x2F;settings.xml 中的 <localRepository> 为一个指定目录</p>
<p>4.配置阿里云私服： 修改conf&#x2F;settings.xml 中的 <mirrors> 标签，为其添加如下子标签</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h2><p>complie —    clean—-   package—-</p>
<h2 id="IDEA配置MAVEN："><a href="#IDEA配置MAVEN：" class="headerlink" title="IDEA配置MAVEN："></a>IDEA配置MAVEN：</h2><p>1.选择IDEA中File—&gt;settings</p>
<p>2.搜索maven</p>
<p>3.设置IDEA使用本地安装的Maven，并修改配置文件路径</p>
<h2 id="Maven坐标详解："><a href="#Maven坐标详解：" class="headerlink" title="Maven坐标详解："></a>Maven坐标详解：</h2><p>Maven中坐标是资源的唯一标识</p>
<p>使用坐标来定义项目或引入项目中需要的依赖</p>
<p>坐标组成：</p>
<p>groupId —–&gt;定义当前Maven项目隶属组织名称</p>
<p>artifactId—–&gt;定义当前Maven项目名称（通常是模块名称，例如：order-service,goods-services）</p>
<p>version—–&gt;定义当前项目版本号</p>
<h2 id="依赖管理："><a href="#依赖管理：" class="headerlink" title="依赖管理："></a>依赖管理：</h2><p>使用坐标导入jar包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入mysql 驱动jar包--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>！！！点击刷新按钮</p>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis:"></a>MyBatis:</h1><p>定义：是一款优秀的持久层框架，用于简化JDBC开发</p>
<h2 id="持久层："><a href="#持久层：" class="headerlink" title="持久层："></a>持久层：</h2><p>负责将数据保存到数据库的那一层代码</p>
<p>JavaEE三层架构：表现层，业务层，持久层</p>
<h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><p>1.创建user表，添加数据</p>
<p>2.创建模块，导入坐标</p>
<p>3.编写MyBatis核心配置文件—&gt;替换连接信息，解决连接信息  解决硬编码问题</p>
<p>4.编写SQL映射文件—&gt;统一管理sql语句，解决硬编码问题</p>
<p>5.编码</p>
<h2 id="Mapper代理开发："><a href="#Mapper代理开发：" class="headerlink" title="Mapper代理开发："></a>Mapper代理开发：</h2><p>1.定义SQL映射文件同名的Mapper接口，并且将Mapper接口各SQL映射文件放置在统一目录下</p>
<p>2.设置SQL映射文件的namespace属性为Mapper接口全限定名</p>
<p>3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id，并保持参数类型和返回值类型一致</p>
<p>4.编码</p>
<p>​	1.通过 SqlSession 的 getMapper 方法获取 Mapper 接口的代理对象</p>
<p>​	2.调用对应方法完成sql的执行</p>
<h2 id="MyBatis核心配置："><a href="#MyBatis核心配置：" class="headerlink" title="MyBatis核心配置："></a>MyBatis核心配置：</h2><p>环境配置—&gt;可以配置多个环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://mybatis?useSSL=false&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br></pre></td></tr></table></figure>

<p>别名配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=&quot;com.qian.pojo&quot; /&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>

<p>那么在Resource-com.qian.mapper下的UserMapper.xml中resultType就可以不区分大小写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.qian.mapper.UserMapper&quot;&gt;</span><br><span class="line">	&lt;!-- &lt;select id=&quot;selectAll&quot; resultType=&quot;com.qian.pojo.User&quot;&gt; --&gt;</span><br><span class="line">    &lt;select id=&quot;selectAll&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">    select * from tb_user ;</span><br><span class="line">  	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>



<h2 id="配置文件完成增删改查："><a href="#配置文件完成增删改查：" class="headerlink" title="配置文件完成增删改查："></a>配置文件完成增删改查：</h2><h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>1.编写接口方法：Mapper接口</p>
<p>2.编写SQL语句：SQL映射文件：</p>
<p>3.执行方法，测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据</span><br></pre></td></tr></table></figure>

<p><img src="D:\Apple\项目\研究生课程资料\Typora\图片\image-20220617153339026.png" alt="image-20220617153339026"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据</span><br><span class="line"></span><br><span class="line">    1.解决方法：as 为实体类的属性名称</span><br><span class="line">        引用sql片段</span><br><span class="line">    2.使用resultMap</span><br><span class="line">    </span><br><span class="line">--&gt;</span><br><span class="line">&lt;resultMap id=&quot;brandResultMap&quot; type=&quot;Brand&quot;&gt;</span><br><span class="line">    &lt;result column=&quot;brand_name&quot; property=&quot;brandName&quot;/&gt;</span><br><span class="line">    &lt;result column=&quot;company_name&quot; property=&quot;companyName&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;sql id = &quot;brand_column&quot;&gt;id,brand_name as brandName,company_name as companyName,ordered,description,status&lt;/sql&gt;</span><br><span class="line">&lt;select id=&quot;selectAll&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">    select * from tb_brand;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="详细查询："><a href="#详细查询：" class="headerlink" title="详细查询："></a>详细查询：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    参数占位符：</span><br><span class="line">    1.#&#123;&#125; 会将其替换为 ？ 防止 sql注入</span><br><span class="line">    2.$&#123;&#125;  拼sql，会存在SQL注入</span><br><span class="line">    特殊字符的处理：</span><br><span class="line">        1.转移字符：&lt; - &amp;lt</span><br><span class="line">        2.CDATA区  &lt;![CDATA[ &lt; ]]&gt;</span><br><span class="line">    </span><br><span class="line">--&gt;</span><br><span class="line">&lt;select id=&quot;selectById&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">    select * from tb_brand where id = #&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h5><p>多条件查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    条件查询</span><br><span class="line"> --&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">    select * from tb_brand</span><br><span class="line">    where status = #&#123;status&#125;</span><br><span class="line">      and company_name like #&#123;companyName&#125;</span><br><span class="line">      and brand_name like #&#123;brandName&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h5 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询;"></a>动态查询;</h5><p>SQL语句随着用户的输入或者外部条件的变化而变化，称为动态SQL</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">        动态条件查询</span><br><span class="line">     --&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;selectByCondition&quot; resultMap=&quot;brandResultMap&quot;&gt;</span><br><span class="line">        select * from tb_brand</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;status != null&quot;&gt;status = #&#123;status&#125; &lt;/if&gt;</span><br><span class="line">            and &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;company_name like #&#123;companyName&#125;&lt;/if&gt;</span><br><span class="line">            and &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;brand_name like #&#123;brandName&#125;&lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="添加："><a href="#添加：" class="headerlink" title="添加："></a>添加：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加--&gt;</span><br><span class="line">&lt;insert id=&quot;add&quot;&gt;</span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<p>主键返回</p>
<p>设置useGeneratedKeys&#x3D;”true” 和 keyProperty&#x3D;”id”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;add&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h3 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h3><h5 id="修改全部字段："><a href="#修改全部字段：" class="headerlink" title="修改全部字段："></a>修改全部字段：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--修改--&gt;</span><br><span class="line">&lt;update id=&quot;updata&quot;&gt;</span><br><span class="line">    update tb_brand set brand_name = #&#123;brandName&#125;,</span><br><span class="line">     company_name = #&#123;companyName&#125;,</span><br><span class="line">     ordered = #&#123;ordered&#125;,</span><br><span class="line">     description = #&#123;description&#125;,</span><br><span class="line">     status = #&#123;status&#125;</span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<h5 id="修改动态字段："><a href="#修改动态字段：" class="headerlink" title="修改动态字段："></a>修改动态字段：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--修改--&gt;</span><br><span class="line">&lt;update id=&quot;updata&quot;&gt;</span><br><span class="line">    update tb_brand &lt;set&gt;</span><br><span class="line">    &lt;if test=&quot;brandName != null and brandName != &#x27;&#x27; &quot;&gt;</span><br><span class="line">        brand_name = #&#123;brandName&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;companyName != null and companyName != &#x27;&#x27; &quot;&gt;</span><br><span class="line">        company_name = #&#123;companyName&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;ordered != null &quot;&gt;</span><br><span class="line">        ordered = #&#123;ordered&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;description != null and description != &#x27;&#x27; &quot;&gt;</span><br><span class="line">        description = #&#123;description&#125;,&lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;status != null &quot;&gt;</span><br><span class="line">        status = #&#123;status&#125;&lt;/if&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line"></span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--删除--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteById&quot;&gt;</span><br><span class="line">    delete from tb_brand where id = #&#123;id&#125;;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p>批量删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis会将数组封装成一个Map集合</span><br><span class="line">    默认：array = 数组</span><br><span class="line">    使用@Param 注解改变map集合的默认key名称--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteByIds&quot;&gt;</span><br><span class="line">    delete from tb_brand where id in (</span><br><span class="line">    &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot;  separator=&quot;,&quot;&gt;</span><br><span class="line">      #&#123;id&#125;</span><br><span class="line">    &lt;/foreach&gt;)</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<h1 id="HTML："><a href="#HTML：" class="headerlink" title="HTML："></a>HTML：</h1><p>（Hyper Text Markup Language）</p>
<p>推荐的学习网站：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/">https://www.w3school.com.cn/</a></p>
<p>结构—-HTML</p>
<p>表现—-CSS</p>
<p>行为—-JavaScript</p>
<h2 id="基础标签："><a href="#基础标签：" class="headerlink" title="基础标签："></a>基础标签：</h2><table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><h1> ~ <h6></td>
<td>定义标题，h1最大，h6最小</td>
</tr>
<tr>
<td><font></td>
<td>定义文本的字体，字体尺寸，字体颜色</td>
</tr>
<tr>
<td><b></td>
<td>定义粗体文字</td>
</tr>
<tr>
<td><i></td>
<td>定义斜体文字</td>
</tr>
<tr>
<td><u></td>
<td>定义文本下划线</td>
</tr>
<tr>
<td><center></td>
<td>定义文本居中</td>
</tr>
<tr>
<td><p></td>
<td>定义段落</td>
</tr>
<tr>
<td><br></td>
<td>定义换行</td>
</tr>
<tr>
<td><hr></td>
<td>定义水平线</td>
</tr>
</tbody></table>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS:"></a>CSS:</h2><h3 id="CSS导入方式："><a href="#CSS导入方式：" class="headerlink" title="CSS导入方式："></a>CSS导入方式：</h3><p>1.内联样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;color:red&quot;&gt;Hello CSS&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>2.内部样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;dvi&#123;</span><br><span class="line">	dolor:red</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>3.外部样式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;demo.css&quot;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript:"></a>JavaScript:</h2><h3 id="JavaScript引入方式"><a href="#JavaScript引入方式" class="headerlink" title="JavaScript引入方式"></a>JavaScript引入方式</h3><p>1.内部脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	alter(&quot;hello JS&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2.外部脚本：</p>
<p>将JS代码定义在外部JS文件中，然后引入到HTML页面中</p>
<p>外部文件：demo.js</p>
<p>引入外部文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src = &quot;../js/demo.js&quot;&gt; &lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="JavaScript基础语法："><a href="#JavaScript基础语法：" class="headerlink" title="JavaScript基础语法："></a>JavaScript基础语法：</h3><h4 id="书写语法："><a href="#书写语法：" class="headerlink" title="书写语法："></a>书写语法：</h4><p>1.区分大小写</p>
<p>2.每行分号可有可无</p>
<p>3.注释：同java一样</p>
<p>4.大括号表示代码块</p>
<h4 id="输出语句："><a href="#输出语句：" class="headerlink" title="输出语句："></a>输出语句：</h4><p>使用window.alert() —–写入警告框</p>
<p>使用document.write() —–写入HTML输出</p>
<p>使用console.log() ——写入浏览控制台</p>
<h4 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h4><p>JavaScript 中使用 var 关键字表示变量</p>
<p>作用域： 1.全局变量  2.可以重复定义</p>
<p>！！！数字不能开头</p>
<p>ECMAScript 中新增了 let 关键字定义变量，它的用法类似于 var ，声明的变量所在代码块有效，不能重复定义 </p>
<p>ECMAScript 中新增了 const 关键字定义常量，一旦声明就不能改变</p>
<h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p>原始类型和引用类型：</p>
<p>5种原始类型：</p>
<p>​	number：数字（整数，小数，NaN（Not a Number））</p>
<p>​	string：字符，字符串，单双引皆可</p>
<p>​	boolean：布尔，</p>
<p>​	null：空</p>
<p>​	undefined：当声明变量未初始化时，该变量的默认值时undefined</p>
<p>同样可以使用 typeof 获取变量类型</p>
<h4 id="运算符："><a href="#运算符：" class="headerlink" title="运算符："></a>运算符：</h4><p>一元运算符：++，–</p>
<p>算术运算符：+，-，*，&#x2F;，%</p>
<p>赋值运算符：&#x3D;，+&#x3D;，-&#x3D;</p>
<p>关系运算符：&gt; , &lt;, &gt;&#x3D;, &lt;&#x3D;, !&#x3D;, &#x3D;&#x3D;, &#x3D;&#x3D;&#x3D;(全等)</p>
<p>逻辑运算符：&amp;&amp;， ||， ！</p>
<p>三元运算符：条件表达式？trut_value:fasle_value</p>
<p>注意：&#x3D;&#x3D; 时会进行类型转化 ，&#x3D;&#x3D;&#x3D; 时不会类型转化</p>
<p>其他类型转number：</p>
<p>​	1.string ：按照字符串的字面值，转数字，如果字面值不是数字，转为NaN  —parseInt(）</p>
<p>​	2.boolean:true—1,false—-0</p>
<p>其他类型转boolean：</p>
<p>​	1.number：0和NaN—–false，其他数字—–true</p>
<p>​	2.string：空字符串—–false，其他字符串—-true</p>
<p>​	3.null: false</p>
<p>​	4.undefined: false</p>
<h4 id="流程控制语句："><a href="#流程控制语句：" class="headerlink" title="流程控制语句："></a>流程控制语句：</h4><p>​	if:</p>
<p>​	switch:</p>
<p>​	for:</p>
<p>​	while:</p>
<p>​	do while:</p>
<h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><p>形参不需要类型，返回值也不用返回类型</p>
<h3 id="Array对象："><a href="#Array对象：" class="headerlink" title="Array对象："></a>Array对象：</h3><p>长度和类型可以变化</p>
<h3 id="String对象："><a href="#String对象：" class="headerlink" title="String对象："></a>String对象：</h3><p>length—-是属性，不是方法</p>
<h3 id="自定义对象："><a href="#自定义对象：" class="headerlink" title="自定义对象："></a>自定义对象：</h3><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var 对象名称&#123;</span><br><span class="line">	属性名称1：属性值1；</span><br><span class="line">	属性名称2：属性值2；</span><br><span class="line">	...</span><br><span class="line">	函数名称：function(形参列表)&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BOM对象：（浏览器对象模型）"><a href="#BOM对象：（浏览器对象模型）" class="headerlink" title="BOM对象：（浏览器对象模型）"></a>BOM对象：（浏览器对象模型）</h2><h4 id="window-浏览器窗口对象"><a href="#window-浏览器窗口对象" class="headerlink" title="window:浏览器窗口对象"></a>window:浏览器窗口对象</h4><p>获取：直接使用window,其中window.可以省略</p>
<p>属性：获取其他DOM对象</p>
<p>history: —–&gt; 对History对象的只读引用。</p>
<p>Navigator:—–&gt;对Navigator对象的只读引用。</p>
<p>Screen:——&gt;对Screen对象的只读引用。</p>
<p>location:——-&gt;用于窗口或框架的Location对象。</p>
<p>方法：</p>
<p>alert():——&gt;显示带有一段消息和一个确认按钮的警告框。</p>
<p>confirm():——&gt;显示带有一段消息以及确认按钮和取消按钮的对话框。</p>
<p>setInterval():—–&gt;按照指定的周期来调用函数或者计算表达式。</p>
<p>setTimeout():—–&gt;在指定的毫秒数后调用函数或计算表达式。</p>
<h4 id="History"><a href="#History" class="headerlink" title="History:"></a>History:</h4><p>历史记录</p>
<p>获取：使用window.history获取，其中window.可以省略</p>
<p>方法：</p>
<p>back() :—–&gt;加载history列表中的前一个URL</p>
<p>forward() :——&gt;加载history列表中的下一个URL</p>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location:"></a>Location:</h4><p>获取：使用window.history获取，其中window.可以省略</p>
<p>属性：href </p>
<h2 id="DOM对象：-文档对象模型"><a href="#DOM对象：-文档对象模型" class="headerlink" title="DOM对象：(文档对象模型)"></a>DOM对象：(文档对象模型)</h2><h4 id="Document："><a href="#Document：" class="headerlink" title="Document："></a>Document：</h4><p>整个文档对象</p>
<h4 id="Element："><a href="#Element：" class="headerlink" title="Element："></a>Element：</h4><p>元素对象</p>
<p>获取：使用Document对象的方法来获取</p>
<p>​	1.getElementById:根据id属性获取，返回一个Element对象</p>
<p>​	2.getElementByTagName:根据标签名获取，返回Element对象数组</p>
<p>​	3.getElementByName:根据name属性值获取，返回Element对象数组</p>
<p>​	4.getElementByClassName:根据class属性值获取，返回Element对象数组</p>
<h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute:"></a>Attribute:</h4><p>属性对象</p>
<h4 id="Text"><a href="#Text" class="headerlink" title="Text:"></a>Text:</h4><p>文本对象</p>
<h4 id="Comment："><a href="#Comment：" class="headerlink" title="Comment："></a>Comment：</h4><p>注释对象</p>
<h3 id="事件监听："><a href="#事件监听：" class="headerlink" title="事件监听："></a>事件监听：</h3><p>事件绑定</p>
<p>方式一：通过HTML标签中的事件属性进行绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;buttom&quot; onclick=&#x27;on()&#x27;&gt;</span><br><span class="line"></span><br><span class="line">function on()&#123;</span><br><span class="line">	alert(&quot;someone click the button&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：通过DOM元素属性绑定 (推荐使用这种方式)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; id = &quot;btn&quot;&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&quot;btn&quot;).onclick = function()&#123;</span><br><span class="line">	alert(&quot;someone click the button&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见事件</p>
<h2 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>​	1.直接量：注意不要加引号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = /^\w&#123;6,12&#125;$/;</span><br></pre></td></tr></table></figure>

<p>​	2.创建RegExp对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reg = new RegExp(&quot;^\\w&#123;6,12&#125;$&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>开始——– ^      结束———– $</p>
<p>[] ：——- 代表某个范围内的单个字符，比如：[0-9] 单个数字字符</p>
<p>. : ——— 代表任意单个字符，除了换行和行结束符</p>
<p>\w ：——– 代表单词字符：字母、数字、下划线(<em>)，相当于 [A-Za-z0-9</em>]</p>
<p>\d :代表数字字符：相当于[0-9]</p>
<p>量词</p>
<p>+：至少一个</p>
<p>*：零个或多个</p>
<p>？：零个或一个</p>
<p>{x}：x个</p>
<p>{m,}：至少m个</p>
<p>{m,n}：至少m个,最多n个</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>​	test(reg)</p>
<h1 id="Web核心："><a href="#Web核心：" class="headerlink" title="Web核心："></a>Web核心：</h1><h2 id="JavaWeb技术栈："><a href="#JavaWeb技术栈：" class="headerlink" title="JavaWeb技术栈："></a>JavaWeb技术栈：</h2><p>​	B&#x2F;S架构：Browser和Server，浏览器&#x2F;服务器架构模式</p>
<p>​		好处：容易维护升级，服务器端升级后，客户端无需任何部署就可以使用到新版本</p>
<p>​	静态资源：HTML，CSS，JavaScript，图片等，负责页面展示</p>
<p>​	动态资源：Sevlet，JSP等，负责逻辑处理</p>
<p>​	数据库：负责存储数据</p>
<p>​	HTTP协议：定义通信规则</p>
<p>​	Web服务器：负责解析HTTP协议，解析请求数据，并发送数据</p>
<h2 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h2><p>超文本传输协议，规定了浏览器和服务器之间数据传输的规则</p>
<h3 id="HTTP请求数据格式"><a href="#HTTP请求数据格式" class="headerlink" title="HTTP请求数据格式"></a>HTTP请求数据格式</h3><p>​	1.请求行：请求数据的第一行，其中GET表示请求方式，&#x2F;表示请求资源路径，HTTP&#x2F;1.1表示协议版本</p>
<p>​	2.请求头：第二行开始，格式为key:value形式</p>
<p>​	3.请求体：POST请求的最后一部分，存放请求参数</p>
<p>GET请求和POST请求：</p>
<p>​	1.GET请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</p>
<p>​	2.GET请求参数大小有限制，POST没有</p>
<h3 id="HTTP响应数据格式"><a href="#HTTP响应数据格式" class="headerlink" title="HTTP响应数据格式"></a>HTTP响应数据格式</h3><p>​	1.响应行：响应数据的第一行，其中HTTP&#x2F;1.1表示协议版本，200表示响应状态码，OK表示状态码描述</p>
<p>​	2.响应头：第二行开始，格式为key:value</p>
<p>​	3.响应体：最后一部分，存放响应数据</p>
<h3 id="响应状态码："><a href="#响应状态码：" class="headerlink" title="响应状态码："></a>响应状态码：</h3><table>
<thead>
<tr>
<th>状态码分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>响应中–临时状态码，表示请求已经接受，告诉客户端应该继续请求或者已经完成则忽略</td>
</tr>
<tr>
<td>2xx</td>
<td>成功–表示请求已经被成功接收，处理完成</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向—重定向到其他地方：它让客户端再发起一个请求以完成整个处理</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误—处理发生错误，责任再客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器端错误—处理发生错误，责任再服务端，如服务端抛出异常，路由出错，HTTP版本不对等</td>
</tr>
</tbody></table>
<p>状态码大全：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/chapter/13553">https://cloud.tencent.com/developer/chapter/13553</a></p>
<h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><p>Tomcat</p>
<h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><p>官网：<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">https://tomcat.apache.org/</a></p>
<h4 id="Tomcat–基本使用"><a href="#Tomcat–基本使用" class="headerlink" title="Tomcat–基本使用"></a>Tomcat–基本使用</h4><p>​	1.配置</p>
<p>​		1.修改启动端口号：conf&#x2F;server.xml</p>
<p>​		注意：HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，不用输入端口号</p>
<p>​	2.启动可能出现的问题</p>
<p>​		1.端口号冲突：找到对应程序，将其关闭掉</p>
<p>​		2.启动窗口一闪而过，检查JAVA_HOME环境变量是否配置正确</p>
<h4 id="项目部署："><a href="#项目部署：" class="headerlink" title="项目部署："></a>项目部署：</h4><h3 id="IDEA中创建Maven-Web项目"><a href="#IDEA中创建Maven-Web项目" class="headerlink" title="IDEA中创建Maven Web项目"></a>IDEA中创建Maven Web项目</h3><p>​	使用骨架：选择 create from apachetype</p>
<p>​	不使用骨架：不选择 create from apachetype</p>
<p>集成本地Tomcat：</p>
<p>使用Tomcat Maven插件：</p>
<p>在<plugins>中写下面代码，注意使用骨架时不能自动导包，把<pluginManagement>注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h2><p>​	Java中提供的一门动态web资源开发技术</p>
<p>​	是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</p>
<h3 id="快速入门：-1"><a href="#快速入门：-1" class="headerlink" title="快速入门："></a>快速入门：</h3><p>​	1.创建web项目，导入Servlet依赖坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">	&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.创建：定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class ServletDemo1 implements&#123;</span><br><span class="line">	public void service()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	3.配置：在类上使用@WebServlet 注解，配置该Servlet的访问路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/demo1&quot;)</span><br><span class="line">public class ServletDemo1 implements Servlet&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​	4.访问：启动Tomcat，浏览器输入URL，访问Servlet</p>
<h3 id="Servlet执行流程："><a href="#Servlet执行流程：" class="headerlink" title="Servlet执行流程："></a>Servlet执行流程：</h3><p>​	1.servlet由web服务器创建，servlet方法由web服务器调用</p>
<p>​	2.服务器怎么知道servlet中一定由servlet方法？</p>
<p>​	我们定义的servlet，必须实现servlet接口并复写其方法，而servlet接口中有servlet方法</p>
<h3 id="Servlet生命周期："><a href="#Servlet生命周期：" class="headerlink" title="Servlet生命周期："></a>Servlet生命周期：</h3><p>​	对象被创建到被销毁的整个过程</p>
<p>​	1.加载和实列化：默认情况下，当Servlet第一次被访问时，由容器创建Servelt对象</p>
<p>​	2.初始化：在实列化后，容器将调用servlet的init（）方法初始化对象，完成一些如加载配置文件，创建连接等初始化的工作，该方法只调用一次</p>
<p>​	3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service（）方法对请求进行处理</p>
<p>​	4.终止服务：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destory()方法完成资源的释放。</p>
<h3 id="Servlet体系结构："><a href="#Servlet体系结构：" class="headerlink" title="Servlet体系结构："></a>Servlet体系结构：</h3><p>​	HttpServlet使用步骤：</p>
<p>​		1.继承HttpServlet</p>
<p>​		2.重写doGet和doPost方法</p>
<h3 id="Servlet-urlPattern配置："><a href="#Servlet-urlPattern配置：" class="headerlink" title="Servlet urlPattern配置："></a>Servlet urlPattern配置：</h3><p>​	urlPattern配置规则：</p>
<p>​		1.精确匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;/demo03&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>​		2.目录匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;/demo03/*&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>​		3.扩展名匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;*.do&quot;&#125;)</span><br></pre></td></tr></table></figure>

<p>​		4.任意匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &#123;&quot;/&quot;&#125;)</span><br><span class="line">or</span><br><span class="line">@WebServlet(urlPatterns = &#123;&quot;/*&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Filter："><a href="#Filter：" class="headerlink" title="Filter："></a>Filter：</h2><p>过滤器可以把一些对资源的请求拦截，从而实现一些特殊功能</p>
<h3 id="快速入门：-2"><a href="#快速入门：-2" class="headerlink" title="快速入门："></a>快速入门：</h3><p>​	1.定义类，实现Filter接口，并重写方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class FilterDemo implemnets Filter&#123;</span><br><span class="line">	public void init(FilterConfig filterConfig);</span><br><span class="line">	public void doFilter(ServletRequest request,ServletResponse response);</span><br><span class="line">	public void destory()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	2.配置Filter拦截资源的路径，在类上定义@WebFilter注解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(&quot;/*&quot;)</span><br><span class="line">public class FilterDemo implements Filter&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	3.在doFilter方法中输出一句话，并放行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest request,ServletResponse response)&#123;</span><br><span class="line">	print(&quot;you can pass&quot;);</span><br><span class="line">	chain.doFilter(request,response),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Request-Response："><a href="#Request-Response：" class="headerlink" title="Request &amp;Response："></a>Request &amp;Response：</h2><h3 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h3><p>继承体系：</p>
<p>​	ServletRequest &lt;——HttpServletRequest &lt;——-RequestFacade</p>
<p>​	java提供的请求对象接口—-java提供的对http协议封装的请求接口对象—–Tomcat定义的实现类</p>
<p>获取请求数据：</p>
<p>​	1.请求行：</p>
<p>​		String getMethod()：获取请求方式 </p>
<p>​		String getContextPath()：获取虚拟目录（项目访问路径）</p>
<p>​		StringBuffer getRequestURL()：获取URL（统一资源定位符）</p>
<p>​		String getRequestURI()：获取URI（统一资源标识符）</p>
<p>​		String getQueryString()：获取请求参数</p>
<p>​	2.请求头：</p>
<p>​		String getHeader(String name):根据请求头名称，获取值</p>
<p>​	3.请求体：</p>
<p>​		ServletInputStream getInputStream() :获取字节输入流</p>
<p>​		BufferedReader getReader() : 获取字符输入流</p>
<h3 id="Response："><a href="#Response：" class="headerlink" title="Response："></a>Response：</h3><p>转发和重定向</p>
<p>重定向：</p>
<p>​	找别人处理，状态码设置302，重定向的url </p>
<p>Response响应字符数据：</p>
<p>​	1.通过Response对象获取字符输出流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.获取字符输出流</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        resp.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);</span><br><span class="line">        writer.write(&quot;aaaa&quot;);</span><br><span class="line">        writer.write(&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        //细节：流不需要关闭</span><br></pre></td></tr></table></figure>

<p>​	2.通过Response对象获取字节输出流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.读取文件</span><br><span class="line">        FileInputStream fileInputStream = new FileInputStream(&quot;C:\\Users\\peanut\\Pictures\\test\\6.jpg&quot;);</span><br><span class="line"></span><br><span class="line">        //2.获取字节输出流</span><br><span class="line">        ServletOutputStream outputStream = resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        //完成流的copy</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while((len = fileInputStream.read(bytes))!=-1)&#123;</span><br><span class="line">            outputStream.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fileInputStream.close();</span><br></pre></td></tr></table></figure>



<h2 id="JSP："><a href="#JSP：" class="headerlink" title="JSP："></a>JSP：</h2><p>全称Java Sever Pages ，java服务端页面</p>
<p>一种动态的网页技术，其中既可以定义HTML，JS，CSS等静态内容，还可以定义Java代码的动态内容</p>
<p>JSP&#x3D;HTML+Java</p>
<h2 id="MVC模式："><a href="#MVC模式：" class="headerlink" title="MVC模式："></a>MVC模式：</h2><p>​	Model：业务模式，处理业务</p>
<p>​	View：视图，展示页面</p>
<p>​	Controller：控制器，处理请求，调用模型和视图</p>
<h3 id="三层架构："><a href="#三层架构：" class="headerlink" title="三层架构："></a>三层架构：</h3><p>表现层：</p>
<p>​	接受请求，封装数据，调用业务逻辑层，响应数据</p>
<p>​	com.qian.web&#x2F;controller</p>
<p>业务逻辑层：</p>
<p>​	对业务逻辑进行封装，组合数据访问层的基本功能，形成复杂的业务逻辑功能</p>
<p>​	com.qian.service</p>
<p>数据访问层：</p>
<p>​	对数据库的CRUD基本操作</p>
<p>​	com.qian.mapper&#x2F;dao</p>
<h2 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h2><p>异步的JavaScript和XML</p>
<p>AJAX作用：</p>
<p>​	1.与服务器进行数据交换：通过AJAX可以给服务器发送请求，并获取服务器响应的数据</p>
<p>​	2.异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用校验，等等。。。</p>
<h4 id="快速入门：-3"><a href="#快速入门：-3" class="headerlink" title="快速入门："></a>快速入门：</h4><p>​	1.编写AjaxServlet，并使用response输出字符串</p>
<p>​	2.创建XMLHttpRequest对象：用于和服务器交换数据</p>
<p>​	3.向服务器发送请求</p>
<p>​	4.获取服务器响应数据</p>
<h4 id="AXIOS异步框架："><a href="#AXIOS异步框架：" class="headerlink" title="AXIOS异步框架："></a>AXIOS异步框架：</h4><h5 id="快速入门：-4"><a href="#快速入门：-4" class="headerlink" title="快速入门："></a>快速入门：</h5><p>​	1.引入axios的js文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/axios-0.18.0.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.使用axios发送请求，并获取响应结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	method:&quot;get&quot;,</span><br><span class="line">	url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span><br><span class="line">&#125;).then(function(resp)&#123;</span><br><span class="line">	alert(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	method:&quot;post&quot;,</span><br><span class="line">	url:&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;</span><br><span class="line">	data:&quot;username=zhangsan&quot;</span><br><span class="line">&#125;).then(function(resp)&#123;</span><br><span class="line">	alert(resp.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h5><p>​	概念：JavaScript对象表示方式</p>
<p>​	由于结构简单，层次鲜明，现多用于作为数据载体，在网络中进行数据传输</p>
<p>JavaScript对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	name:&quot;zhangsan&quot;,</span><br><span class="line">	age:23,</span><br><span class="line">	city:&quot;北京&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:&quot;zhangsan&quot;,</span><br><span class="line">	&quot;age&quot;:23,</span><br><span class="line">	&quot;city&quot;:&quot;北京&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础语法：</p>
<p>JSON数据和Java对象转换：</p>
<p>​	Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的JSON库，是目前Java语言中最快的JSON库，可以实现Java对象和JSON字符串的相互转换。</p>
<p>使用：</p>
<p>​	1.导入坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.Java对象转JSON</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String jsonstr = JSON.toJSONString(obj);</span><br></pre></td></tr></table></figure>

<p>​	3.JSON字符串转Java对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = JSON.parseObject(jsonStr,User.class);</span><br></pre></td></tr></table></figure>

<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue:"></a>Vue:</h2><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>Vue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写</p>
<p>基于MVVM思想，实现数据的双向绑定，将编程的关注点放在数据上</p>
<p>​	1.新建HTML页面，引入Vue.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.在JS代码区域中，创建Vue核心对象，进行数据绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el:&quot;#app&quot;,</span><br><span class="line">    data()&#123;</span><br><span class="line">    	return &#123;username:&quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>​	3.编写视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;input name=&quot;username&quot; v-model=&quot;username&quot;&gt;</span><br><span class="line">	&#123;&#123;username&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>



<h2 id="Element：-1"><a href="#Element：-1" class="headerlink" title="Element："></a>Element：</h2><p>饿了吗公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页</p>
<p>官网：<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">https://element.eleme.cn/#/zh-CN</a></p>
<h4 id="快速入门：-5"><a href="#快速入门：-5" class="headerlink" title="快速入门："></a>快速入门：</h4><p>​	1.引入Element的css，js文件和Vue.js</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;element-ui/lib/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;element-ui/lib/theme-chalk/index.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​	2.创建Vue核心对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el:&quot;#app&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​	3.复制官网</p>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><h3 id="表单验证："><a href="#表单验证：" class="headerlink" title="表单验证："></a>表单验证：</h3><p>1.当输入框失去焦点时，验证输入内容是否符合要求</p>
<p>​	获取表单输入框</p>
<p>​	绑定onblur事件</p>
<p>​	获取输入内容</p>
<p>​	判断是否符合规则</p>
<p>​	如果不符合规则，则显示错误提示信息</p>
<p>2.当点击注册按钮时，判断所有输入框的内容是否符合要求，如果不符合则阻止表单提交</p>
<p>​	获取表单对象</p>
<p>​	为表单对象绑定onsubmit</p>
<p>​	判断所有输入框是否符合要求，如果符合，则返回true，如果有一项不符合，则返回false</p>
<h3 id="用户登录："><a href="#用户登录：" class="headerlink" title="用户登录："></a>用户登录：</h3><h4 id="流程分析："><a href="#流程分析：" class="headerlink" title="流程分析："></a>流程分析：</h4><p>​	1.用户填写用户名和密码，提交到LoginServlet</p>
<p>​	2.在LoginServlet中使用MyBatis查询数据库，验证用户名和密码是否正确</p>
<p>​	3.如果正确，响应“登录成功，否则，登录失败</p>
<h4 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h4><p>1.准备html页面</p>
<p>2.在数据库中创建tb_user,在java包下的pojo下创建User类</p>
<p>3.在pom.xml中导入MyBatis，MySql驱动</p>
<p>4.创建mybatis-config.xml核心配置文件，UserMapper.xml映射文件，UserMapper接口</p>
<h4 id="bug调试："><a href="#bug调试：" class="headerlink" title="bug调试："></a>bug调试：</h4><p>bug情况1：</p>
<p>Caused by: org.xml.sax.SAXParseException； lineNumber: 1； columnNumber: 1； 前言中不允许有内容。</p>
<p>​	检查<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=mybatis&spm=1001.2101.3001.7020">mybatis</a>-config.xml文件中<mapper resource="mapper\Mapper.xml"/>有没有引入对应的mapper.xml文件</p>
<h3 id="用户注册："><a href="#用户注册：" class="headerlink" title="用户注册："></a>用户注册：</h3><h4 id="流程分析：-1"><a href="#流程分析：-1" class="headerlink" title="流程分析："></a>流程分析：</h4><p>​	1.用户填写用户名，密码等，点击注册按钮，提交到RegisterServlet</p>
<p>​	2.在RegisterServlet中使用MyBatis保存数据</p>
<p>​	3，保存前，需要判断用户名是否已经存在</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/12/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/13/SQL%E8%AF%AD%E5%8F%A5%EF%BC%9A/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">Java的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">1.1.1.</span> <span class="nav-text">时间类的使用：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">1.1.2.</span> <span class="nav-text">变量和方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">成员变量和局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">静态变量和实例变量和普通变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%86%85%E9%83%A8%E7%9A%84%E9%9D%99%E6%80%81%E7%B1%BB"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">静态内部类：定义在类内部的静态类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%86%85%E9%83%A8%EF%BC%8C%E6%88%90%E5%91%98%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E7%B1%BB"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">成员内部类：定义在类内部，成员位置上的非静态类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">局部内部类：定义在方法中的内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB-%E5%B0%B1%E6%98%AF%E6%B2%A1%E6%9C%89%E5%90%8D%E5%AD%97%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83%E5%A4%9A"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">匿名内部类:就是没有名字的内部类，日常开发中使用的比较多</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%B5%81%EF%BC%9A"><span class="nav-number">1.1.4.</span> <span class="nav-text">IO流：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO-NIO-AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">BIO,NIO,AIO有什么区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%8416%E7%A7%8D%EF%BC%9A"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">需要掌握的16种：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%93%E5%B1%9E%EF%BC%9A"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">文件专属：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81%EF%BC%9A"><span class="nav-number">1.1.4.2.2.</span> <span class="nav-text">转换流：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E4%B8%93%E5%B1%9E%EF%BC%9A"><span class="nav-number">1.1.4.2.3.</span> <span class="nav-text">缓冲流专属：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%93%E5%B1%9E%EF%BC%9A"><span class="nav-number">1.1.4.2.4.</span> <span class="nav-text">数据流专属：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81%E4%B8%93%E5%B1%9E%EF%BC%9A"><span class="nav-number">1.1.4.2.5.</span> <span class="nav-text">对象流专属：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9A"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">序列化：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.5.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">TCP&#x2F;IP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.6.</span> <span class="nav-text">集合容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">Collection接口：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-List%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="nav-number">1.1.6.2.1.</span> <span class="nav-text">1.List接口：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Set%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.6.2.2.</span> <span class="nav-text">2.Set接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Queue%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.6.2.3.</span> <span class="nav-text">3.Queue接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">Map接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.1.7.</span> <span class="nav-text">多线程：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-lang-Thread"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">java.lang.Thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-lang-Runable"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">java.lang.Runable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-util-concurrent-Callable"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">java.util.concurrent.Callable:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">线程安全：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%EF%BC%9A"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">死锁：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="nav-number">1.1.7.6.</span> <span class="nav-text">守护线程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">1.1.7.7.</span> <span class="nav-text">生产者和消费者模式：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-number">1.1.8.</span> <span class="nav-text">反射机制：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">1.1.9.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sychronized%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">sychronized关键字：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E9%94%81%EF%BC%9A"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">无锁：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81%EF%BC%9A"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">偏向锁：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">轻量级锁：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A"><span class="nav-number">1.1.9.5.</span> <span class="nav-text">重量级锁：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-AbstractQueuedSynchronizer-%EF%BC%9A"><span class="nav-number">1.1.9.6.</span> <span class="nav-text">AQS(AbstractQueuedSynchronizer)：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-CLH-%EF%BC%9A"><span class="nav-number">1.1.9.6.1.</span> <span class="nav-text">自旋锁(CLH)：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">面向对象的三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%EF%BC%9A"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">封装：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">继承：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%EF%BC%9A"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">多态：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">零碎知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode-%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="nav-number">1.3.1.</span> <span class="nav-text">hashCode()介绍：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E8%AE%A1%E7%AE%97%E4%B9%98%E6%B3%95%EF%BC%9A"><span class="nav-number">1.3.2.</span> <span class="nav-text">最有效率计算乘法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9A"><span class="nav-number">1.3.3.</span> <span class="nav-text">值传递：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E5%9E%8B%EF%BC%9A"><span class="nav-number">1.3.4.</span> <span class="nav-text">强制转型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">1.3.5.</span> <span class="nav-text">&amp;和&amp;&amp;的区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final-finally-finalize%E5%8C%BA%E5%88%AB"><span class="nav-number">1.3.6.</span> <span class="nav-text">final finally finalize区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="nav-number">1.3.7.</span> <span class="nav-text">this关键字的用法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="nav-number">1.3.8.</span> <span class="nav-text">super关键字的用法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E6%84%8F%E4%B9%89%EF%BC%9A"><span class="nav-number">1.3.9.</span> <span class="nav-text">static存在的主要意义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-continue-return-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.10.</span> <span class="nav-text">break ,continue ,return 的区别及作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%9A"><span class="nav-number">1.3.11.</span> <span class="nav-text">优先级队列：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">类、接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%EF%BC%9A"><span class="nav-number">1.4.1.</span> <span class="nav-text">类：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="nav-number">1.4.2.</span> <span class="nav-text">接口：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.5.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.</span> <span class="nav-text">内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">1.程序计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">2.虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.5.1.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">1.5.1.2.2.</span> <span class="nav-text">栈内存溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="nav-number">1.5.1.2.3.</span> <span class="nav-text">线程运行诊断</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">3本地方法栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%A0%86"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">4.堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">1.5.1.4.1.</span> <span class="nav-text">堆内存溢出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">5.方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">1.5.1.5.1.</span> <span class="nav-text">方法区内存溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.5.1.5.2.</span> <span class="nav-text">运行常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.5.1.5.2.1.</span> <span class="nav-text">面试题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#StringTable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">1.5.1.5.2.2.</span> <span class="nav-text">StringTable性能调优</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">6.直接内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.5.2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">1.如何判断对象可以回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">2.垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">3.分代垃圾回收机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">4.垃圾回收器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="nav-number">1.5.3.</span> <span class="nav-text">类加载与字节码技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91-1"><span class="nav-number">1.6.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B1%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87"><span class="nav-number">1.6.1.</span> <span class="nav-text">案例1：多线程提升效率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">1.环境搭建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.2.</span> <span class="nav-text">Java线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">创建和运行线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">查看进程线程的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">线程运行原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">线程的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#run%E5%92%8Cstart"><span class="nav-number">1.6.2.4.1.</span> <span class="nav-text">run和start</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sleep%E5%92%8Cyield"><span class="nav-number">1.6.2.4.2.</span> <span class="nav-text">sleep和yield</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#join%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.6.2.4.3.</span> <span class="nav-text">join方法详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#interrupt%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.6.2.4.4.</span> <span class="nav-text">interrupt方法详解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.2.4.5.</span> <span class="nav-text">两阶段终止模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.6.2.4.6.</span> <span class="nav-text">线程优先级</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">主线程和守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">线程状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B"><span class="nav-number">1.6.3.</span> <span class="nav-text">共享模型之管程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B2-%E9%98%B2%E6%AD%A2CPU%E5%8D%A0100"><span class="nav-number">1.6.4.</span> <span class="nav-text">案例2-防止CPU占100%</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.1.1.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">平衡二叉树(AVL)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">红黑树</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC%E5%AD%A6%E4%B9%A0"><span class="nav-number">3.</span> <span class="nav-text">JDBC学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">3.1.</span> <span class="nav-text">快速入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#api%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">api详解：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Connection%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">3.2.1.</span> <span class="nav-text">Connection对象：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Statement%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.2.</span> <span class="nav-text">Statement对象:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResultSet%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.3.</span> <span class="nav-text">ResultSet对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PreparedStatement%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">3.2.4.</span> <span class="nav-text">PreparedStatement对象：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Maven%EF%BC%9A"><span class="nav-number">4.</span> <span class="nav-text">Maven：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">4.1.</span> <span class="nav-text">Maven 常用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IDEA%E9%85%8D%E7%BD%AEMAVEN%EF%BC%9A"><span class="nav-number">4.2.</span> <span class="nav-text">IDEA配置MAVEN：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven%E5%9D%90%E6%A0%87%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="nav-number">4.3.</span> <span class="nav-text">Maven坐标详解：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="nav-number">4.4.</span> <span class="nav-text">依赖管理：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyBatis"><span class="nav-number">5.</span> <span class="nav-text">MyBatis:</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82%EF%BC%9A"><span class="nav-number">5.1.</span> <span class="nav-text">持久层：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A"><span class="nav-number">5.2.</span> <span class="nav-text">快速入门：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mapper%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91%EF%BC%9A"><span class="nav-number">5.3.</span> <span class="nav-text">Mapper代理开发：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="nav-number">5.4.</span> <span class="nav-text">MyBatis核心配置：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%8C%E6%88%90%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%9A"><span class="nav-number">5.5.</span> <span class="nav-text">配置文件完成增删改查：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="nav-number">5.5.1.</span> <span class="nav-text">查询：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="nav-number">5.5.1.0.1.</span> <span class="nav-text">详细查询：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="nav-number">5.5.1.0.2.</span> <span class="nav-text">条件查询：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.5.1.0.3.</span> <span class="nav-text">动态查询;</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%EF%BC%9A"><span class="nav-number">5.5.2.</span> <span class="nav-text">添加：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%EF%BC%9A"><span class="nav-number">5.5.3.</span> <span class="nav-text">修改：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%85%A8%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="nav-number">5.5.3.0.1.</span> <span class="nav-text">修改全部字段：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%8A%A8%E6%80%81%E5%AD%97%E6%AE%B5%EF%BC%9A"><span class="nav-number">5.5.3.0.2.</span> <span class="nav-text">修改动态字段：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%EF%BC%9A"><span class="nav-number">5.5.4.</span> <span class="nav-text">删除：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML%EF%BC%9A"><span class="nav-number">6.</span> <span class="nav-text">HTML：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A0%87%E7%AD%BE%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">基础标签：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text"> ~ </span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">7.0.0.0.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS"><span class="nav-number">7.1.</span> <span class="nav-text">CSS:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">7.1.1.</span> <span class="nav-text">CSS导入方式：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript"><span class="nav-number">7.2.</span> <span class="nav-text">JavaScript:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.1.</span> <span class="nav-text">JavaScript引入方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="nav-number">7.2.2.</span> <span class="nav-text">JavaScript基础语法：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A6%E5%86%99%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">书写语法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%EF%BC%9A"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">输出语句：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="nav-number">7.2.2.3.</span> <span class="nav-text">变量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="nav-number">7.2.2.4.</span> <span class="nav-text">数据类型：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="nav-number">7.2.2.5.</span> <span class="nav-text">运算符：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A"><span class="nav-number">7.2.2.6.</span> <span class="nav-text">流程控制语句：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">7.2.2.7.</span> <span class="nav-text">函数：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">7.2.3.</span> <span class="nav-text">Array对象：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">7.2.4.</span> <span class="nav-text">String对象：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="nav-number">7.2.5.</span> <span class="nav-text">自定义对象：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BOM%E5%AF%B9%E8%B1%A1%EF%BC%9A%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%89"><span class="nav-number">7.3.</span> <span class="nav-text">BOM对象：（浏览器对象模型）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#window-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.3.0.1.</span> <span class="nav-text">window:浏览器窗口对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#History"><span class="nav-number">7.3.0.2.</span> <span class="nav-text">History:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Location"><span class="nav-number">7.3.0.3.</span> <span class="nav-text">Location:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM%E5%AF%B9%E8%B1%A1%EF%BC%9A-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.4.</span> <span class="nav-text">DOM对象：(文档对象模型)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Document%EF%BC%9A"><span class="nav-number">7.4.0.1.</span> <span class="nav-text">Document：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Element%EF%BC%9A"><span class="nav-number">7.4.0.2.</span> <span class="nav-text">Element：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Attribute"><span class="nav-number">7.4.0.3.</span> <span class="nav-text">Attribute:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Text"><span class="nav-number">7.4.0.4.</span> <span class="nav-text">Text:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Comment%EF%BC%9A"><span class="nav-number">7.4.0.5.</span> <span class="nav-text">Comment：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%EF%BC%9A"><span class="nav-number">7.4.1.</span> <span class="nav-text">事件监听：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="nav-number">7.5.</span> <span class="nav-text">正则表达式：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">7.5.0.1.</span> <span class="nav-text">定义：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="nav-number">7.5.0.2.</span> <span class="nav-text">语法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">7.5.0.3.</span> <span class="nav-text">方法：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web%E6%A0%B8%E5%BF%83%EF%BC%9A"><span class="nav-number">8.</span> <span class="nav-text">Web核心：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaWeb%E6%8A%80%E6%9C%AF%E6%A0%88%EF%BC%9A"><span class="nav-number">8.1.</span> <span class="nav-text">JavaWeb技术栈：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%EF%BC%9A"><span class="nav-number">8.2.</span> <span class="nav-text">HTTP：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.2.1.</span> <span class="nav-text">HTTP请求数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.2.2.</span> <span class="nav-text">HTTP响应数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%9A"><span class="nav-number">8.2.3.</span> <span class="nav-text">响应状态码：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">8.3.</span> <span class="nav-text">Web服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">8.3.1.</span> <span class="nav-text">基本使用：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tomcat%E2%80%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">Tomcat–基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%EF%BC%9A"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">项目部署：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDEA%E4%B8%AD%E5%88%9B%E5%BB%BAMaven-Web%E9%A1%B9%E7%9B%AE"><span class="nav-number">8.3.2.</span> <span class="nav-text">IDEA中创建Maven Web项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlet%EF%BC%9A"><span class="nav-number">8.4.</span> <span class="nav-text">Servlet：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A-1"><span class="nav-number">8.4.1.</span> <span class="nav-text">快速入门：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">8.4.2.</span> <span class="nav-text">Servlet执行流程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="nav-number">8.4.3.</span> <span class="nav-text">Servlet生命周期：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-number">8.4.4.</span> <span class="nav-text">Servlet体系结构：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet-urlPattern%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="nav-number">8.4.5.</span> <span class="nav-text">Servlet urlPattern配置：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filter%EF%BC%9A"><span class="nav-number">8.5.</span> <span class="nav-text">Filter：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A-2"><span class="nav-number">8.5.1.</span> <span class="nav-text">快速入门：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Request-Response%EF%BC%9A"><span class="nav-number">8.6.</span> <span class="nav-text">Request &amp;Response：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Request%EF%BC%9A"><span class="nav-number">8.6.1.</span> <span class="nav-text">Request：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response%EF%BC%9A"><span class="nav-number">8.6.2.</span> <span class="nav-text">Response：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSP%EF%BC%9A"><span class="nav-number">8.7.</span> <span class="nav-text">JSP：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC%E6%A8%A1%E5%BC%8F%EF%BC%9A"><span class="nav-number">8.8.</span> <span class="nav-text">MVC模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%EF%BC%9A"><span class="nav-number">8.8.1.</span> <span class="nav-text">三层架构：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AJAX%EF%BC%9A"><span class="nav-number">8.9.</span> <span class="nav-text">AJAX：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A-3"><span class="nav-number">8.9.0.1.</span> <span class="nav-text">快速入门：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AXIOS%E5%BC%82%E6%AD%A5%E6%A1%86%E6%9E%B6%EF%BC%9A"><span class="nav-number">8.9.0.2.</span> <span class="nav-text">AXIOS异步框架：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A-4"><span class="nav-number">8.9.0.2.1.</span> <span class="nav-text">快速入门：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSON%EF%BC%9A"><span class="nav-number">8.9.0.2.2.</span> <span class="nav-text">JSON：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue"><span class="nav-number">8.10.</span> <span class="nav-text">Vue:</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="nav-number">8.10.0.1.</span> <span class="nav-text">介绍：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Element%EF%BC%9A-1"><span class="nav-number">8.11.</span> <span class="nav-text">Element：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%9A-5"><span class="nav-number">8.11.0.1.</span> <span class="nav-text">快速入门：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="nav-number">8.12.</span> <span class="nav-text">案例：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%EF%BC%9A"><span class="nav-number">8.12.1.</span> <span class="nav-text">表单验证：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%EF%BC%9A"><span class="nav-number">8.12.2.</span> <span class="nav-text">用户登录：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A"><span class="nav-number">8.12.2.1.</span> <span class="nav-text">流程分析：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%EF%BC%9A"><span class="nav-number">8.12.2.2.</span> <span class="nav-text">环境准备：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bug%E8%B0%83%E8%AF%95%EF%BC%9A"><span class="nav-number">8.12.2.3.</span> <span class="nav-text">bug调试：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%EF%BC%9A"><span class="nav-number">8.12.3.</span> <span class="nav-text">用户注册：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%EF%BC%9A-1"><span class="nav-number">8.12.3.1.</span> <span class="nav-text">流程分析：</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">乾</p>
  <div class="site-description" itemprop="description">写一个赚乾的程序</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
